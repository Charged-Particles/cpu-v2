{
  "language": "Solidity",
  "sources": {
    "@opengsn/gsn/contracts/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\n// solhint-disable no-inline-assembly\npragma solidity ^0.6.2;\n\nimport \"./interfaces/IRelayRecipient.sol\";\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\nabstract contract BaseRelayRecipient is IRelayRecipient {\n\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address public trustedForwarder;\n\n    function isTrustedForwarder(address forwarder) public override view returns(bool) {\n        return forwarder == trustedForwarder;\n    }\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, return the original sender.\n     * otherwise, return `msg.sender`.\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal override virtual view returns (address payable ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal override virtual view returns (bytes memory ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // we copy the msg.data , except the last 20 bytes (and update the total length)\n            assembly {\n                let ptr := mload(0x40)\n                // copy only size-20 bytes\n                let size := sub(calldatasize(),20)\n                // structure RLP data as <offset> <length> <bytes>\n                mstore(ptr, 0x20)\n                mstore(add(ptr,32), size)\n                calldatacopy(add(ptr,64), 0, size)\n                return(ptr, add(size,64))\n            }\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "@opengsn/gsn/contracts/interfaces/IRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.6.2;\n\n/**\n * a contract must implement this interface in order to support relayed transaction.\n * It is better to inherit the BaseRelayRecipient as its implementation.\n */\nabstract contract IRelayRecipient {\n\n    /**\n     * return if the forwarder is trusted to forward relayed transactions to us.\n     * the forwarder is required to verify the sender's signature, and verify\n     * the call is not a replay.\n     */\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\n     * of the msg.data.\n     * otherwise, return `msg.sender`\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal virtual view returns (address payable);\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal virtual view returns (bytes memory);\n\n    function versionRecipient() external virtual view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721MetadataUpgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"../../introspection/ERC165Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/EnumerableSetUpgradeable.sol\";\nimport \"../../utils/EnumerableMapUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable, IERC721EnumerableUpgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.UintToAddressMap;\n    using StringsUpgradeable for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSetUpgradeable.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721Upgradeable.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721Upgradeable.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721ReceiverUpgradeable(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n    uint256[41] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableMapUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMapUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"../../GSN/Context.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor (string memory uri) public {\n        _setURI(uri);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC1155Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    constructor() public {\n        _registerInterface(\n            ERC1155Receiver(0).onERC1155Received.selector ^\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // If there is no base URI, return the token URI.\n        if (bytes(_baseURI).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n    external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        return _get(map, key, \"EnumerableMap: nonexistent key\");\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = byte(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/v1/ChargedManagers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ChargedSettings.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"./interfaces/IChargedManagers.sol\";\nimport \"./interfaces/IChargedSettings.sol\";\nimport \"./interfaces/IChargedState.sol\";\nimport \"./interfaces/ITokenInfoProxy.sol\";\n\nimport \"./lib/TokenInfo.sol\";\nimport \"./lib/BlackholePrevention.sol\";\n\n/**\n * @notice Charged Particles Wallet-Managers Contract\n */\ncontract ChargedManagers is\n  IChargedManagers,\n  Initializable,\n  OwnableUpgradeable,\n  BlackholePrevention\n{\n  using SafeMathUpgradeable for uint256;\n  using TokenInfo for address;\n\n  IChargedSettings internal _chargedSettings;\n  IChargedState internal _chargedState;\n  ITokenInfoProxy internal _tokenInfoProxy;\n\n  // Wallet/Basket Managers (by Unique Manager ID)\n  mapping (string => IWalletManager) internal _ftWalletManager;\n  mapping (string => IBasketManager) internal _nftBasketManager;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize(address initiator) public initializer {\n    __Ownable_init();\n    emit Initialized(initiator);\n  }\n\n\n  /***********************************|\n  |               Public              |\n  |__________________________________*/\n\n  /// @notice Checks if an Account is the Owner of an NFT Contract\n  ///    When Custom Contracts are registered, only the \"owner\" or operator of the Contract\n  ///    is allowed to register them and define custom rules for how their tokens are \"Charged\".\n  ///    Otherwise, any token can be \"Charged\" according to the default rules of Charged Particles.\n  /// @param contractAddress  The Address to the External NFT Contract to check\n  /// @param account          The Account to check if it is the Owner of the specified Contract\n  /// @return True if the account is the Owner of the _contract\n  function isContractOwner(address contractAddress, address account) external view override virtual returns (bool) {\n    return contractAddress.isContractOwner(account);\n  }\n\n  function isWalletManagerEnabled(string calldata walletManagerId) external virtual override view returns (bool) {\n    return _isWalletManagerEnabled(walletManagerId);\n  }\n\n  function getWalletManager(string calldata walletManagerId) external virtual override view returns (IWalletManager) {\n    return _ftWalletManager[walletManagerId];\n  }\n\n  function isNftBasketEnabled(string calldata basketId) external virtual override view returns (bool) {\n    return _isNftBasketEnabled(basketId);\n  }\n\n  function getBasketManager(string calldata basketId) external virtual override view returns (IBasketManager) {\n    return _nftBasketManager[basketId];\n  }\n\n  /// @dev Validates a Deposit according to the rules set by the Token Contract\n  /// @param sender           The sender address to validate against\n  /// @param contractAddress      The Address to the Contract of the External NFT to check\n  /// @param tokenId              The Token ID of the External NFT to check\n  /// @param walletManagerId  The Wallet Manager of the Assets to Deposit\n  /// @param assetToken           The Address of the Asset Token to Deposit\n  /// @param assetAmount          The specific amount of Asset Token to Deposit\n  function validateDeposit(\n    address sender,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  ) external virtual override {\n    _validateDeposit(sender, contractAddress, tokenId, walletManagerId, assetToken, assetAmount);\n  }\n\n  /// @dev Validates an NFT Deposit according to the rules set by the Token Contract\n  /// @param sender           The sender address to validate against\n  /// @param contractAddress      The Address to the Contract of the External NFT to check\n  /// @param tokenId              The Token ID of the External NFT to check\n  /// @param basketManagerId      The Basket to Deposit the NFT into\n  /// @param nftTokenAddress      The Address of the NFT Token being deposited\n  /// @param nftTokenId           The ID of the NFT Token being deposited\n  /// @param nftTokenAmount       The amount of Tokens to Deposit (ERC1155-specific)\n  function validateNftDeposit(\n    address sender,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  ) external virtual override {\n    _validateNftDeposit(sender, contractAddress, tokenId, basketManagerId, nftTokenAddress, nftTokenId, nftTokenAmount);\n  }\n\n  function validateDischarge(address sender, address contractAddress, uint256 tokenId) external virtual override {\n    _validateDischarge(sender, contractAddress, tokenId);\n  }\n\n  function validateRelease(address sender, address contractAddress, uint256 tokenId) external virtual override {\n    _validateRelease(sender, contractAddress, tokenId);\n  }\n\n  function validateBreakBond(address sender, address contractAddress, uint256 tokenId) external virtual override {\n    _validateBreakBond(sender, contractAddress, tokenId);\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /// @dev Setup the various Charged-Controllers\n  function setController(address controller, string calldata controllerId) external virtual onlyOwner {\n    bytes32 controllerIdStr = keccak256(abi.encodePacked(controllerId));\n\n    if (controllerIdStr == keccak256(abi.encodePacked(\"settings\"))) {\n      _chargedSettings = IChargedSettings(controller);\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"state\"))) {\n      _chargedState = IChargedState(controller);\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"tokeninfo\"))) {\n      _tokenInfoProxy = ITokenInfoProxy(controller);\n    }\n\n    emit ControllerSet(controller, controllerId);\n  }\n\n  /// @dev Register Contracts as wallet managers with a unique liquidity provider ID\n  function registerWalletManager(string calldata walletManagerId, address walletManager) external virtual onlyOwner {\n    // Validate wallet manager\n    IWalletManager newWalletMgr = IWalletManager(walletManager);\n    require(newWalletMgr.isPaused() != true, \"CP:E-418\");\n\n    // Register LP ID\n    _ftWalletManager[walletManagerId] = newWalletMgr;\n    emit WalletManagerRegistered(walletManagerId, walletManager);\n  }\n\n  /// @dev Register Contracts as basket managers with a unique basket ID\n  function registerBasketManager(string calldata basketId, address basketManager) external virtual onlyOwner {\n    // Validate basket manager\n    IBasketManager newBasketMgr = IBasketManager(basketManager);\n    require(newBasketMgr.isPaused() != true, \"CP:E-418\");\n\n    // Register Basket ID\n    _nftBasketManager[basketId] = newBasketMgr;\n    emit BasketManagerRegistered(basketId, basketManager);\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  /// @dev See {ChargedParticles-isWalletManagerEnabled}.\n  function _isWalletManagerEnabled(string calldata walletManagerId) internal view virtual returns (bool) {\n    return (address(_ftWalletManager[walletManagerId]) != address(0x0) && !_ftWalletManager[walletManagerId].isPaused());\n  }\n\n  /// @dev See {ChargedParticles-isNftBasketEnabled}.\n  function _isNftBasketEnabled(string calldata basketId) internal view virtual returns (bool) {\n    return (address(_nftBasketManager[basketId]) != address(0x0) && !_nftBasketManager[basketId].isPaused());\n  }\n\n  /// @dev Validates a Deposit according to the rules set by the Token Contract\n  /// @param contractAddress      The Address to the Contract of the External NFT to check\n  /// @param tokenId              The Token ID of the External NFT to check\n  /// @param walletManagerId  The Wallet Manager of the Assets to Deposit\n  /// @param assetToken           The Address of the Asset Token to Deposit\n  /// @param assetAmount          The specific amount of Asset Token to Deposit\n  function _validateDeposit(\n    address sender,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    internal\n    virtual\n  {\n    if (_chargedState.isEnergizeRestricted(contractAddress, tokenId)) {\n      bool isNFTOwnerOrOperator = _tokenInfoProxy.isNFTOwnerOrOperator(contractAddress, tokenId, sender);\n      require(isNFTOwnerOrOperator, \"CP:E-105\");\n    }\n\n    ( string memory requiredWalletManager,\n      bool energizeEnabled,\n      bool restrictedAssets,\n      bool validAsset,\n      uint256 depositCap,\n      uint256 depositMin,\n      uint256 depositMax,\n      bool invalidAsset\n    ) = _chargedSettings.getAssetRequirements(contractAddress, assetToken);\n\n    require(energizeEnabled, \"CP:E-417\");\n\n    require(!invalidAsset, \"CP:E-424\");\n\n    // Valid Wallet Manager?\n    if (bytes(requiredWalletManager).length > 0) {\n        require(keccak256(abi.encodePacked(requiredWalletManager)) == keccak256(abi.encodePacked(walletManagerId)), \"CP:E-419\");\n    }\n\n    // Valid Asset?\n    if (restrictedAssets) {\n      require(validAsset, \"CP:E-424\");\n    }\n\n    _validateDepositAmount(\n      contractAddress,\n      tokenId,\n      walletManagerId,\n      assetToken,\n      assetAmount,\n      depositCap,\n      depositMin,\n      depositMax\n    );\n  }\n\n  /// @dev Validates a Deposit-Amount according to the rules set by the Token Contract\n  /// @param contractAddress      The Address to the Contract of the External NFT to check\n  /// @param tokenId              The Token ID of the External NFT to check\n  /// @param walletManagerId      The Wallet Manager of the Assets to Deposit\n  /// @param assetToken           The Address of the Asset Token to Deposit\n  /// @param assetAmount          The specific amount of Asset Token to Deposit\n  function _validateDepositAmount(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 depositCap,\n    uint256 depositMin,\n    uint256 depositMax\n  )\n    internal\n    virtual\n  {\n    uint256 existingBalance = _ftWalletManager[walletManagerId].getPrincipal(contractAddress, tokenId, assetToken);\n    uint256 newBalance = assetAmount.add(existingBalance);\n\n    // Validate Deposit Cap\n    if (depositCap > 0) {\n      require(newBalance <= depositCap, \"CP:E-408\");\n    }\n\n    // Valid Amount for Deposit?\n    if (depositMin > 0) {\n        require(newBalance >= depositMin, \"CP:E-410\");\n    }\n    if (depositMax > 0) {\n        require(newBalance <= depositMax, \"CP:E-410\");\n    }\n  }\n\n  /// @dev Validates an NFT Deposit according to the rules set by the Token Contract\n  /// @param contractAddress      The Address to the Contract of the External NFT to check\n  /// @param tokenId              The Token ID of the External NFT to check\n  /// @param basketManagerId      The Basket to Deposit the NFT into\n  /// @param nftTokenAddress      The Address of the NFT Token being deposited\n  /// @param nftTokenId           The ID of the NFT Token being deposited\n  /// @param nftTokenAmount       The amount of Tokens to Deposit (ERC1155-specific)\n  function _validateNftDeposit(\n    address sender,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    internal\n    virtual\n  {\n    // Prevent Ouroboros NFTs\n    require(contractAddress.getTokenUUID(tokenId) != nftTokenAddress.getTokenUUID(nftTokenId), \"CP:E-433\");\n\n    if (_chargedState.isCovalentBondRestricted(contractAddress, tokenId)) {\n      bool isNFTOwnerOrOperator = _tokenInfoProxy.isNFTOwnerOrOperator(contractAddress, tokenId, sender);\n      require(isNFTOwnerOrOperator, \"CP:E-105\");\n    }\n\n    ( string memory requiredBasketManager,\n      bool basketEnabled,\n      uint256 maxNfts\n    ) = _chargedSettings.getNftAssetRequirements(contractAddress, nftTokenAddress);\n\n    require(basketEnabled, \"CP:E-417\");\n\n    // Valid Basket Manager?\n    if (bytes(requiredBasketManager).length > 0) {\n        require(keccak256(abi.encodePacked(requiredBasketManager)) == keccak256(abi.encodePacked(basketManagerId)), \"CP:E-419\");\n    }\n\n    if (maxNfts > 0) {\n      uint256 tokenCount = _nftBasketManager[basketManagerId].getTokenTotalCount(contractAddress, tokenId);\n      require(maxNfts >= (tokenCount + nftTokenAmount), \"CP:E-427\");\n    }\n  }\n\n  function _validateDischarge(address sender, address contractAddress, uint256 tokenId) internal virtual {\n    ( bool allowFromAll,\n      bool isApproved,\n      uint256 timelock,\n      uint256 tempLockExpiry\n    ) = _chargedState.getDischargeState(contractAddress, tokenId, sender);\n    _validateState(allowFromAll, isApproved, timelock, tempLockExpiry);\n  }\n\n  function _validateRelease(address sender, address contractAddress, uint256 tokenId) internal virtual {\n    ( bool allowFromAll,\n      bool isApproved,\n      uint256 timelock,\n      uint256 tempLockExpiry\n    ) = _chargedState.getReleaseState(contractAddress, tokenId, sender);\n    _validateState(allowFromAll, isApproved, timelock, tempLockExpiry);\n  }\n\n  function _validateBreakBond(address sender, address contractAddress, uint256 tokenId) internal virtual {\n    ( bool allowFromAll,\n      bool isApproved,\n      uint256 timelock,\n      uint256 tempLockExpiry\n    ) = _chargedState.getBreakBondState(contractAddress, tokenId, sender);\n    _validateState(allowFromAll, isApproved, timelock, tempLockExpiry);\n  }\n\n  function _validateState(\n    bool allowFromAll,\n    bool isApproved,\n    uint256 timelock,\n    uint256 tempLockExpiry\n  )\n    internal\n    view\n    virtual\n  {\n    if (!allowFromAll) {\n      require(isApproved, \"CP:E-105\");\n    }\n    if (timelock > 0) {\n      require(block.number >= timelock, \"CP:E-302\");\n    }\n    if (tempLockExpiry > 0) {\n      require(block.number >= tempLockExpiry, \"CP:E-303\");\n    }\n  }\n}\n"
    },
    "contracts/v1/ChargedParticles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ChargedParticles.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IUniverse.sol\";\nimport \"./interfaces/IChargedState.sol\";\nimport \"./interfaces/IChargedSettings.sol\";\nimport \"./interfaces/IChargedManagers.sol\";\nimport \"./interfaces/IChargedParticles.sol\";\nimport \"./interfaces/IWalletManager.sol\";\nimport \"./interfaces/IBasketManager.sol\";\nimport \"./interfaces/ITokenInfoProxy.sol\";\n\nimport \"./lib/Bitwise.sol\";\nimport \"./lib/RelayRecipient.sol\";\n\nimport \"./lib/BlackholePrevention.sol\";\n\n/**\n * @notice Charged Particles V2 Contract\n * @dev Upgradeable Contract\n */\ncontract ChargedParticles is\n  IChargedParticles,\n  Initializable,\n  OwnableUpgradeable,\n  ReentrancyGuardUpgradeable,\n  RelayRecipient,\n  IERC721ReceiverUpgradeable,\n  BlackholePrevention,\n  IERC1155ReceiverUpgradeable\n{\n  using SafeMathUpgradeable for uint256;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using Bitwise for uint32;\n  using AddressUpgradeable for address;\n\n  uint256 constant internal PERCENTAGE_SCALE = 1e4;       // 10000  (100%)\n\n  //\n  // Particle Terminology\n  //\n  //   Particle               - Non-fungible Token (NFT)\n  //   Mass                   - Underlying Asset of a Token (ex; DAI)\n  //   Charge                 - Accrued Interest on the Underlying Asset of a Token\n  //   Charged Particle       - Any NFT that has a Mass and a Positive Charge\n  //   Neutral Particle       - Any NFT that has a Mass and No Charge\n  //   Energize / Recharge    - Deposit of an Underlying Asset into an NFT\n  //   Discharge              - Withdraw the Accrued Interest of an NFT leaving the Particle with its initial Mass\n  //   Release                - Withdraw the Underlying Asset & Accrued Interest of an NFT leaving the Particle with No Mass or Charge\n  //\n  //   Proton                 - NFTs minted from the Charged Particle Accelerator\n  //                            - A proton is a subatomic particle, symbol p or p⁺, with a positive electric charge of +1e elementary\n  //                              charge and a mass slightly less than that of a neutron.\n  //   Ion                    - Platform Governance Token\n  //                            - A charged subatomic particle. An atom or group of atoms that carries a positive or negative electric charge\n  //                              as a result of having lost or gained one or more electrons.\n  //\n\n  // Linked Contracts\n  IUniverse internal _universe;\n  IChargedState internal _chargedState;\n  IChargedSettings internal _chargedSettings;\n  address internal _lepton;\n  uint256 internal depositFee;\n  ITokenInfoProxy internal _tokenInfoProxy;\n  IChargedManagers internal _chargedManagers;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize(address initiator) public initializer {\n    __Ownable_init();\n    __ReentrancyGuard_init();\n    emit Initialized(initiator);\n  }\n\n\n  /***********************************|\n  |         Public Functions          |\n  |__________________________________*/\n\n  function getStateAddress() external view virtual override returns (address stateAddress) {\n    return address(_chargedState);\n  }\n\n  function getSettingsAddress() external view virtual override returns (address settingsAddress) {\n    return address(_chargedSettings);\n  }\n\n  function getManagersAddress() external view virtual override returns (address managersAddress) {\n    return address(_chargedManagers);\n  }\n\n  function onERC721Received(address, address, uint256, bytes calldata) external virtual override returns (bytes4) {\n    return IERC721ReceiverUpgradeable(0).onERC721Received.selector;\n  }\n\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata) external virtual override returns (bytes4) {\n    return IERC1155ReceiverUpgradeable(0).onERC1155Received.selector;\n  }\n\n  // Unimplemented\n  function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external virtual override returns (bytes4) {\n    return \"\"; // IERC1155ReceiverUpgradeable(0).onERC1155BatchReceived.selector;\n  }\n\n  function supportsInterface(bytes4 /* interfaceId */) external view virtual override returns (bool) {\n      return false;\n  }\n\n  /// @notice Calculates the amount of Fees to be paid for a specific deposit amount\n  /// @param assetAmount The Amount of Assets to calculate Fees on\n  /// @return protocolFee The amount of deposit fees for the protocol\n  function getFeesForDeposit(\n    uint256 assetAmount\n  )\n    external\n    override\n    view\n    returns (uint256 protocolFee)\n  {\n    protocolFee = _getFeesForDeposit(assetAmount);\n  }\n\n  /// @notice Gets the Amount of Asset Tokens that have been Deposited into the Particle\n  /// representing the Mass of the Particle.\n  /// @param contractAddress      The Address to the Contract of the Token\n  /// @param tokenId              The ID of the Token\n  /// @param walletManagerId  The Liquidity-Provider ID to check the Asset balance of\n  /// @param assetToken           The Address of the Asset Token to check\n  /// @return The Amount of underlying Assets held within the Token\n  function baseParticleMass(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    returns (uint256)\n  {\n    return _baseParticleMass(contractAddress, tokenId, walletManagerId, assetToken);\n  }\n\n  /// @notice Gets the amount of Interest that the Particle has generated representing\n  /// the Charge of the Particle\n  /// @param contractAddress      The Address to the Contract of the Token\n  /// @param tokenId              The ID of the Token\n  /// @param walletManagerId  The Liquidity-Provider ID to check the Interest balance of\n  /// @param assetToken           The Address of the Asset Token to check\n  /// @return The amount of interest the Token has generated (in Asset Token)\n  function currentParticleCharge(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    returns (uint256)\n  {\n    return _currentParticleCharge(contractAddress, tokenId, walletManagerId, assetToken);\n  }\n\n  /// @notice Gets the amount of LP Tokens that the Particle has generated representing\n  /// the Kinetics of the Particle\n  /// @param contractAddress      The Address to the Contract of the Token\n  /// @param tokenId              The ID of the Token\n  /// @param walletManagerId  The Liquidity-Provider ID to check the Kinetics balance of\n  /// @param assetToken           The Address of the Asset Token to check\n  /// @return The amount of LP tokens that have been generated\n  function currentParticleKinetics(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    returns (uint256)\n  {\n    return _currentParticleKinetics(contractAddress, tokenId, walletManagerId, assetToken);\n  }\n\n  /// @notice Gets the total amount of ERC721 Tokens that the Particle holds\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param basketManagerId  The ID of the BasketManager to check the token balance of\n  /// @return The total amount of ERC721 tokens that are held  within the Particle\n  function currentParticleCovalentBonds(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId\n  )\n    external\n    view\n    virtual\n    override\n    basketEnabled(basketManagerId)\n    returns (uint256)\n  {\n    return _currentParticleCovalentBonds(contractAddress, tokenId, basketManagerId);\n  }\n\n\n  /***********************************|\n  |        Energize Particles         |\n  |__________________________________*/\n\n  /// @notice Fund Particle with Asset Token\n  ///    Must be called by the account providing the Asset\n  ///    Account must Approve THIS contract as Operator of Asset\n  ///\n  /// NOTE: DO NOT Energize an ERC20 Token, as anyone who holds any amount\n  ///       of the same ERC20 token could discharge or release the funds.\n  ///       All holders of the ERC20 token would essentially be owners of the Charged Particle.\n  ///\n  /// @param contractAddress      The Address to the Contract of the Token to Energize\n  /// @param tokenId              The ID of the Token to Energize\n  /// @param walletManagerId  The Asset-Pair to Energize the Token with\n  /// @param assetToken           The Address of the Asset Token being used\n  /// @param assetAmount          The Amount of Asset Token to Energize the Token with\n  /// @return yieldTokensAmount The amount of Yield-bearing Tokens added to the escrow for the Token\n  function energizeParticle(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    address referrer\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    nonReentrant\n    returns (uint256 yieldTokensAmount)\n  {\n    _validateDeposit(contractAddress, tokenId, walletManagerId, assetToken, assetAmount);\n\n    // Transfer ERC20 Token from Caller to Contract (reverts on fail)\n    uint256 feeAmount = _collectAssetToken(_msgSender(), assetToken, assetAmount);\n\n    // Deposit Asset Token directly into Smart Wallet (reverts on fail) and Update WalletManager\n    yieldTokensAmount = _depositIntoWalletManager(contractAddress, tokenId, walletManagerId, assetToken, assetAmount, feeAmount);\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onEnergize(_msgSender(), referrer, contractAddress, tokenId, walletManagerId, assetToken, assetAmount);\n    }\n  }\n\n\n  /***********************************|\n  |        Discharge Particles        |\n  |__________________________________*/\n\n  /// @notice Allows the owner or operator of the Token to collect or transfer the interest generated\n  ///         from the token without removing the underlying Asset that is held within the token.\n  /// @param receiver             The Address to Receive the Discharged Asset Tokens\n  /// @param contractAddress      The Address to the Contract of the Token to Discharge\n  /// @param tokenId              The ID of the Token to Discharge\n  /// @param walletManagerId      The Wallet Manager of the Assets to Discharge from the Token\n  /// @param assetToken           The Address of the Asset Token being discharged\n  /// @return creatorAmount Amount of Asset Token discharged to the Creator\n  /// @return receiverAmount Amount of Asset Token discharged to the Receiver\n  function dischargeParticle(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    nonReentrant\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    _validateDischarge(contractAddress, tokenId);\n\n    address creatorRedirect = _chargedSettings.getCreatorAnnuitiesRedirect(contractAddress, tokenId);\n    (creatorAmount, receiverAmount) = _chargedManagers.getWalletManager(walletManagerId).discharge(\n      receiver,\n      contractAddress,\n      tokenId,\n      assetToken,\n      creatorRedirect\n    );\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onDischarge(contractAddress, tokenId, walletManagerId, assetToken, creatorAmount, receiverAmount);\n    }\n  }\n\n  /// @notice Allows the owner or operator of the Token to collect or transfer a specific amount of the interest\n  ///         generated from the token without removing the underlying Asset that is held within the token.\n  /// @param receiver             The Address to Receive the Discharged Asset Tokens\n  /// @param contractAddress      The Address to the Contract of the Token to Discharge\n  /// @param tokenId              The ID of the Token to Discharge\n  /// @param walletManagerId  The Wallet Manager of the Assets to Discharge from the Token\n  /// @param assetToken           The Address of the Asset Token being discharged\n  /// @param assetAmount          The specific amount of Asset Token to Discharge from the Token\n  /// @return creatorAmount Amount of Asset Token discharged to the Creator\n  /// @return receiverAmount Amount of Asset Token discharged to the Receiver\n  function dischargeParticleAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    nonReentrant\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    _validateDischarge(contractAddress, tokenId);\n\n    address creatorRedirect = _chargedSettings.getCreatorAnnuitiesRedirect(contractAddress, tokenId);\n    (creatorAmount, receiverAmount) = _chargedManagers.getWalletManager(walletManagerId).dischargeAmount(\n      receiver,\n      contractAddress,\n      tokenId,\n      assetToken,\n      assetAmount,\n      creatorRedirect\n    );\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onDischarge(contractAddress, tokenId, walletManagerId, assetToken, creatorAmount, receiverAmount);\n    }\n  }\n\n  /// @notice Allows the Creator of the Token to collect or transfer a their portion of the interest (if any)\n  ///         generated from the token without removing the underlying Asset that is held within the token.\n  /// @param receiver             The Address to Receive the Discharged Asset Tokens\n  /// @param contractAddress      The Address to the Contract of the Token to Discharge\n  /// @param tokenId              The ID of the Token to Discharge\n  /// @param walletManagerId  The Wallet Manager of the Assets to Discharge from the Token\n  /// @param assetToken           The Address of the Asset Token being discharged\n  /// @param assetAmount          The specific amount of Asset Token to Discharge from the Particle\n  /// @return receiverAmount      Amount of Asset Token discharged to the Receiver\n  function dischargeParticleForCreator(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    nonReentrant\n    returns (uint256 receiverAmount)\n  {\n    address sender = _msgSender();\n    address tokenCreator = _tokenInfoProxy.getTokenCreator(contractAddress, tokenId);\n    require(sender == tokenCreator, \"CP:E-104\");\n\n    receiverAmount = _chargedManagers.getWalletManager(walletManagerId).dischargeAmountForCreator(\n      receiver,\n      contractAddress,\n      tokenId,\n      sender,\n      assetToken,\n      assetAmount\n    );\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onDischargeForCreator(contractAddress, tokenId, walletManagerId, sender, assetToken, receiverAmount);\n    }\n  }\n\n\n  /***********************************|\n  |         Release Particles         |\n  |__________________________________*/\n\n  /// @notice Releases the Full amount of Asset + Interest held within the Particle by LP of the Assets\n  /// @param receiver             The Address to Receive the Released Asset Tokens\n  /// @param contractAddress      The Address to the Contract of the Token to Release\n  /// @param tokenId              The ID of the Token to Release\n  /// @param walletManagerId  The Wallet Manager of the Assets to Release from the Token\n  /// @param assetToken           The Address of the Asset Token being released\n  /// @return creatorAmount Amount of Asset Token released to the Creator\n  /// @return receiverAmount Amount of Asset Token released to the Receiver (includes principalAmount)\n  function releaseParticle(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    nonReentrant\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    _validateRelease(contractAddress, tokenId);\n\n    // Release Particle to Receiver\n    uint256 principalAmount;\n    address creatorRedirect = _chargedSettings.getCreatorAnnuitiesRedirect(contractAddress, tokenId);\n    (principalAmount, creatorAmount, receiverAmount) = _chargedManagers.getWalletManager(walletManagerId).release(\n      receiver,\n      contractAddress,\n      tokenId,\n      assetToken,\n      creatorRedirect\n    );\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onRelease(contractAddress, tokenId, walletManagerId, assetToken, principalAmount, creatorAmount, receiverAmount);\n    }\n  }\n\n\n  /// @notice Releases a partial amount of Asset + Interest held within the Particle by LP of the Assets\n  /// @param receiver             The Address to Receive the Released Asset Tokens\n  /// @param contractAddress      The Address to the Contract of the Token to Release\n  /// @param tokenId              The ID of the Token to Release\n  /// @param walletManagerId      The Wallet Manager of the Assets to Release from the Token\n  /// @param assetToken           The Address of the Asset Token being released\n  /// @param assetAmount          The specific amount of Asset Token to Release from the Particle\n  /// @return creatorAmount Amount of Asset Token released to the Creator\n  /// @return receiverAmount Amount of Asset Token released to the Receiver (includes principalAmount)\n  function releaseParticleAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    virtual\n    override\n    managerEnabled(walletManagerId)\n    nonReentrant\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    _validateRelease(contractAddress, tokenId);\n\n    // Release Particle to Receiver\n    uint256 principalAmount;\n    address creatorRedirect = _chargedSettings.getCreatorAnnuitiesRedirect(contractAddress, tokenId);\n    (principalAmount, creatorAmount, receiverAmount) = _chargedManagers.getWalletManager(walletManagerId).releaseAmount(\n      receiver,\n      contractAddress,\n      tokenId,\n      assetToken,\n      assetAmount,\n      creatorRedirect\n    );\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onRelease(contractAddress, tokenId, walletManagerId, assetToken, principalAmount, creatorAmount, receiverAmount);\n    }\n  }\n\n\n  /***********************************|\n  |         Covalent Bonding          |\n  |__________________________________*/\n\n  /// @notice Deposit other NFT Assets into the Particle\n  ///    Must be called by the account providing the Asset\n  ///    Account must Approve THIS contract as Operator of Asset\n  ///\n  /// @param contractAddress      The Address to the Contract of the Token to Energize\n  /// @param tokenId              The ID of the Token to Energize\n  /// @param basketManagerId      The Basket to Deposit the NFT into\n  /// @param nftTokenAddress      The Address of the NFT Token being deposited\n  /// @param nftTokenId           The ID of the NFT Token being deposited\n  /// @param nftTokenAmount       The amount of Tokens to Deposit (ERC1155-specific)\n  function covalentBond(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    external\n    virtual\n    override\n    basketEnabled(basketManagerId)\n    nonReentrant\n    returns (bool success)\n  {\n    _validateNftDeposit(contractAddress, tokenId, basketManagerId, nftTokenAddress, nftTokenId, nftTokenAmount);\n\n    // Transfer ERC721 Token from Caller to Contract (reverts on fail)\n    _collectNftToken(_msgSender(), nftTokenAddress, nftTokenId, nftTokenAmount);\n\n    // Deposit Asset Token directly into Smart Wallet (reverts on fail) and Update WalletManager\n    success = _depositIntoBasketManager(contractAddress, tokenId, basketManagerId, nftTokenAddress, nftTokenId, nftTokenAmount);\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onCovalentBond(contractAddress, tokenId, basketManagerId, nftTokenAddress, nftTokenId, nftTokenAmount);\n    }\n  }\n\n  /// @notice Release NFT Assets from the Particle\n  /// @param receiver             The Address to Receive the Released Asset Tokens\n  /// @param contractAddress      The Address to the Contract of the Token to Energize\n  /// @param tokenId              The ID of the Token to Energize\n  /// @param basketManagerId      The Basket to Deposit the NFT into\n  /// @param nftTokenAddress      The Address of the NFT Token being deposited\n  /// @param nftTokenId           The ID of the NFT Token being deposited\n  /// @param nftTokenAmount       The amount of Tokens to Withdraw (ERC1155-specific)\n  function breakCovalentBond(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    external\n    virtual\n    override\n    basketEnabled(basketManagerId)\n    nonReentrant\n    returns (bool success)\n  {\n    _validateBreakBond(contractAddress, tokenId);\n\n    IBasketManager basketMgr = _chargedManagers.getBasketManager(basketManagerId);\n    if (keccak256(abi.encodePacked(basketManagerId)) != keccak256(abi.encodePacked(\"generic\"))) {\n      basketMgr.prepareTransferAmount(nftTokenAmount);\n    }\n\n    // Release Particle to Receiver\n    success = basketMgr.removeFromBasket(\n      receiver,\n      contractAddress,\n      tokenId,\n      nftTokenAddress,\n      nftTokenId\n    );\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onCovalentBreak(contractAddress, tokenId, basketManagerId, nftTokenAddress, nftTokenId, nftTokenAmount);\n    }\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /// @dev Setup the various Charged-Controllers\n  function setController(address controller, string calldata controllerId) external virtual onlyOwner {\n    bytes32 controllerIdStr = keccak256(abi.encodePacked(controllerId));\n\n    if (controllerIdStr == keccak256(abi.encodePacked(\"universe\"))) {\n      _universe = IUniverse(controller);\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"settings\"))) {\n      _chargedSettings = IChargedSettings(controller);\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"state\"))) {\n      _chargedState = IChargedState(controller);\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"managers\"))) {\n      _chargedManagers = IChargedManagers(controller);\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"leptons\"))) {\n      _lepton = controller;\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"forwarder\"))) {\n      trustedForwarder = controller;\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"tokeninfo\"))) {\n      _tokenInfoProxy = ITokenInfoProxy(controller);\n    }\n\n    emit ControllerSet(controller, controllerId);\n  }\n\n\n  /***********************************|\n  |          Protocol Fees            |\n  |__________________________________*/\n\n  /// @dev Setup the Base Deposit Fee for the Protocol\n  function setDepositFee(uint256 fee) external onlyOwner {\n    require(fee < PERCENTAGE_SCALE, \"CP:E-421\");\n    depositFee = fee;\n    emit DepositFeeSet(fee);\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  /// @dev Validates a Deposit according to the rules set by the Token Contract\n  /// @param contractAddress      The Address to the Contract of the External NFT to check\n  /// @param tokenId              The Token ID of the External NFT to check\n  /// @param walletManagerId  The Wallet Manager of the Assets to Deposit\n  /// @param assetToken           The Address of the Asset Token to Deposit\n  /// @param assetAmount          The specific amount of Asset Token to Deposit\n  function _validateDeposit(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    internal\n    virtual\n  {\n    _chargedManagers.validateDeposit(_msgSender(), contractAddress, tokenId, walletManagerId, assetToken, assetAmount);\n  }\n\n  /// @dev Validates an NFT Deposit according to the rules set by the Token Contract\n  /// @param contractAddress      The Address to the Contract of the External NFT to check\n  /// @param tokenId              The Token ID of the External NFT to check\n  /// @param basketManagerId      The Basket to Deposit the NFT into\n  /// @param nftTokenAddress      The Address of the NFT Token being deposited\n  /// @param nftTokenId           The ID of the NFT Token being deposited\n  /// @param nftTokenAmount       The amount of Tokens to Deposit (ERC1155-specific)\n  function _validateNftDeposit(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    internal\n    virtual\n  {\n    _chargedManagers.validateNftDeposit(_msgSender(), contractAddress, tokenId, basketManagerId, nftTokenAddress, nftTokenId, nftTokenAmount);\n  }\n\n  function _validateDischarge(address contractAddress, uint256 tokenId) internal virtual {\n    _chargedManagers.validateDischarge(_msgSender(), contractAddress, tokenId);\n  }\n\n  function _validateRelease(address contractAddress, uint256 tokenId) internal virtual {\n    _chargedManagers.validateRelease(_msgSender(), contractAddress, tokenId);\n  }\n\n  function _validateBreakBond(address contractAddress, uint256 tokenId) internal virtual {\n    _chargedManagers.validateBreakBond(_msgSender(), contractAddress, tokenId);\n  }\n\n  /// @dev Deposit Asset Tokens into an NFT via the Wallet Manager\n  /// @param contractAddress      The Address to the Contract of the NFT\n  /// @param tokenId              The Token ID of the NFT\n  /// @param walletManagerId  The Wallet Manager of the Assets to Deposit\n  /// @param assetToken           The Address of the Asset Token to Deposit\n  /// @param assetAmount          The specific amount of Asset Token to Deposit\n  /// @param feeAmount            The Amount of Protocol Fees charged\n  function _depositIntoWalletManager(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 feeAmount\n  )\n    internal\n    virtual\n    returns (uint256)\n  {\n    // Get Wallet-Manager for LP\n    IWalletManager lpWalletMgr = _chargedManagers.getWalletManager(walletManagerId);\n\n    (address creator, uint256 annuityPct) = _chargedSettings.getCreatorAnnuities(contractAddress, tokenId);\n\n    // Deposit Asset Token directly into Smart Wallet (reverts on fail) and Update WalletManager\n    address wallet = lpWalletMgr.getWalletAddressById(contractAddress, tokenId, creator, annuityPct);\n    IERC20Upgradeable(assetToken).transfer(wallet, assetAmount);\n\n    emit ProtocolFeesCollected(assetToken, assetAmount, feeAmount);\n\n    return lpWalletMgr.energize(contractAddress, tokenId, assetToken, assetAmount);\n  }\n\n  /// @dev Deposit NFT Tokens into the Basket Manager\n  /// @param contractAddress      The Address to the Contract of the NFT\n  /// @param tokenId              The Token ID of the NFT\n  /// @param basketManagerId      The Wallet Manager of the Assets to Deposit\n  /// @param nftTokenAddress      The Address of the Asset Token to Deposit\n  /// @param nftTokenId           The specific amount of Asset Token to Deposit\n  /// @param nftTokenAmount       The amount of Tokens to Deposit (ERC1155-specific)\n  function _depositIntoBasketManager(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    internal\n    virtual\n    returns (bool)\n  {\n    // Deposit NFT Token directly into Smart Wallet (reverts on fail) and Update BasketManager\n    IBasketManager basketMgr = _chargedManagers.getBasketManager(basketManagerId);\n    address wallet = basketMgr.getBasketAddressById(contractAddress, tokenId);\n\n    if (keccak256(abi.encodePacked(basketManagerId)) != keccak256(abi.encodePacked(\"generic\"))) {\n      basketMgr.prepareTransferAmount(nftTokenAmount);\n    }\n\n    if (_isERC1155(nftTokenAddress)) {\n      if (nftTokenAmount == 0) { nftTokenAmount = 1; }\n      IERC1155Upgradeable(nftTokenAddress).safeTransferFrom(address(this), wallet, nftTokenId, nftTokenAmount, \"\");\n    } else {\n      IERC721Upgradeable(nftTokenAddress).transferFrom(address(this), wallet, nftTokenId);\n    }\n    return basketMgr.addToBasket(contractAddress, tokenId, nftTokenAddress, nftTokenId);\n  }\n\n  /**\n    * @dev Calculates the amount of Fees to be paid for a specific deposit amount\n    *   Fees are calculated in Interest-Token as they are the type collected for Fees\n    * @param assetAmount The Amount of Assets to calculate Fees on\n    * @return protocolFee The amount of fees reserved for the protocol\n    */\n  function _getFeesForDeposit(\n    uint256 assetAmount\n  )\n    internal\n    view\n    returns (uint256 protocolFee)\n  {\n    if (depositFee > 0) {\n      protocolFee = assetAmount.mul(depositFee).div(PERCENTAGE_SCALE);\n    }\n  }\n\n  /// @dev Collects the Required ERC20 Token(s) from the users wallet\n  ///   Be sure to Approve this Contract to transfer your Token(s)\n  /// @param from         The owner address to collect the tokens from\n  /// @param tokenAddress  The addres of the token to transfer\n  /// @param tokenAmount  The amount of tokens to collect\n  function _collectAssetToken(address from, address tokenAddress, uint256 tokenAmount) internal virtual returns (uint256 protocolFee) {\n    protocolFee = _getFeesForDeposit(tokenAmount);\n    IERC20Upgradeable(tokenAddress).safeTransferFrom(from, address(this), tokenAmount.add(protocolFee));\n  }\n\n  /// @dev Collects the Required ERC721 Token(s) from the users wallet\n  ///   Be sure to Approve this Contract to transfer your Token(s)\n  /// @param from             The owner address to collect the tokens from\n  /// @param nftTokenAddress  The address of the NFT token to transfer\n  /// @param nftTokenId       The ID of the NFT token to transfer\n  /// @param nftTokenAmount   The amount of Tokens to Transfer (ERC1155-specific)\n  function _collectNftToken(address from, address nftTokenAddress, uint256 nftTokenId, uint256 nftTokenAmount) internal virtual {\n    if (_isERC1155(nftTokenAddress)) {\n      IERC1155Upgradeable(nftTokenAddress).safeTransferFrom(from, address(this), nftTokenId, nftTokenAmount, \"\");\n    } else {\n      IERC721Upgradeable(nftTokenAddress).safeTransferFrom(from, address(this), nftTokenId);\n    }\n  }\n\n  /// @dev Checks if an NFT token contract supports the ERC1155 standard interface\n  function _isERC1155(address nftTokenAddress) internal view virtual returns (bool) {\n    bytes4 _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n    return IERC165Upgradeable(nftTokenAddress).supportsInterface(_INTERFACE_ID_ERC1155);\n  }\n\n  /// @dev See {ChargedParticles-baseParticleMass}.\n  function _baseParticleMass(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    internal\n    virtual\n    returns (uint256)\n  {\n    return _chargedManagers.getWalletManager(walletManagerId).getPrincipal(contractAddress, tokenId, assetToken);\n  }\n\n  /// @dev See {ChargedParticles-currentParticleCharge}.\n  function _currentParticleCharge(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    internal\n    virtual\n    returns (uint256)\n  {\n    (, uint256 ownerInterest) = _chargedManagers.getWalletManager(walletManagerId).getInterest(contractAddress, tokenId, assetToken);\n    return ownerInterest;\n  }\n\n  /// @dev See {ChargedParticles-currentParticleKinetics}.\n  function _currentParticleKinetics(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    internal\n    virtual\n    returns (uint256)\n  {\n    return _chargedManagers.getWalletManager(walletManagerId).getRewards(contractAddress, tokenId, assetToken);\n  }\n\n  /// @dev See {ChargedParticles-currentParticleCovalentBonds}.\n  function _currentParticleCovalentBonds(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId\n  )\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return _chargedManagers.getBasketManager(basketManagerId).getTokenTotalCount(contractAddress, tokenId);\n  }\n\n\n  /***********************************|\n  |          GSN/MetaTx Relay         |\n  |__________________________________*/\n\n  /// @dev See {BaseRelayRecipient-_msgSender}.\n  function _msgSender()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, ContextUpgradeable)\n    returns (address payable)\n  {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  /// @dev See {BaseRelayRecipient-_msgData}.\n  function _msgData()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, ContextUpgradeable)\n    returns (bytes memory)\n  {\n    return BaseRelayRecipient._msgData();\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier managerEnabled(string calldata walletManagerId) {\n    require(_chargedManagers.isWalletManagerEnabled(walletManagerId), \"CP:E-419\");\n    _;\n  }\n\n  modifier basketEnabled(string calldata basketManagerId) {\n    require(_chargedManagers.isNftBasketEnabled(basketManagerId), \"CP:E-419\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/ChargedSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ChargedSettings.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"./interfaces/IChargedSettings.sol\";\nimport \"./interfaces/ITokenInfoProxy.sol\";\n\nimport \"./lib/Bitwise.sol\";\nimport \"./lib/TokenInfo.sol\";\nimport \"./lib/RelayRecipient.sol\";\nimport \"./lib/BlackholePrevention.sol\";\n\nimport \"./lib/TokenInfoProxy.sol\";\n\n/**\n * @notice Charged Particles Settings Contract\n */\ncontract ChargedSettings is\n  IChargedSettings,\n  Initializable,\n  OwnableUpgradeable,\n  RelayRecipient,\n  BlackholePrevention\n{\n  using SafeMathUpgradeable for uint256;\n  using TokenInfo for address;\n  using Bitwise for uint32;\n\n  uint256 constant internal MAX_ANNUITIES = 1e4;      // 10000  (100%)\n\n  // NftSettings - actionPerms\n  uint32 constant internal PERM_CHARGE_NFT        = 1;    // NFT Contracts that can have assets Deposited into them (Charged)\n  uint32 constant internal PERM_BASKET_NFT        = 2;    // NFT Contracts that can have other NFTs Deposited into them\n  uint32 constant internal PERM_TIMELOCK_ANY_NFT  = 4;    // NFT Contracts that can timelock any NFT on behalf of users (primarily used for Front-run Protection)\n  uint32 constant internal PERM_TIMELOCK_OWN_NFT  = 8;    // NFT Contracts that can timelock their own NFTs on behalf of their users\n  uint32 constant internal PERM_RESTRICTED_ASSETS = 16;   // NFT Contracts that have restricted deposits to specific assets\n\n  ITokenInfoProxy internal _tokenInfoProxy;\n\n  // Current Settings for External NFT Token Contracts;\n  //  - Any user can add any ERC721 or ERC1155 token as a Charged Particle without Limits,\n  //    unless the Owner of the ERC721 or ERC1155 token contract registers the token\n  //    and sets the Custom Settings for their token(s)\n  mapping (address => uint32) internal _nftActionPerms;\n\n  mapping (address => string) internal _nftRequiredWalletManager;\n  mapping (address => string) internal _nftRequiredBasketManager;\n\n  // ERC20\n  mapping (address => mapping(address => bool)) internal _nftAllowedAssetTokens;\n  mapping (address => mapping (address => uint256)) internal _nftDepositMin;\n  mapping (address => mapping (address => uint256)) internal _nftDepositMax;\n\n  // ERC721 / ERC1155\n  mapping (address => mapping (address => uint256)) internal _nftMaxNfts;     // NFT Token Address => Max\n\n  // Optional Configs for individual NFTs set by NFT Creator (by Token UUID)\n  mapping (uint256 => uint256) internal _creatorAnnuityPercent;\n  mapping (uint256 => address) internal _creatorAnnuityRedirect;\n\n  mapping (address => uint256) internal _depositCap;\n  uint256 internal _tempLockExpiryBlocks;\n\n  // Blacklist for non-compliant tokens\n  mapping (address => bool) internal _invalidAssets;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize(address initiator) public initializer {\n    __Ownable_init();\n    emit Initialized(initiator);\n  }\n\n\n  /***********************************|\n  |               Public              |\n  |__________________________________*/\n\n  /// @dev Gets the amount of creator annuities reserved for the creator for the specified NFT\n  /// @param contractAddress The Address to the Contract of the NFT\n  /// @param tokenId         The Token ID of the NFT\n  /// @return creator The address of the creator\n  /// @return annuityPct The percentage amount of annuities reserved for the creator\n  function getCreatorAnnuities(\n    address contractAddress,\n    uint256 tokenId\n  )\n    external\n    override\n    virtual\n    returns (address creator, uint256 annuityPct)\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    creator = _tokenInfoProxy.getTokenCreator(contractAddress, tokenId);\n    annuityPct = _creatorAnnuityPercent[tokenUuid];\n  }\n\n  function getCreatorAnnuitiesRedirect(address contractAddress, uint256 tokenId)\n    external\n    view\n    override\n    virtual\n    returns (address)\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    return _creatorAnnuityRedirect[tokenUuid];\n  }\n\n  function getTempLockExpiryBlocks() external view override virtual returns (uint256) {\n    return _tempLockExpiryBlocks;\n  }\n\n  function getTimelockApprovals(address operator)\n    external\n    view\n    override\n    virtual\n    returns (bool timelockAny, bool timelockOwn)\n  {\n    timelockAny = _nftActionPerms[operator].hasBit(PERM_TIMELOCK_ANY_NFT);\n    timelockOwn = _nftActionPerms[operator].hasBit(PERM_TIMELOCK_OWN_NFT);\n  }\n\n  function getAssetRequirements(address contractAddress, address assetToken)\n    external\n    view\n    override\n    virtual\n    returns (\n      string memory requiredWalletManager,\n      bool energizeEnabled,\n      bool restrictedAssets,\n      bool validAsset,\n      uint256 depositCap,\n      uint256 depositMin,\n      uint256 depositMax,\n      bool invalidAsset\n    )\n  {\n    requiredWalletManager = _nftRequiredWalletManager[contractAddress];\n    energizeEnabled = _nftActionPerms[contractAddress].hasBit(PERM_CHARGE_NFT);\n    restrictedAssets = _nftActionPerms[contractAddress].hasBit(PERM_RESTRICTED_ASSETS);\n    validAsset = _nftAllowedAssetTokens[contractAddress][assetToken];\n    depositCap = _depositCap[assetToken];\n    depositMin = _nftDepositMin[contractAddress][assetToken];\n    depositMax = _nftDepositMax[contractAddress][assetToken];\n    invalidAsset = _invalidAssets[assetToken];\n  }\n\n  function getNftAssetRequirements(address contractAddress, address nftTokenAddress)\n    external\n    view\n    override\n    virtual\n    returns (string memory requiredBasketManager, bool basketEnabled, uint256 maxNfts)\n  {\n    requiredBasketManager = _nftRequiredBasketManager[contractAddress];\n    basketEnabled = _nftActionPerms[contractAddress].hasBit(PERM_BASKET_NFT);\n    maxNfts = _nftMaxNfts[contractAddress][nftTokenAddress];\n  }\n\n\n  /***********************************|\n  |         Only NFT Creator          |\n  |__________________________________*/\n\n  /// @notice Sets the Custom Configuration for Creators of Proton-based NFTs\n  /// @param contractAddress  The Address to the Proton-based NFT to configure\n  /// @param tokenId          The token ID of the Proton-based NFT to configure\n  /// @param creator          The creator of the Proton-based NFT\n  /// @param annuityPercent   The percentage of interest-annuities to reserve for the creator\n  function setCreatorAnnuities(\n    address contractAddress,\n    uint256 tokenId,\n    address creator,\n    uint256 annuityPercent\n  )\n    external\n    virtual\n    override\n  {\n    require(_tokenInfoProxy.isNFTContractOrCreator(contractAddress, tokenId, _msgSender()), \"CP:E-104\");\n    _setCreatorAnnuities(contractAddress, tokenId, creator, annuityPercent);\n  }\n\n  /// @notice Sets a Custom Receiver Address for the Creator Annuities\n  /// @param contractAddress  The Address to the Proton-based NFT to configure\n  /// @param tokenId          The token ID of the Proton-based NFT to configure\n  /// @param receiver         The receiver of the Creator interest-annuities\n  function setCreatorAnnuitiesRedirect(\n    address contractAddress,\n    uint256 tokenId,\n    address receiver\n  )\n    external\n    virtual\n    override\n  {\n    require(_tokenInfoProxy.isNFTContractOrCreator(contractAddress, tokenId, _msgSender()), \"CP:E-104\");\n    _setCreatorAnnuitiesRedirect(contractAddress, tokenId, receiver);\n  }\n\n\n  /***********************************|\n  |     Register Contract Settings    |\n  |(For External Contract Integration)|\n  |__________________________________*/\n\n  /// @notice Sets a Required Wallet-Manager for External NFT Contracts (otherwise set to \"none\" to allow any Wallet-Manager)\n  /// @param contractAddress    The Address to the External NFT Contract to configure\n  /// @param walletManager      If set, will only allow deposits from this specific Wallet-Manager\n  function setRequiredWalletManager(\n    address contractAddress,\n    string calldata walletManager\n  )\n    external\n    virtual\n    override\n    onlyValidExternalContract(contractAddress)\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\n  {\n    // Update Configs for External Token Contract\n    if (keccak256(bytes(walletManager)) == keccak256(bytes(\"none\"))) {\n      _nftRequiredWalletManager[contractAddress] = \"\";\n    } else {\n      _nftRequiredWalletManager[contractAddress] = walletManager;\n    }\n\n    emit RequiredWalletManagerSet(\n      contractAddress,\n      walletManager\n    );\n  }\n\n  /// @notice Sets a Required Basket-Manager for External NFT Contracts (otherwise set to \"none\" to allow any Basket-Manager)\n  /// @param contractAddress    The Address to the External Contract to configure\n  /// @param basketManager      If set, will only allow deposits from this specific Basket-Manager\n  function setRequiredBasketManager(\n    address contractAddress,\n    string calldata basketManager\n  )\n    external\n    virtual\n    override\n    onlyValidExternalContract(contractAddress)\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\n  {\n    // Update Configs for External Token Contract\n    if (keccak256(bytes(basketManager)) == keccak256(bytes(\"none\"))) {\n      _nftRequiredBasketManager[contractAddress] = \"\";\n    } else {\n      _nftRequiredBasketManager[contractAddress] = basketManager;\n    }\n\n    emit RequiredBasketManagerSet(\n      contractAddress,\n      basketManager\n    );\n  }\n\n  /// @notice Enables or Disables Asset-Token Restrictions for External NFT Contracts\n  /// @param contractAddress      The Address to the External NFT Contract to configure\n  /// @param restrictionsEnabled  If set, will only allow deposits from Allowed Asset Tokens\n  function setAssetTokenRestrictions(\n    address contractAddress,\n    bool restrictionsEnabled\n  )\n    external\n    virtual\n    override\n    onlyValidExternalContract(contractAddress)\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\n  {\n    // Update Configs for External Token Contract\n    if (restrictionsEnabled) {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].setBit(PERM_RESTRICTED_ASSETS);\n    } else {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].clearBit(PERM_RESTRICTED_ASSETS);\n    }\n\n    emit AssetTokenRestrictionsSet(\n      contractAddress,\n      restrictionsEnabled\n    );\n  }\n\n  /// @notice Enables or Disables Allowed Asset Tokens for External NFT Contracts\n  /// @param contractAddress  The Address to the External NFT Contract to configure\n  /// @param assetToken       The Address of the Asset Token to Allow or Disallow\n  /// @param isAllowed        True if the Asset Token is allowed\n  function setAllowedAssetToken(\n    address contractAddress,\n    address assetToken,\n    bool isAllowed\n  )\n    external\n    virtual\n    override\n    onlyValidExternalContract(contractAddress)\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\n  {\n    // Update Configs for External Token Contract\n    _nftAllowedAssetTokens[contractAddress][assetToken] = isAllowed;\n\n    emit AllowedAssetTokenSet(\n      contractAddress,\n      assetToken,\n      isAllowed\n    );\n  }\n\n  /// @notice Sets the Custom Configuration for External Contracts\n  /// @param contractAddress  The Address to the External Contract to configure\n  /// @param assetToken       The address of the Asset Token to set Limits for\n  /// @param depositMin       If set, will define the minimum amount of Asset tokens the NFT may hold, otherwise any amount\n  /// @param depositMax       If set, will define the maximum amount of Asset tokens the NFT may hold, otherwise any amount\n  function setAssetTokenLimits(\n    address contractAddress,\n    address assetToken,\n    uint256 depositMin,\n    uint256 depositMax\n  )\n    external\n    virtual\n    override\n    onlyValidExternalContract(contractAddress)\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\n  {\n    // Update Configs for External Token Contract\n    _nftDepositMin[contractAddress][assetToken] = depositMin;\n    _nftDepositMax[contractAddress][assetToken] = depositMax;\n\n    emit AssetTokenLimitsSet(\n      contractAddress,\n      assetToken,\n      depositMin,\n      depositMax\n    );\n  }\n\n  /// @notice Sets the Max Number of NFTs that can be held by a Charged Particle NFT\n  /// @param contractAddress  The Address to the External Contract to configure\n  /// @param nftTokenAddress  The address of the NFT Token to set a Max for\n  /// @param maxNfts          The maximum numbers of NFTs that can be held by a given NFT (0 = unlimited)\n  function setMaxNfts(\n    address contractAddress,\n    address nftTokenAddress,\n    uint256 maxNfts\n  )\n    external\n    virtual\n    override\n    onlyValidExternalContract(contractAddress)\n    onlyContractOwnerOrAdmin(contractAddress, msg.sender)\n  {\n    // Update Configs for External Token Contract\n    _nftMaxNfts[contractAddress][nftTokenAddress] = maxNfts;\n\n    emit MaxNftsSet(\n      contractAddress,\n      nftTokenAddress,\n      maxNfts\n    );\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /// @dev Setup the various Charged-Controllers\n  function setController(address controller, string calldata controllerId) external virtual onlyOwner {\n    bytes32 controllerIdStr = keccak256(abi.encodePacked(controllerId));\n\n    if (controllerIdStr == keccak256(abi.encodePacked(\"tokeninfo\"))) {\n      _tokenInfoProxy = ITokenInfoProxy(controller);\n    }\n\n    emit ControllerSet(controller, controllerId);\n  }\n\n  function setTrustedForwarder(address _trustedForwarder) external onlyOwner {\n    trustedForwarder = _trustedForwarder;\n  }\n\n  function setAssetInvalidity(address assetToken, bool invalidity) external virtual override onlyOwner {\n    _invalidAssets[assetToken] = invalidity;\n    emit AssetInvaliditySet(assetToken, invalidity);\n  }\n\n  function setDepositCap(address assetToken, uint256 cap) external virtual onlyOwner {\n    _depositCap[assetToken] = cap;\n    emit DepositCapSet(assetToken, cap);\n  }\n\n  function setTempLockExpiryBlocks(uint256 numBlocks) external virtual onlyOwner {\n    _tempLockExpiryBlocks = numBlocks;\n    emit TempLockExpirySet(numBlocks);\n  }\n\n  function enableNftContracts(address[] calldata contracts) external override virtual onlyOwner {\n    uint count = contracts.length;\n    for (uint i = 0; i < count; i++) {\n      address tokenContract = contracts[i];\n      _setPermsForCharge(tokenContract, true);\n      _setPermsForBasket(tokenContract, true);\n      _setPermsForTimelockSelf(tokenContract, true);\n    }\n  }\n\n  function migrateToken(\n    address contractAddress,\n    uint256 tokenId,\n    address creator,\n    uint256 annuityPercent,\n    address annuityReceiver\n  )\n    external\n    onlyOwner\n  {\n    _setCreatorAnnuities(contractAddress, tokenId, creator, annuityPercent);\n    if (annuityReceiver != address(0)) {\n      _setCreatorAnnuitiesRedirect(contractAddress, tokenId, annuityReceiver);\n    }\n  }\n\n  /// @dev Update the list of NFT contracts that can be Charged\n  function setPermsForCharge(address contractAddress, bool state)\n    external\n    override\n    virtual\n    onlyOwner\n  {\n    _setPermsForCharge(contractAddress, state);\n  }\n\n  /// @dev Update the list of NFT contracts that can hold other NFTs\n  function setPermsForBasket(address contractAddress, bool state)\n    external\n    override\n    virtual\n    onlyOwner\n  {\n    _setPermsForBasket(contractAddress, state);\n  }\n\n  /// @dev Update the list of NFT contracts that can Timelock any NFT for Front-run Protection\n  function setPermsForTimelockAny(address contractAddress, bool state)\n    external\n    override\n    virtual\n    onlyOwner\n  {\n    _setPermsForTimelockAny(contractAddress, state);\n  }\n\n  /// @dev Update the list of NFT contracts that can Timelock their own tokens\n  function setPermsForTimelockSelf(address contractAddress, bool state)\n    external\n    override\n    virtual\n    onlyOwner\n  {\n    _setPermsForTimelockSelf(contractAddress, state);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  /// @dev Update the list of NFT contracts that can be Charged\n  function _setPermsForCharge(address contractAddress, bool state) internal virtual {\n    if (state) {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].setBit(PERM_CHARGE_NFT);\n    } else {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].clearBit(PERM_CHARGE_NFT);\n    }\n    emit PermsSetForCharge(contractAddress, state);\n  }\n\n  /// @dev Update the list of NFT contracts that can hold other NFTs\n  function _setPermsForBasket(address contractAddress, bool state) internal virtual {\n    if (state) {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].setBit(PERM_BASKET_NFT);\n    } else {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].clearBit(PERM_BASKET_NFT);\n    }\n    emit PermsSetForBasket(contractAddress, state);\n  }\n\n  /// @dev Update the list of NFT contracts that can Timelock any NFT for Front-run Protection\n  function _setPermsForTimelockAny(address contractAddress, bool state) internal virtual {\n    if (state) {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].setBit(PERM_TIMELOCK_ANY_NFT);\n    } else {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].clearBit(PERM_TIMELOCK_ANY_NFT);\n    }\n    emit PermsSetForTimelockAny(contractAddress, state);\n  }\n\n  /// @dev Update the list of NFT contracts that can Timelock their own tokens\n  function _setPermsForTimelockSelf(address contractAddress, bool state) internal virtual {\n    if (state) {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].setBit(PERM_TIMELOCK_OWN_NFT);\n    } else {\n      _nftActionPerms[contractAddress] = _nftActionPerms[contractAddress].clearBit(PERM_TIMELOCK_OWN_NFT);\n    }\n    emit PermsSetForTimelockSelf(contractAddress, state);\n  }\n\n  /// @dev see setCreatorAnnuities()\n  function _setCreatorAnnuities(\n    address contractAddress,\n    uint256 tokenId,\n    address creator,\n    uint256 annuityPercent\n  )\n    internal\n    virtual\n  {\n    require(annuityPercent <= MAX_ANNUITIES, \"CP:E-421\");\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    // Update Configs for External Token Creator\n    _creatorAnnuityPercent[tokenUuid] = annuityPercent;\n\n    emit TokenCreatorConfigsSet(\n      contractAddress,\n      tokenId,\n      creator,\n      annuityPercent\n    );\n  }\n\n  /// @dev see setCreatorAnnuitiesRedirect()\n  function _setCreatorAnnuitiesRedirect(\n    address contractAddress,\n    uint256 tokenId,\n    address receiver\n  )\n    internal\n    virtual\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    _creatorAnnuityRedirect[tokenUuid] = receiver;\n    emit TokenCreatorAnnuitiesRedirected(contractAddress, tokenId, receiver);\n  }\n\n\n  /***********************************|\n  |          GSN/MetaTx Relay         |\n  |__________________________________*/\n\n  /// @dev See {BaseRelayRecipient-_msgSender}.\n  function _msgSender()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, ContextUpgradeable)\n    returns (address payable)\n  {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  /// @dev See {BaseRelayRecipient-_msgData}.\n  function _msgData()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, ContextUpgradeable)\n    returns (bytes memory)\n  {\n    return BaseRelayRecipient._msgData();\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier onlyValidExternalContract(address contractAddress) {\n    require(contractAddress.isContract(), \"CP:E-420\");\n    _;\n  }\n\n  modifier onlyContractOwnerOrAdmin(address contractAddress, address sender) {\n    require(sender == owner() || contractAddress.isContractOwner(sender), \"CP:E-103\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/ChargedState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ChargedState.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nimport \"./interfaces/IChargedState.sol\";\nimport \"./interfaces/ITokenInfoProxy.sol\";\n\nimport \"./lib/Bitwise.sol\";\nimport \"./lib/TokenInfo.sol\";\nimport \"./lib/RelayRecipient.sol\";\nimport \"./lib/BlackholePrevention.sol\";\n\n/**\n * @notice Charged Particles Settings Contract\n */\ncontract ChargedState is\n  IChargedState,\n  Initializable,\n  OwnableUpgradeable,\n  RelayRecipient,\n  BlackholePrevention\n{\n  using SafeMathUpgradeable for uint256;\n  using TokenInfo for address;\n  using Bitwise for uint32;\n\n  // NftState - actionPerms\n  uint32 constant internal PERM_RESTRICT_ENERGIZE_FROM_ALL = 1;  // NFTs that have Restrictions on Energize\n  uint32 constant internal PERM_ALLOW_DISCHARGE_FROM_ALL   = 2;  // NFTs that allow Discharge by anyone\n  uint32 constant internal PERM_ALLOW_RELEASE_FROM_ALL     = 4;  // NFTs that allow Release by anyone\n  uint32 constant internal PERM_RESTRICT_BOND_FROM_ALL     = 8;  // NFTs that have Restrictions on Covalent Bonds\n  uint32 constant internal PERM_ALLOW_BREAK_BOND_FROM_ALL  = 16; // NFTs that allow Breaking Covalent Bonds by anyone\n\n  IChargedSettings internal _chargedSettings;\n  ITokenInfoProxy internal _tokenInfoProxy;\n\n  // NftTimelocks\n  /// @dev discharge unlockBlock and lockedBy\n  mapping (uint256 => uint256) internal _nftDischargeTimelockUnlockBlock;\n  mapping (uint256 => address) internal _nftDischargeTimelockLockedBy;\n\n  /// @dev release unlockBlock and lockedBy\n  mapping (uint256 => uint256) internal _nftReleaseTimelockUnlockBlock;\n  mapping (uint256 => address) internal _nftReleaseTimelockLockedBy;\n\n  /// @dev release unlockBlock and lockedBy\n  mapping (uint256 => uint256) internal _nftBreakBondTimelockUnlockBlock;\n  mapping (uint256 => address) internal _nftBreakBondTimelockLockedBy;\n\n  // NftState\n  /// @dev maps nft by tokenId to actionPermissions uint32 which is a composite of all possible NftState - actionPerms\n  mapping (uint256 => uint32) internal _nftActionPerms;\n\n  /// @dev maps nft by tokenId to its tempLockExpiry\n  mapping (uint256 => uint256) internal _nftTempLockExpiry;\n\n  /// @dev maps tokenId to user address to operator address for approving various actions\n  mapping (uint256 => mapping(address => address)) internal _nftDischargeApproval;\n  mapping (uint256 => mapping(address => address)) internal _nftReleaseApproval;\n  mapping (uint256 => mapping(address => address)) internal _nftBreakBondApproval;\n  mapping (uint256 => mapping(address => address)) internal _nftTimelockApproval;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize(address initiator) public initializer {\n    __Ownable_init();\n    emit Initialized(initiator);\n  }\n\n  /***********************************|\n  |               Public              |\n  |__________________________________*/\n\n  function getDischargeTimelockExpiry(address contractAddress, uint256 tokenId) external view virtual override returns (uint256 lockExpiry) {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    if (_nftDischargeTimelockUnlockBlock[tokenUuid] > block.number) {\n      lockExpiry = _nftDischargeTimelockUnlockBlock[tokenUuid];\n    }\n    if (_nftTempLockExpiry[tokenUuid] > block.number && _nftTempLockExpiry[tokenUuid] > lockExpiry) {\n      lockExpiry = _nftTempLockExpiry[tokenUuid];\n    }\n  }\n\n  function getReleaseTimelockExpiry(address contractAddress, uint256 tokenId) external view virtual override returns (uint256 lockExpiry) {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    if (_nftReleaseTimelockUnlockBlock[tokenUuid] > block.number) {\n      lockExpiry = _nftReleaseTimelockUnlockBlock[tokenUuid];\n    }\n    if (_nftTempLockExpiry[tokenUuid] > block.number && _nftTempLockExpiry[tokenUuid] > lockExpiry) {\n      lockExpiry = _nftTempLockExpiry[tokenUuid];\n    }\n  }\n\n  function getBreakBondTimelockExpiry(address contractAddress, uint256 tokenId) external view virtual override returns (uint256 lockExpiry) {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    if (_nftBreakBondTimelockUnlockBlock[tokenUuid] > block.number) {\n      lockExpiry = _nftBreakBondTimelockUnlockBlock[tokenUuid];\n    }\n    if (_nftTempLockExpiry[tokenUuid] > block.number && _nftTempLockExpiry[tokenUuid] > lockExpiry) {\n      lockExpiry = _nftTempLockExpiry[tokenUuid];\n    }\n  }\n\n\n  /// @notice Checks if an operator is allowed to Discharge a specific Token\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the operator to check\n  /// @return True if the operator is Approved\n  function isApprovedForDischarge(address contractAddress, uint256 tokenId, address operator) external virtual override returns (bool) {\n    return _isApprovedForDischarge(contractAddress, tokenId, operator);\n  }\n\n  /// @notice Checks if an operator is allowed to Release a specific Token\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the operator to check\n  /// @return True if the operator is Approved\n  function isApprovedForRelease(address contractAddress, uint256 tokenId, address operator) external virtual override returns (bool) {\n    return _isApprovedForRelease(contractAddress, tokenId, operator);\n  }\n\n  /// @notice Checks if an operator is allowed to Break Covalent Bonds on a specific Token\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the operator to check\n  /// @return True if the operator is Approved\n  function isApprovedForBreakBond(address contractAddress, uint256 tokenId, address operator) external virtual override returns (bool) {\n    return _isApprovedForBreakBond(contractAddress, tokenId, operator);\n  }\n\n  /// @notice Checks if an operator is allowed to Timelock a specific Token\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the operator to check\n  /// @return True if the operator is Approved\n  function isApprovedForTimelock(address contractAddress, uint256 tokenId, address operator) external virtual override returns (bool) {\n    return _isApprovedForTimelock(contractAddress, tokenId, operator);\n  }\n\n\n  function isEnergizeRestricted(address contractAddress, uint256 tokenId) external virtual override view returns (bool) {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    return _nftActionPerms[tokenUuid].hasBit(PERM_RESTRICT_ENERGIZE_FROM_ALL);\n  }\n\n\n  function isCovalentBondRestricted(address contractAddress, uint256 tokenId) external virtual override view returns (bool) {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    return _nftActionPerms[tokenUuid].hasBit(PERM_RESTRICT_BOND_FROM_ALL);\n  }\n\n\n  function getDischargeState(address contractAddress, uint256 tokenId, address sender)\n    external\n    virtual\n    override\n    returns (\n      bool allowFromAll,\n      bool isApproved,\n      uint256 timelock,\n      uint256 tempLockExpiry\n    )\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    allowFromAll = _nftActionPerms[tokenUuid].hasBit(PERM_ALLOW_DISCHARGE_FROM_ALL);\n    isApproved = _isApprovedForDischarge(contractAddress, tokenId, sender);\n    timelock = _nftDischargeTimelockUnlockBlock[tokenUuid];\n    tempLockExpiry = _nftTempLockExpiry[tokenUuid];\n  }\n\n\n\n  function getReleaseState(address contractAddress, uint256 tokenId, address sender)\n    external\n    virtual\n    override\n    returns (\n      bool allowFromAll,\n      bool isApproved,\n      uint256 timelock,\n      uint256 tempLockExpiry\n    )\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    allowFromAll = _nftActionPerms[tokenUuid].hasBit(PERM_ALLOW_RELEASE_FROM_ALL);\n    isApproved = _isApprovedForRelease(contractAddress, tokenId, sender);\n    timelock = _nftReleaseTimelockUnlockBlock[tokenUuid];\n    tempLockExpiry = _nftTempLockExpiry[tokenUuid];\n  }\n\n\n\n  function getBreakBondState(address contractAddress, uint256 tokenId, address sender)\n    external\n    virtual\n    override\n    returns (\n      bool allowFromAll,\n      bool isApproved,\n      uint256 timelock,\n      uint256 tempLockExpiry\n    )\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    allowFromAll = _nftActionPerms[tokenUuid].hasBit(PERM_ALLOW_BREAK_BOND_FROM_ALL);\n    isApproved = _isApprovedForBreakBond(contractAddress, tokenId, sender);\n    timelock = _nftBreakBondTimelockUnlockBlock[tokenUuid];\n    tempLockExpiry = _nftTempLockExpiry[tokenUuid];\n  }\n\n\n\n\n  /***********************************|\n  |      Only NFT Owner/Operator      |\n  |__________________________________*/\n\n  /// @notice Sets an Operator as Approved to Discharge a specific Token\n  /// This allows an operator to withdraw the interest-portion only\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function setDischargeApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address operator\n  )\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    require(operator != tokenOwner, \"CP:E-106\");\n    _setDischargeApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @notice Sets an Operator as Approved to Release a specific Token\n  /// This allows an operator to withdraw the principal + interest\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function setReleaseApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address operator\n  )\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    require(operator != tokenOwner, \"CP:E-106\");\n    _setReleaseApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @notice Sets an Operator as Approved to Break Covalent Bonds on a specific Token\n  /// This allows an operator to withdraw Basket NFTs\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function setBreakBondApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address operator\n  )\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    require(operator != tokenOwner, \"CP:E-106\");\n    _setBreakBondApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @notice Sets an Operator as Approved to Timelock a specific Token\n  /// This allows an operator to timelock the principal or interest\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function setTimelockApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address operator\n  )\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    require(operator != tokenOwner, \"CP:E-106\");\n    _setTimelockApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @notice Sets an Operator as Approved to Discharge/Release/Timelock a specific Token\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function setApprovalForAll(\n    address contractAddress,\n    uint256 tokenId,\n    address operator\n  )\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    require(operator != tokenOwner, \"CP:E-106\");\n    _setDischargeApproval(contractAddress, tokenId, tokenOwner, operator);\n    _setReleaseApproval(contractAddress, tokenId, tokenOwner, operator);\n    _setBreakBondApproval(contractAddress, tokenId, tokenOwner, operator);\n    _setTimelockApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @dev Updates Restrictions on Energizing an NFT\n  function setPermsForRestrictCharge(address contractAddress, uint256 tokenId, bool state)\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    _setPermsForRestrictCharge(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Allowance on Discharging an NFT by Anyone\n  function setPermsForAllowDischarge(address contractAddress, uint256 tokenId, bool state)\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    _setPermsForAllowDischarge(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Allowance on Discharging an NFT by Anyone\n  function setPermsForAllowRelease(address contractAddress, uint256 tokenId, bool state)\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    _setPermsForAllowRelease(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Restrictions on Covalent Bonds on an NFT\n  function setPermsForRestrictBond(address contractAddress, uint256 tokenId, bool state)\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    _setPermsForRestrictBond(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Allowance on Breaking Covalent Bonds on an NFT by Anyone\n  function setPermsForAllowBreakBond(address contractAddress, uint256 tokenId, bool state)\n    external\n    virtual\n    override\n    onlyNFTOwnerOrOperator(contractAddress, tokenId, _msgSender())\n  {\n    _setPermsForAllowBreakBond(contractAddress, tokenId, state);\n  }\n\n  /// @notice Sets a Timelock on the ability to Discharge the Interest of a Particle\n  /// @param contractAddress  The Address to the NFT to Timelock\n  /// @param tokenId          The token ID of the NFT to Timelock\n  /// @param unlockBlock      The Ethereum Block-number to Timelock until (~15 seconds per block)\n  function setDischargeTimelock(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 unlockBlock\n  )\n    external\n    override\n    virtual\n  {\n    address sender = _msgSender();\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    // Clear Timelock\n    if (unlockBlock == 0 && _nftDischargeTimelockLockedBy[tokenUuid] == sender) {\n      delete _nftDischargeTimelockUnlockBlock[tokenUuid];\n      delete _nftDischargeTimelockLockedBy[tokenUuid];\n    }\n\n    // Set Timelock\n    else {\n      require(_isApprovedForTimelock(contractAddress, tokenId, sender), \"CP:E-105\");\n      require(block.number >= _nftDischargeTimelockUnlockBlock[tokenUuid], \"CP:E-302\");\n\n      _nftDischargeTimelockUnlockBlock[tokenUuid] = unlockBlock;\n      _nftDischargeTimelockLockedBy[tokenUuid] = sender;\n    }\n\n    emit TokenDischargeTimelock(contractAddress, tokenId, sender, unlockBlock);\n  }\n\n  /// @notice Sets a Timelock on the ability to Release the Assets of a Particle\n  /// @param contractAddress  The Address to the NFT to Timelock\n  /// @param tokenId          The token ID of the NFT to Timelock\n  /// @param unlockBlock      The Ethereum Block-number to Timelock until (~15 seconds per block)\n  function setReleaseTimelock(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 unlockBlock\n  )\n    external\n    override\n    virtual\n  {\n    address sender = _msgSender();\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    // Clear Timelock\n    if (unlockBlock == 0 && _nftReleaseTimelockLockedBy[tokenUuid] == sender) {\n      delete _nftReleaseTimelockUnlockBlock[tokenUuid];\n      delete _nftReleaseTimelockLockedBy[tokenUuid];\n    }\n\n    // Set Timelock\n    else {\n      require(_isApprovedForTimelock(contractAddress, tokenId, sender), \"CP:E-105\");\n      require(block.number >= _nftReleaseTimelockUnlockBlock[tokenUuid], \"CP:E-302\");\n\n      _nftReleaseTimelockUnlockBlock[tokenUuid] = unlockBlock;\n      _nftReleaseTimelockLockedBy[tokenUuid] = sender;\n    }\n\n    emit TokenReleaseTimelock(contractAddress, tokenId, sender, unlockBlock);\n  }\n\n  /// @notice Sets a Timelock on the ability to Break the Covalent Bond of a Particle\n  /// @param contractAddress  The Address to the NFT to Timelock\n  /// @param tokenId          The token ID of the NFT to Timelock\n  /// @param unlockBlock      The Ethereum Block-number to Timelock until (~15 seconds per block)\n  function setBreakBondTimelock(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 unlockBlock\n  )\n    external\n    override\n    virtual\n  {\n    address sender = _msgSender();\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    // Clear Timelock\n    if (unlockBlock == 0 && _nftBreakBondTimelockLockedBy[tokenUuid] == sender) {\n      delete _nftBreakBondTimelockUnlockBlock[tokenUuid];\n      delete _nftBreakBondTimelockLockedBy[tokenUuid];\n    }\n\n    // Set Timelock\n    else {\n      require(_isApprovedForTimelock(contractAddress, tokenId, sender), \"CP:E-105\");\n      require(block.number >= _nftBreakBondTimelockUnlockBlock[tokenUuid], \"CP:E-302\");\n\n      _nftBreakBondTimelockUnlockBlock[tokenUuid] = unlockBlock;\n      _nftBreakBondTimelockLockedBy[tokenUuid] = sender;\n    }\n\n    emit TokenBreakBondTimelock(contractAddress, tokenId, sender, unlockBlock);\n  }\n\n\n  /***********************************|\n  |         Only NFT Contract         |\n  |__________________________________*/\n\n  /// @notice Sets a Temporary-Lock on the ability to Release/Discharge the Assets of a Particle\n  /// @param contractAddress  The Address to the NFT to Timelock\n  /// @param tokenId          The token ID of the NFT to Timelock\n  /// @param isLocked         The locked state; contracts are expected to disable this lock before expiry\n  function setTemporaryLock(\n    address contractAddress,\n    uint256 tokenId,\n    bool isLocked\n  )\n    external\n    override\n    virtual\n  {\n    require(msg.sender == contractAddress, \"CP:E-112\");\n\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    uint256 unlockBlock;\n    if (isLocked && _nftTempLockExpiry[tokenUuid] == 0) {\n      unlockBlock = block.number.add(_chargedSettings.getTempLockExpiryBlocks());\n      _nftTempLockExpiry[tokenUuid] = unlockBlock;\n    }\n    if (!isLocked) {\n      _nftTempLockExpiry[tokenUuid] = 0;\n    }\n\n    emit TokenTempLock(contractAddress, tokenId, unlockBlock);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /// @dev Setup the various Charged-Controllers\n  function setController(address controller, string calldata controllerId) external virtual onlyOwner {\n    bytes32 controllerIdStr = keccak256(abi.encodePacked(controllerId));\n\n    if (controllerIdStr == keccak256(abi.encodePacked(\"settings\"))) {\n      _chargedSettings = IChargedSettings(controller);\n    }\n    else if (controllerIdStr == keccak256(abi.encodePacked(\"tokeninfo\"))) {\n      _tokenInfoProxy = ITokenInfoProxy(controller);\n    }\n\n    emit ControllerSet(controller, controllerId);\n  }\n\n  function migrateToken(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 releaseTimelockExpiry,\n    address releaseTimelockLockedBy,\n    uint256 tempLockExpiry\n  )\n    external\n    onlyOwner\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n\n    if (releaseTimelockExpiry > block.number && releaseTimelockLockedBy != address(0)) {\n      _nftReleaseTimelockUnlockBlock[tokenUuid] = releaseTimelockExpiry;\n      _nftReleaseTimelockLockedBy[tokenUuid] = releaseTimelockLockedBy;\n      emit TokenReleaseTimelock(contractAddress, tokenId, releaseTimelockLockedBy, releaseTimelockExpiry);\n    }\n\n    if (tempLockExpiry > 0) {\n      _nftTempLockExpiry[tokenUuid] = tempLockExpiry;\n      emit TokenTempLock(contractAddress, tokenId, tempLockExpiry);\n    }\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  /// @dev See {ChargedParticles-isApprovedForDischarge}.\n  function _isApprovedForDischarge(address contractAddress, uint256 tokenId, address operator) internal virtual returns (bool) {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    return contractAddress == operator || tokenOwner == operator || _nftDischargeApproval[tokenUuid][tokenOwner] == operator;\n  }\n\n  /// @dev See {ChargedParticles-isApprovedForRelease}.\n  function _isApprovedForRelease(address contractAddress, uint256 tokenId, address operator) internal virtual returns (bool) {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    return contractAddress == operator || tokenOwner == operator || _nftReleaseApproval[tokenUuid][tokenOwner] == operator;\n  }\n\n  /// @dev See {ChargedParticles-isApprovedForBreakBond}.\n  function _isApprovedForBreakBond(address contractAddress, uint256 tokenId, address operator) internal virtual returns (bool) {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    return contractAddress == operator || tokenOwner == operator || _nftBreakBondApproval[tokenUuid][tokenOwner] == operator;\n  }\n\n  /// @dev See {ChargedParticles-isApprovedForTimelock}.\n  function _isApprovedForTimelock(address contractAddress, uint256 tokenId, address operator) internal virtual returns (bool) {\n    (bool timelockAny, bool timelockOwn) = _chargedSettings.getTimelockApprovals(operator);\n    if (timelockAny || (timelockOwn && contractAddress == operator)) { return true; }\n\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    return tokenOwner == operator || _nftTimelockApproval[tokenUuid][tokenOwner] == operator;\n  }\n\n  /// @notice Sets an Operator as Approved to Discharge a specific Token\n  /// This allows an operator to withdraw the interest-portion only\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param tokenOwner       The Owner Address of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function _setDischargeApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address tokenOwner,\n    address operator\n  )\n    internal\n    virtual\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    _nftDischargeApproval[tokenUuid][tokenOwner] = operator;\n    emit DischargeApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @notice Sets an Operator as Approved to Release a specific Token\n  /// This allows an operator to withdraw the principal + interest\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param tokenOwner       The Owner Address of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function _setReleaseApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address tokenOwner,\n    address operator\n  )\n    internal\n    virtual\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    _nftReleaseApproval[tokenUuid][tokenOwner] = operator;\n    emit ReleaseApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @notice Sets an Operator as Approved to Break Covalent Bonds on a specific Token\n  /// This allows an operator to withdraw Basket NFTs\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param tokenOwner       The Owner Address of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function _setBreakBondApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address tokenOwner,\n    address operator\n  )\n    internal\n    virtual\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    _nftBreakBondApproval[tokenUuid][tokenOwner] = operator;\n    emit BreakBondApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @notice Sets an Operator as Approved to Timelock a specific Token\n  /// This allows an operator to timelock the principal or interest\n  /// @param contractAddress  The Address to the Contract of the Token\n  /// @param tokenId          The ID of the Token\n  /// @param tokenOwner       The Owner Address of the Token\n  /// @param operator         The Address of the Operator to Approve\n  function _setTimelockApproval(\n    address contractAddress,\n    uint256 tokenId,\n    address tokenOwner,\n    address operator\n  )\n    internal\n    virtual\n  {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    _nftTimelockApproval[tokenUuid][tokenOwner] = operator;\n    emit TimelockApproval(contractAddress, tokenId, tokenOwner, operator);\n  }\n\n  /// @dev Updates Restrictions on Energizing an NFT\n  function _setPermsForRestrictCharge(address contractAddress, uint256 tokenId, bool state) internal virtual {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    if (state) {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].setBit(PERM_RESTRICT_ENERGIZE_FROM_ALL);\n    } else {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].clearBit(PERM_RESTRICT_ENERGIZE_FROM_ALL);\n    }\n    emit PermsSetForRestrictCharge(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Allowance on Discharging an NFT by Anyone\n  function _setPermsForAllowDischarge(address contractAddress, uint256 tokenId, bool state) internal virtual {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    if (state) {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].setBit(PERM_ALLOW_DISCHARGE_FROM_ALL);\n    } else {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].clearBit(PERM_ALLOW_DISCHARGE_FROM_ALL);\n    }\n    emit PermsSetForAllowDischarge(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Allowance on Discharging an NFT by Anyone\n  function _setPermsForAllowRelease(address contractAddress, uint256 tokenId, bool state) internal virtual {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    if (state) {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].setBit(PERM_ALLOW_RELEASE_FROM_ALL);\n    } else {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].clearBit(PERM_ALLOW_RELEASE_FROM_ALL);\n    }\n    emit PermsSetForAllowRelease(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Restrictions on Covalent Bonds on an NFT\n  function _setPermsForRestrictBond(address contractAddress, uint256 tokenId, bool state) internal virtual {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    if (state) {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].setBit(PERM_RESTRICT_BOND_FROM_ALL);\n    } else {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].clearBit(PERM_RESTRICT_BOND_FROM_ALL);\n    }\n    emit PermsSetForRestrictBond(contractAddress, tokenId, state);\n  }\n\n  /// @dev Updates Allowance on Breaking Covalent Bonds on an NFT by Anyone\n  function _setPermsForAllowBreakBond(address contractAddress, uint256 tokenId, bool state) internal virtual {\n    uint256 tokenUuid = contractAddress.getTokenUUID(tokenId);\n    if (state) {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].setBit(PERM_ALLOW_BREAK_BOND_FROM_ALL);\n    } else {\n      _nftActionPerms[tokenUuid] = _nftActionPerms[tokenUuid].clearBit(PERM_ALLOW_BREAK_BOND_FROM_ALL);\n    }\n    emit PermsSetForAllowBreakBond(contractAddress, tokenId, state);\n  }\n\n\n  /***********************************|\n  |          GSN/MetaTx Relay         |\n  |__________________________________*/\n\n  /// @dev See {BaseRelayRecipient-_msgSender}.\n  function _msgSender()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, ContextUpgradeable)\n    returns (address payable)\n  {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  /// @dev See {BaseRelayRecipient-_msgData}.\n  function _msgData()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, ContextUpgradeable)\n    returns (bytes memory)\n  {\n    return BaseRelayRecipient._msgData();\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier onlyNFTOwnerOrOperator(address contractAddress, uint256 tokenId, address sender) {\n    require(_tokenInfoProxy.isNFTOwnerOrOperator(contractAddress, tokenId, sender), \"CP:E-105\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/incentives/CommunityVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\ncontract CommunityVault is Ownable, BlackholePrevention {\n\n    IERC20 private immutable _ionx;\n\n    constructor (address ionx) public {\n        _ionx = IERC20(ionx);\n    }\n\n    event SetAllowance(address indexed caller, address indexed spender, uint256 amount);\n\n    function setAllowance(address spender, uint amount) public onlyOwner {\n        _ionx.approve(spender, amount);\n\n        emit SetAllowance(msg.sender, spender, amount);\n    }\n\n    /***********************************|\n    |          Only Admin/DAO           |\n    |__________________________________*/\n\n    // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n    function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n        _withdrawEther(receiver, amount);\n    }\n\n    // Note: This contract should never hold any tokens other than IONX, if any are accidentally sent in then the DAO can return them\n    function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n        require(tokenAddress != address(_ionx), \"CommunityVault: cannot withdraw IONX\");\n        _withdrawERC20(receiver, tokenAddress, amount);\n    }\n\n    // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n    function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n        _withdrawERC721(receiver, tokenAddress, tokenId);\n    }\n}"
    },
    "contracts/v1/incentives/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"../interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor is IMerkleDistributor {\n    address public immutable override token;\n    bytes32 public immutable override merkleRoot;\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(address token_, bytes32 merkleRoot_) public {\n        token = token_;\n        merkleRoot = merkleRoot_;\n    }\n\n    function isClaimed(uint256 index) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\n        require(!isClaimed(index), 'MerkleDistributor: Drop already claimed.');\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), 'MerkleDistributor: Invalid proof.');\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        require(IERC20(token).transfer(account, amount), 'MerkleDistributor: Transfer failed.');\n\n        emit Claimed(index, account, amount);\n    }\n}\n"
    },
    "contracts/v1/incentives/MerkleDistributor2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"../interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor2 is IMerkleDistributor {\n    address public immutable override token;\n    bytes32 public immutable override merkleRoot;\n\n    address public owner;\n    uint256 public immutable expiryDate;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(address token_, bytes32 merkleRoot_, uint256 expiryDate_) public {\n        owner = msg.sender;\n        token = token_;\n        merkleRoot = merkleRoot_;\n        expiryDate = expiryDate_;\n    }\n\n    function isClaimed(uint256 index) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\n        require(!isClaimed(index), \"MerkleDistributor2: Drop already claimed.\");\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), \"MerkleDistributor2: Invalid proof.\");\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        require(IERC20(token).transfer(account, amount), \"MerkleDistributor2: Transfer failed.\");\n\n        emit Claimed(index, account, amount);\n    }\n\n    function expire(address exitAddress) external onlyOwner {\n        require(block.timestamp >= expiryDate, \"MerkleDistributor2: expiry date not reached\");\n        uint256 remainingBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(exitAddress, remainingBalance);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"MerkleDistributor2: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"MerkleDistributor2: not owner\");\n        _;\n    }\n}\n"
    },
    "contracts/v1/incentives/MerkleDistributor3.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"../interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor3 is IMerkleDistributor {\n    address public immutable override token;\n    bytes32 public immutable override merkleRoot;\n\n    address public owner;\n    uint256 public immutable expiryDate;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(address token_, bytes32 merkleRoot_, uint256 expiryDate_) public {\n        owner = msg.sender;\n        token = token_;\n        merkleRoot = merkleRoot_;\n        expiryDate = expiryDate_;\n    }\n\n    function isClaimed(uint256 index) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\n        require(!isClaimed(index), \"MerkleDistributor3: Drop already claimed.\");\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), \"MerkleDistributor3: Invalid proof.\");\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        require(IERC20(token).transfer(account, amount), \"MerkleDistributor3: Transfer failed.\");\n\n        emit Claimed(index, account, amount);\n    }\n\n    function expire(address exitAddress) external onlyOwner {\n        require(block.timestamp >= expiryDate, \"MerkleDistributor3: expiry date not reached\");\n        uint256 remainingBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(exitAddress, remainingBalance);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"MerkleDistributor3: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"MerkleDistributor3: not owner\");\n        _;\n    }\n}\n"
    },
    "contracts/v1/incentives/RewardProgram.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// RewardProgram.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2023 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IRewardProgram.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\nimport \"../interfaces/IUniverseRP.sol\";\nimport \"../interfaces/IChargedManagers.sol\";\nimport \"../interfaces/IWalletManager.sol\";\nimport \"../lib/TokenInfo.sol\";\nimport \"../lib/ReentrancyGuard.sol\";\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../interfaces/IERC20Detailed.sol\";\n\ncontract RewardProgram is\n  IRewardProgram,\n  BlackholePrevention,\n  IERC165,\n  ReentrancyGuard,\n  IERC721Receiver,\n  IERC1155Receiver\n{\n  using SafeMath for uint256;\n  using TokenInfo for address;\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  uint256 constant private PERCENTAGE_SCALE = 1e4; // 10000 (100%)\n  uint256 constant private LEPTON_MULTIPLIER_SCALE = 1e2;\n\n  address private _owner;\n  IUniverseRP private _universe;\n  IChargedManagers private _chargedManagers;\n  ProgramRewardData private _programData;\n  mapping(uint256 => AssetStake) private _assetStake;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor() public {}\n\n  function initialize(\n    address stakingToken,\n    address rewardToken,\n    uint256 baseMultiplier,\n    address chargedManagers,\n    address universe,\n    address owner\n  ) external override {\n    require(_owner == address(0x0), \"Already initialized\");\n    _owner = owner;\n\n    // Prepare Reward Program\n    _programData.stakingToken = stakingToken;\n    _programData.rewardToken = rewardToken;\n    _programData.baseMultiplier = baseMultiplier; // Basis Points\n\n    // Connect to Charged Particles\n    _chargedManagers = IChargedManagers(chargedManagers);\n    _universe = IUniverseRP(universe);\n  }\n\n\n  /***********************************|\n  |         Public Functions          |\n  |__________________________________*/\n\n  function getProgramData() external view override returns (ProgramRewardData memory) {\n    return _programData;\n  }\n\n  function getAssetStake(uint256 parentNftUuid) external view override returns (AssetStake memory) {\n    return _assetStake[parentNftUuid];\n  }\n\n  function getFundBalance() external view override returns (uint256) {\n    return _getFundBalance();\n  }\n\n  function calculateRewardsEarned(uint256 parentNftUuid, uint256 interestAmount) public view override returns (uint256) {\n    return _calculateRewardsEarned(parentNftUuid, interestAmount);\n  }\n\n  function getClaimableRewards(address contractAddress, uint256 tokenId) external view override returns (uint256) {\n    uint256 parentNftUuid = contractAddress.getTokenUUID(tokenId);\n    return _assetStake[parentNftUuid].claimableRewards;\n  }\n\n  function onERC721Received(address, address, uint256, bytes calldata) external override returns (bytes4) {\n    return IERC721Receiver.onERC721Received.selector;\n  }\n\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata) external override returns (bytes4) {\n    return IERC1155Receiver.onERC1155BatchReceived.selector;\n  }\n\n  function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external override returns (bytes4) {\n    return \"\";\n  }\n\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(IERC165)\n    returns (bool)\n  {\n    // default interface support\n    if (\n      interfaceId == type(IERC721Receiver).interfaceId ||\n      interfaceId == type(IERC1155Receiver).interfaceId ||\n      interfaceId == type(IERC165).interfaceId\n    ) {\n      return true;\n    }\n  }\n\n  function owner() public view returns (address) {\n    return _owner;\n  }\n\n\n  /***********************************|\n  |          Only Universe            |\n  |__________________________________*/\n\n  function registerAssetDeposit(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    uint256 principalAmount\n  )\n    external\n    override\n    onlyUniverse\n  {\n    uint256 parentNftUuid = contractAddress.getTokenUUID(tokenId);\n    AssetStake storage assetStake = _assetStake[parentNftUuid];\n\n    if (assetStake.start == 0) {\n      assetStake.start = block.number;\n      assetStake.walletManagerId = walletManagerId;\n    }\n    emit AssetDeposit(contractAddress, tokenId, walletManagerId, principalAmount);\n  }\n\n  function registerAssetRelease(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 interestAmount\n  )\n    external\n    override\n    onlyUniverse\n    nonReentrant\n    returns (uint256 rewards)\n  {\n    uint256 parentNftUuid = contractAddress.getTokenUUID(tokenId);\n    AssetStake storage assetStake = _assetStake[parentNftUuid];\n\n    // Update Claimable Rewards\n    uint256 newRewards = _calculateRewardsEarned(parentNftUuid, interestAmount);\n    assetStake.claimableRewards = assetStake.claimableRewards.add(newRewards);\n\n    // Reset Stake if Principal Balance falls to Zero\n    IWalletManager walletMgr = _chargedManagers.getWalletManager(assetStake.walletManagerId);\n    uint256 principal = walletMgr.getPrincipal(contractAddress, tokenId, _programData.stakingToken);\n    if (principal == 0) {\n      assetStake.start = 0;\n    }\n\n    // Issue Rewards to NFT Owner\n    rewards = _claimRewards(contractAddress, tokenId);\n\n    emit AssetRelease(contractAddress, tokenId, interestAmount);\n  }\n\n\n  /***********************************|\n  |         Reward Calculation        |\n  |__________________________________*/\n\n  function _calculateRewardsEarned(uint256 parentNftUuid, uint256 interestAmount) internal view returns (uint256 totalReward) {\n    uint256 baseReward = _calculateBaseReward(interestAmount);\n    uint256 leptonMultipliedReward = _calculateMultipliedReward(parentNftUuid, baseReward);\n    totalReward = _convertDecimals(leptonMultipliedReward);\n  }\n\n  function _calculateBaseReward(uint256 amount) internal view returns(uint256 baseReward) {\n    baseReward = amount.mul(_programData.baseMultiplier).div(PERCENTAGE_SCALE);\n  }\n\n  function _calculateMultipliedReward(uint256 parentNftUuid, uint256 baseReward) internal view returns(uint256) {\n    AssetStake storage assetStake = _assetStake[parentNftUuid];\n    if (assetStake.start == 0) { return baseReward; }\n\n    IUniverseRP.NftStake memory nftStake = _universe.getNftStake(parentNftUuid);\n    uint256 multiplierBP = nftStake.multiplier;\n\n    uint256 assetDepositLength = block.number.sub(assetStake.start);\n    uint256 nftDepositLength = 0;\n    if (nftStake.releaseBlockNumber > 0) {\n      nftDepositLength = nftStake.releaseBlockNumber.sub(nftStake.depositBlockNumber);\n    } else {\n      nftDepositLength = block.number.sub(nftStake.depositBlockNumber);\n    }\n\n    if (multiplierBP == 0 || nftDepositLength == 0 || assetDepositLength == 0) {\n      return baseReward;\n    }\n\n    if (nftDepositLength > assetDepositLength) {\n      nftDepositLength = assetDepositLength;\n    }\n\n    // Percentage of the total program that the Multiplier Nft was deposited for\n    uint256 nftRewardRatioBP = nftDepositLength.mul(PERCENTAGE_SCALE).div(assetDepositLength);\n\n    // Amount of reward that the Multiplier Nft is responsible for\n    uint256 amountGeneratedDuringNftDeposit = baseReward.mul(nftRewardRatioBP).div(PERCENTAGE_SCALE);\n\n    // Amount of Multiplied Reward from NFT\n    uint256 multipliedReward = amountGeneratedDuringNftDeposit.mul(multiplierBP.mul(LEPTON_MULTIPLIER_SCALE)).div(PERCENTAGE_SCALE);\n\n    // Amount of Base Reward without Multiplied NFT Rewards\n    uint256 amountGeneratedWithoutNftDeposit = baseReward.sub(amountGeneratedDuringNftDeposit);\n\n    // Amount of Base Rewards + Multiplied NFT Rewards\n    return amountGeneratedWithoutNftDeposit.add(multipliedReward);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function fundProgram(uint256 amount) external onlyOwner {\n    require(_programData.rewardToken != address(0), \"RP:E-405\");\n    IERC20(_programData.rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n    emit RewardProgramFunded(amount);\n  }\n\n  function setStakingToken(address newStakingToken) external onlyOwner {\n    _programData.stakingToken = newStakingToken;\n  }\n\n  function setRewardToken(address newRewardToken) external onlyOwner {\n    _programData.rewardToken = newRewardToken;\n  }\n\n  function setBaseMultiplier(uint256 newMultiplier) external onlyOwner {\n    _programData.baseMultiplier = newMultiplier; // Basis Points\n  }\n\n  function setChargedManagers(address manager) external onlyOwner {\n    _chargedManagers = IChargedManagers(manager);\n  }\n\n  function setUniverse(address universe) external onlyOwner {\n    _universe = IUniverseRP(universe);\n  }\n\n  function registerExistingDeposits(address contractAddress, uint256 tokenId, string calldata walletManagerId) external override onlyOwner {\n    uint256 parentNftUuid = contractAddress.getTokenUUID(tokenId);\n\n    // Initiate Asset Stake\n    IWalletManager walletMgr = _chargedManagers.getWalletManager(walletManagerId);\n    uint256 principal = walletMgr.getPrincipal(contractAddress, tokenId, _programData.stakingToken);\n    if (principal > 0) {\n      _assetStake[parentNftUuid] = AssetStake(block.number, 0, walletManagerId);\n      emit AssetRegistered(contractAddress, tokenId, walletManagerId, principal);\n    }\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _claimRewards(\n    address contractAddress,\n    uint256 tokenId\n  )\n    internal\n    returns (uint256 totalReward)\n  {\n    uint256 parentNftUuid = contractAddress.getTokenUUID(tokenId);\n    AssetStake storage assetStake = _assetStake[parentNftUuid];\n\n    // Rewards Receiver\n    address receiver = IERC721(contractAddress).ownerOf(tokenId);\n\n    // Ensure Reward Pool has Sufficient Balance\n    totalReward = assetStake.claimableRewards;\n    uint256 fundBalance = _getFundBalance();\n    uint256 unavailReward = totalReward > fundBalance ? totalReward.sub(fundBalance) : 0;\n\n    // Determine amount of Rewards to Transfer\n    if (unavailReward > 0) {\n      totalReward = totalReward.sub(unavailReward);\n      emit RewardProgramOutOfFunds();\n    }\n\n    // Update Asset Stake\n    assetStake.claimableRewards = unavailReward;\n\n    if (totalReward > 0) {\n      // Transfer Available Rewards to Receiver\n      IERC20(_programData.rewardToken).safeTransfer(receiver, totalReward);\n    }\n\n    emit RewardsClaimed(contractAddress, tokenId, receiver, totalReward, unavailReward);\n  }\n\n  function _convertDecimals(uint256 reward) internal view returns (uint256) {\n    uint8 stakingTokenDecimals = IERC20Detailed(_programData.stakingToken).decimals();\n    return reward.mul(10**(18 - uint256(stakingTokenDecimals)));\n  }\n\n  function _getFundBalance() internal view returns (uint256) {\n    return IERC20Detailed(_programData.rewardToken).balanceOf(address(this));\n  }\n\n\n  modifier onlyOwner() {\n    require(_owner == msg.sender, \"Caller is not the owner\");\n    _;\n  }\n\n  modifier onlyUniverse() {\n    require(msg.sender == address(_universe), \"RP:E-108\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/incentives/RewardProgramFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// RewardProgramFactory.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2023 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./RewardProgram.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\ncontract RewardProgramFactory is BlackholePrevention, Ownable {\n  event RewardProgramCreated(address indexed rewardProgram);\n\n  address public _template;\n\n  constructor () public {\n    _template = address(new RewardProgram());\n  }\n\n  // function _msgSender() internal view override returns (address payable) {\n  //   return msg.sender;\n  // }\n\n  function createRewardProgram(\n    address stakingToken,\n    address rewardToken,\n    uint256 baseMultiplier,\n    address chargedManagers,\n    address universe\n  )\n    external\n    onlyOwner\n    returns (address)\n  {\n    address newRewardProgram = _createClone(_template);\n    RewardProgram rewardProgram = RewardProgram(newRewardProgram);\n    rewardProgram.initialize(stakingToken, rewardToken, baseMultiplier, chargedManagers, universe, _msgSender());\n    emit RewardProgramCreated(newRewardProgram);\n    return newRewardProgram;\n  }\n\n  /**\n    * @dev Creates Contracts from a Template via Cloning\n    * see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n    */\n  function _createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n}\n"
    },
    "contracts/v1/incentives/Staking.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\ncontract Staking is\n        Ownable,\n        ReentrancyGuard,\n        BlackholePrevention\n{\n    using SafeMath for uint256;\n\n    uint128 constant private BASE_MULTIPLIER = uint128(1 * 10 ** 18);\n\n    bool internal _paused;\n\n    // timestamp for the epoch 1\n    // everything before that is considered epoch 0 which won't have a reward but allows for the initial stake\n    uint256 public immutable epoch1Start;\n\n    // duration of each epoch\n    uint256 public immutable epochDuration;\n\n    // holds the current balance of the user for each token\n    mapping(address => mapping(address => uint256)) private balances;\n\n    struct Pool {\n        uint256 size;\n        bool set;\n    }\n\n    // for each token, we store the total pool size\n    mapping(address => mapping(uint256 => Pool)) private poolSize;\n\n    // a checkpoint of the valid balance of a user for an epoch\n    struct Checkpoint {\n        uint128 epochId;\n        uint128 multiplier;\n        uint256 startBalance;\n        uint256 newDeposits;\n    }\n\n    // balanceCheckpoints[user][token][]\n    mapping(address => mapping(address => Checkpoint[])) private balanceCheckpoints;\n\n    mapping(address => uint128) private lastWithdrawEpochId;\n\n    event PausedStateSet(bool isPaused);\n    event Deposit(address indexed user, address indexed tokenAddress, uint256 amount);\n    event Withdraw(address indexed user, address indexed tokenAddress, uint256 amount);\n    event ManualEpochInit(address indexed caller, uint128 indexed epochId, address[] tokens);\n    event EmergencyWithdraw(address indexed user, address indexed tokenAddress, uint256 amount);\n\n    constructor (uint256 _epoch1Start, uint256 _epochDuration) public {\n        _paused = false;\n        epoch1Start = _epoch1Start;\n        epochDuration = _epochDuration;\n    }\n\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    /*\n     * Stores `amount` of `tokenAddress` tokens for the `user` into the vault\n     */\n    function deposit(address tokenAddress, uint256 amount) public nonReentrant whenNotPaused {\n        require(amount > 0, \"STK:E-205\");\n\n        IERC20 token = IERC20(tokenAddress);\n\n        balances[msg.sender][tokenAddress] = balances[msg.sender][tokenAddress].add(amount);\n\n        token.transferFrom(msg.sender, address(this), amount);\n\n        // epoch logic\n        uint128 currentEpoch = getCurrentEpoch();\n        uint128 currentMultiplier = currentEpochMultiplier();\n        uint256 balance = balances[msg.sender][tokenAddress];\n\n        if (!epochIsInitialized(tokenAddress, currentEpoch)) {\n            address[] memory tokens = new address[](1);\n            tokens[0] = tokenAddress;\n            manualEpochInit(tokens, currentEpoch);\n        }\n\n        // update the next epoch pool size\n        Pool storage pNextEpoch = poolSize[tokenAddress][currentEpoch + 1];\n        pNextEpoch.size = token.balanceOf(address(this));\n        pNextEpoch.set = true;\n\n        Checkpoint[] storage checkpoints = balanceCheckpoints[msg.sender][tokenAddress];\n\n        uint256 balanceBefore = getEpochUserBalance(msg.sender, tokenAddress, currentEpoch);\n\n        // if there's no checkpoint yet, it means the user didn't have any activity\n        // we want to store checkpoints both for the current epoch and next epoch because\n        // if a user does a withdraw, the current epoch can also be modified and\n        // we don't want to insert another checkpoint in the middle of the array as that could be expensive\n        if (checkpoints.length == 0) {\n            checkpoints.push(Checkpoint(currentEpoch, currentMultiplier, 0, amount));\n\n            // next epoch => multiplier is 1, epoch deposits is 0\n            checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, amount, 0));\n        } else {\n            uint256 last = checkpoints.length - 1;\n\n            // the last action happened in an older epoch (e.g. a deposit in epoch 3, current epoch is >=5)\n            if (checkpoints[last].epochId < currentEpoch) {\n                uint128 multiplier = computeNewMultiplier(\n                    getCheckpointBalance(checkpoints[last]),\n                    BASE_MULTIPLIER,\n                    amount,\n                    currentMultiplier\n                );\n                checkpoints.push(Checkpoint(currentEpoch, multiplier, getCheckpointBalance(checkpoints[last]), amount));\n                checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, balance, 0));\n            }\n            // the last action happened in the previous epoch\n            else if (checkpoints[last].epochId == currentEpoch) {\n                checkpoints[last].multiplier = computeNewMultiplier(\n                    getCheckpointBalance(checkpoints[last]),\n                    checkpoints[last].multiplier,\n                    amount,\n                    currentMultiplier\n                );\n                checkpoints[last].newDeposits = checkpoints[last].newDeposits.add(amount);\n\n                checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, balance, 0));\n            }\n            // the last action happened in the current epoch\n            else {\n                if (last >= 1 && checkpoints[last - 1].epochId == currentEpoch) {\n                    checkpoints[last - 1].multiplier = computeNewMultiplier(\n                        getCheckpointBalance(checkpoints[last - 1]),\n                        checkpoints[last - 1].multiplier,\n                        amount,\n                        currentMultiplier\n                    );\n                    checkpoints[last - 1].newDeposits = checkpoints[last - 1].newDeposits.add(amount);\n                }\n\n                checkpoints[last].startBalance = balance;\n            }\n        }\n\n        uint256 balanceAfter = getEpochUserBalance(msg.sender, tokenAddress, currentEpoch);\n\n        poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.add(balanceAfter.sub(balanceBefore));\n\n        emit Deposit(msg.sender, tokenAddress, amount);\n    }\n\n    /*\n     * Removes the deposit of the user and sends the amount of `tokenAddress` back to the `user`\n     */\n    function withdraw(address tokenAddress, uint256 amount) public nonReentrant {\n        require(balances[msg.sender][tokenAddress] >= amount, \"STK:E-432\");\n\n        balances[msg.sender][tokenAddress] = balances[msg.sender][tokenAddress].sub(amount);\n\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(msg.sender, amount);\n\n        // epoch logic\n        uint128 currentEpoch = getCurrentEpoch();\n\n        lastWithdrawEpochId[tokenAddress] = currentEpoch;\n\n        if (!epochIsInitialized(tokenAddress, currentEpoch)) {\n            address[] memory tokens = new address[](1);\n            tokens[0] = tokenAddress;\n            manualEpochInit(tokens, currentEpoch);\n        }\n\n        // update the pool size of the next epoch to its current balance\n        Pool storage pNextEpoch = poolSize[tokenAddress][currentEpoch + 1];\n        pNextEpoch.size = token.balanceOf(address(this));\n        pNextEpoch.set = true;\n\n        Checkpoint[] storage checkpoints = balanceCheckpoints[msg.sender][tokenAddress];\n        uint256 last = checkpoints.length - 1;\n\n        // note: it's impossible to have a withdraw and no checkpoints because the checkpoints[last] will be out of bound and revert\n\n        // there was a deposit in an older epoch (more than 1 behind [eg: previous 0, now 5]) but no other action since then\n        if (checkpoints[last].epochId < currentEpoch) {\n            checkpoints.push(Checkpoint(currentEpoch, BASE_MULTIPLIER, balances[msg.sender][tokenAddress], 0));\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(amount);\n        }\n        // there was a deposit in the `epochId - 1` epoch => we have a checkpoint for the current epoch\n        else if (checkpoints[last].epochId == currentEpoch) {\n            checkpoints[last].startBalance = balances[msg.sender][tokenAddress];\n            checkpoints[last].newDeposits = 0;\n            checkpoints[last].multiplier = BASE_MULTIPLIER;\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(amount);\n        }\n        // there was a deposit in the current epoch\n        else {\n            Checkpoint storage currentEpochCheckpoint = checkpoints[last - 1];\n\n            uint256 balanceBefore = getCheckpointEffectiveBalance(currentEpochCheckpoint);\n\n            // in case of withdraw, we have 2 branches:\n            // 1. the user withdraws less than he added in the current epoch\n            // 2. the user withdraws more than he added in the current epoch (including 0)\n            if (amount < currentEpochCheckpoint.newDeposits) {\n                uint128 avgDepositMultiplier = uint128(\n                    balanceBefore.sub(currentEpochCheckpoint.startBalance).mul(BASE_MULTIPLIER).div(currentEpochCheckpoint.newDeposits)\n                );\n\n                currentEpochCheckpoint.newDeposits = currentEpochCheckpoint.newDeposits.sub(amount);\n\n                currentEpochCheckpoint.multiplier = computeNewMultiplier(\n                    currentEpochCheckpoint.startBalance,\n                    BASE_MULTIPLIER,\n                    currentEpochCheckpoint.newDeposits,\n                    avgDepositMultiplier\n                );\n            } else {\n                currentEpochCheckpoint.startBalance = currentEpochCheckpoint.startBalance.sub(\n                    amount.sub(currentEpochCheckpoint.newDeposits)\n                );\n                currentEpochCheckpoint.newDeposits = 0;\n                currentEpochCheckpoint.multiplier = BASE_MULTIPLIER;\n            }\n\n            uint256 balanceAfter = getCheckpointEffectiveBalance(currentEpochCheckpoint);\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(balanceBefore.sub(balanceAfter));\n\n            checkpoints[last].startBalance = balances[msg.sender][tokenAddress];\n        }\n\n        emit Withdraw(msg.sender, tokenAddress, amount);\n    }\n\n    /*\n     * manualEpochInit can be used by anyone to initialize an epoch based on the previous one\n     * This is only applicable if there was no action (deposit/withdraw) in the current epoch.\n     * Any deposit and withdraw will automatically initialize the current and next epoch.\n     */\n    function manualEpochInit(address[] memory tokens, uint128 epochId) public whenNotPaused {\n        require(epochId <= getCurrentEpoch(), \"STK:E-306\");\n\n\n        for (uint i = 0; i < tokens.length; i++) {\n            Pool storage p = poolSize[tokens[i]][epochId];\n            if (epochId == 0) {\n                p.size = uint256(0);\n                p.set = true;\n            } else {\n                require(!epochIsInitialized(tokens[i], epochId), \"STK:E-002\");\n                require(epochIsInitialized(tokens[i], epochId - 1), \"STK:E-305\");\n                p.size = poolSize[tokens[i]][epochId - 1].size;\n                p.set = true;\n            }\n        }\n\n        emit ManualEpochInit(msg.sender, epochId, tokens);\n    }\n\n    function emergencyWithdraw(address tokenAddress) public {\n        require((getCurrentEpoch() - lastWithdrawEpochId[tokenAddress]) >= 10, \"STK:E-304\");\n\n        uint256 totalUserBalance = balances[msg.sender][tokenAddress];\n        require(totalUserBalance > 0, \"STK:E-205\");\n\n        balances[msg.sender][tokenAddress] = 0;\n\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(msg.sender, totalUserBalance);\n\n        emit EmergencyWithdraw(msg.sender, tokenAddress, totalUserBalance);\n    }\n\n    /*\n     * Returns the valid balance of a user that was taken into consideration in the total pool size for the epoch\n     * A deposit will only change the next epoch balance.\n     * A withdraw will decrease the current epoch (and subsequent) balance.\n     */\n    function getEpochUserBalance(address user, address token, uint128 epochId) public view returns (uint256) {\n        Checkpoint[] storage checkpoints = balanceCheckpoints[user][token];\n\n        // if there are no checkpoints, it means the user never deposited any tokens, so the balance is 0\n        if (checkpoints.length == 0 || epochId < checkpoints[0].epochId) {\n            return 0;\n        }\n\n        uint min = 0;\n        uint max = checkpoints.length - 1;\n\n        // shortcut for blocks newer than the latest checkpoint == current balance\n        if (epochId >= checkpoints[max].epochId) {\n            return getCheckpointEffectiveBalance(checkpoints[max]);\n        }\n\n        // binary search of the value in the array\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].epochId <= epochId) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n\n        return getCheckpointEffectiveBalance(checkpoints[min]);\n    }\n\n    /*\n     * Returns the amount of `token` that the `user` has currently staked\n     */\n    function balanceOf(address user, address token) public view returns (uint256) {\n        return balances[user][token];\n    }\n\n    /*\n     * Returns the id of the current epoch derived from block.timestamp\n     */\n    function getCurrentEpoch() public view returns (uint128) {\n        if (block.timestamp < epoch1Start) {\n            return 0;\n        }\n\n        return uint128((block.timestamp - epoch1Start) / epochDuration + 1);\n    }\n\n    /*\n     * Returns the total amount of `tokenAddress` that was locked from beginning to end of epoch identified by `epochId`\n     */\n    function getEpochPoolSize(address tokenAddress, uint128 epochId) public view returns (uint256) {\n        // Premises:\n        // 1. it's impossible to have gaps of uninitialized epochs\n        // - any deposit or withdraw initialize the current epoch which requires the previous one to be initialized\n        if (epochIsInitialized(tokenAddress, epochId)) {\n            return poolSize[tokenAddress][epochId].size;\n        }\n\n        // epochId not initialized and epoch 0 not initialized => there was never any action on this pool\n        if (!epochIsInitialized(tokenAddress, 0)) {\n            return 0;\n        }\n\n        // epoch 0 is initialized => there was an action at some point but none that initialized the epochId\n        // which means the current pool size is equal to the current balance of token held by the staking contract\n        IERC20 token = IERC20(tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    /*\n     * Returns the percentage of time left in the current epoch\n     */\n    function currentEpochMultiplier() public view returns (uint128) {\n        uint128 currentEpoch = getCurrentEpoch();\n        uint256 currentEpochEnd = epoch1Start + currentEpoch * epochDuration;\n        uint256 timeLeft = currentEpochEnd - block.timestamp;\n        uint128 multiplier = uint128(timeLeft * BASE_MULTIPLIER / epochDuration);\n\n        return multiplier;\n    }\n\n    function computeNewMultiplier(uint256 prevBalance, uint128 prevMultiplier, uint256 amount, uint128 currentMultiplier) public pure returns (uint128) {\n        uint256 prevAmount = prevBalance.mul(prevMultiplier).div(BASE_MULTIPLIER);\n        uint256 addAmount = amount.mul(currentMultiplier).div(BASE_MULTIPLIER);\n        uint128 newMultiplier = uint128(prevAmount.add(addAmount).mul(BASE_MULTIPLIER).div(prevBalance.add(amount)));\n\n        return newMultiplier;\n    }\n\n    /*\n     * Checks if an epoch is initialized, meaning we have a pool size set for it\n     */\n    function epochIsInitialized(address token, uint128 epochId) public view returns (bool) {\n        return poolSize[token][epochId].set;\n    }\n\n    function getCheckpointBalance(Checkpoint memory c) internal pure returns (uint256) {\n        return c.startBalance.add(c.newDeposits);\n    }\n\n    function getCheckpointEffectiveBalance(Checkpoint memory c) internal pure returns (uint256) {\n        return getCheckpointBalance(c).mul(c.multiplier).div(BASE_MULTIPLIER);\n    }\n\n\n    /***********************************|\n    |          Only Admin/DAO           |\n    |__________________________________*/\n\n    function setPausedState(bool paused) external onlyOwner {\n        _paused = paused;\n        emit PausedStateSet(paused);\n    }\n\n    // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n    function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n        _withdrawEther(receiver, amount);\n    }\n\n    modifier whenNotPaused() {\n        require(_paused != true, \"STK:E-101\");\n         _;\n    }\n\n}\n"
    },
    "contracts/v1/incentives/Staking2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\ncontract Staking2 is\n        Ownable,\n        ReentrancyGuard,\n        BlackholePrevention\n{\n    using SafeMath for uint256;\n\n    uint128 constant private BASE_MULTIPLIER = uint128(1 * 10 ** 18);\n\n    bool internal _paused;\n\n    // timestamp for the epoch 1\n    // everything before that is considered epoch 0 which won't have a reward but allows for the initial stake\n    uint256 public immutable epoch1Start;\n\n    // duration of each epoch\n    uint256 public immutable epochDuration;\n\n    // holds the current balance of the user for each token\n    mapping(address => mapping(address => uint256)) private balances;\n\n    struct Pool {\n        uint256 size;\n        bool set;\n    }\n\n    // for each token, we store the total pool size\n    mapping(address => mapping(uint256 => Pool)) private poolSize;\n\n    // a checkpoint of the valid balance of a user for an epoch\n    struct Checkpoint {\n        uint128 epochId;\n        uint128 multiplier;\n        uint256 startBalance;\n        uint256 newDeposits;\n    }\n\n    // balanceCheckpoints[user][token][]\n    mapping(address => mapping(address => Checkpoint[])) private balanceCheckpoints;\n\n    mapping(address => uint128) private lastWithdrawEpochId;\n\n    event PausedStateSet(bool isPaused);\n    event Deposit(address indexed user, address indexed tokenAddress, uint256 amount);\n    event Withdraw(address indexed user, address indexed tokenAddress, uint256 amount);\n    event ManualEpochInit(address indexed caller, uint128 indexed epochId, address[] tokens);\n    event EmergencyWithdraw(address indexed user, address indexed tokenAddress, uint256 amount);\n\n    constructor (uint256 _epoch1Start, uint256 _epochDuration) public {\n        _paused = false;\n        epoch1Start = _epoch1Start;\n        epochDuration = _epochDuration;\n    }\n\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    /*\n     * Stores `amount` of `tokenAddress` tokens for the `user` into the vault\n     */\n    function deposit(address tokenAddress, uint256 amount) public nonReentrant whenNotPaused {\n        require(amount > 0, \"STK:E-205\");\n\n        IERC20 token = IERC20(tokenAddress);\n\n        balances[msg.sender][tokenAddress] = balances[msg.sender][tokenAddress].add(amount);\n\n        token.transferFrom(msg.sender, address(this), amount);\n\n        // epoch logic\n        uint128 currentEpoch = getCurrentEpoch();\n        uint128 currentMultiplier = currentEpochMultiplier();\n        uint256 balance = balances[msg.sender][tokenAddress];\n\n        if (!epochIsInitialized(tokenAddress, currentEpoch)) {\n            address[] memory tokens = new address[](1);\n            tokens[0] = tokenAddress;\n            manualEpochInit(tokens, currentEpoch);\n        }\n\n        // update the next epoch pool size\n        Pool storage pNextEpoch = poolSize[tokenAddress][currentEpoch + 1];\n        pNextEpoch.size = token.balanceOf(address(this));\n        pNextEpoch.set = true;\n\n        Checkpoint[] storage checkpoints = balanceCheckpoints[msg.sender][tokenAddress];\n\n        uint256 balanceBefore = getEpochUserBalance(msg.sender, tokenAddress, currentEpoch);\n\n        // if there's no checkpoint yet, it means the user didn't have any activity\n        // we want to store checkpoints both for the current epoch and next epoch because\n        // if a user does a withdraw, the current epoch can also be modified and\n        // we don't want to insert another checkpoint in the middle of the array as that could be expensive\n        if (checkpoints.length == 0) {\n            checkpoints.push(Checkpoint(currentEpoch, currentMultiplier, 0, amount));\n\n            // next epoch => multiplier is 1, epoch deposits is 0\n            checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, amount, 0));\n        } else {\n            uint256 last = checkpoints.length - 1;\n\n            // the last action happened in an older epoch (e.g. a deposit in epoch 3, current epoch is >=5)\n            if (checkpoints[last].epochId < currentEpoch) {\n                uint128 multiplier = computeNewMultiplier(\n                    getCheckpointBalance(checkpoints[last]),\n                    BASE_MULTIPLIER,\n                    amount,\n                    currentMultiplier\n                );\n                checkpoints.push(Checkpoint(currentEpoch, multiplier, getCheckpointBalance(checkpoints[last]), amount));\n                checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, balance, 0));\n            }\n            // the last action happened in the previous epoch\n            else if (checkpoints[last].epochId == currentEpoch) {\n                checkpoints[last].multiplier = computeNewMultiplier(\n                    getCheckpointBalance(checkpoints[last]),\n                    checkpoints[last].multiplier,\n                    amount,\n                    currentMultiplier\n                );\n                checkpoints[last].newDeposits = checkpoints[last].newDeposits.add(amount);\n\n                checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, balance, 0));\n            }\n            // the last action happened in the current epoch\n            else {\n                if (last >= 1 && checkpoints[last - 1].epochId == currentEpoch) {\n                    checkpoints[last - 1].multiplier = computeNewMultiplier(\n                        getCheckpointBalance(checkpoints[last - 1]),\n                        checkpoints[last - 1].multiplier,\n                        amount,\n                        currentMultiplier\n                    );\n                    checkpoints[last - 1].newDeposits = checkpoints[last - 1].newDeposits.add(amount);\n                }\n\n                checkpoints[last].startBalance = balance;\n            }\n        }\n\n        uint256 balanceAfter = getEpochUserBalance(msg.sender, tokenAddress, currentEpoch);\n\n        poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.add(balanceAfter.sub(balanceBefore));\n\n        emit Deposit(msg.sender, tokenAddress, amount);\n    }\n\n    /*\n     * Removes the deposit of the user and sends the amount of `tokenAddress` back to the `user`\n     */\n    function withdraw(address tokenAddress, uint256 amount) public nonReentrant {\n        require(balances[msg.sender][tokenAddress] >= amount, \"STK:E-432\");\n\n        balances[msg.sender][tokenAddress] = balances[msg.sender][tokenAddress].sub(amount);\n\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(msg.sender, amount);\n\n        // epoch logic\n        uint128 currentEpoch = getCurrentEpoch();\n\n        lastWithdrawEpochId[tokenAddress] = currentEpoch;\n\n        if (!epochIsInitialized(tokenAddress, currentEpoch)) {\n            address[] memory tokens = new address[](1);\n            tokens[0] = tokenAddress;\n            manualEpochInit(tokens, currentEpoch);\n        }\n\n        // update the pool size of the next epoch to its current balance\n        Pool storage pNextEpoch = poolSize[tokenAddress][currentEpoch + 1];\n        pNextEpoch.size = token.balanceOf(address(this));\n        pNextEpoch.set = true;\n\n        Checkpoint[] storage checkpoints = balanceCheckpoints[msg.sender][tokenAddress];\n        uint256 last = checkpoints.length - 1;\n\n        // note: it's impossible to have a withdraw and no checkpoints because the checkpoints[last] will be out of bound and revert\n\n        // there was a deposit in an older epoch (more than 1 behind [eg: previous 0, now 5]) but no other action since then\n        if (checkpoints[last].epochId < currentEpoch) {\n            checkpoints.push(Checkpoint(currentEpoch, BASE_MULTIPLIER, balances[msg.sender][tokenAddress], 0));\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(amount);\n        }\n        // there was a deposit in the `epochId - 1` epoch => we have a checkpoint for the current epoch\n        else if (checkpoints[last].epochId == currentEpoch) {\n            checkpoints[last].startBalance = balances[msg.sender][tokenAddress];\n            checkpoints[last].newDeposits = 0;\n            checkpoints[last].multiplier = BASE_MULTIPLIER;\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(amount);\n        }\n        // there was a deposit in the current epoch\n        else {\n            Checkpoint storage currentEpochCheckpoint = checkpoints[last - 1];\n\n            uint256 balanceBefore = getCheckpointEffectiveBalance(currentEpochCheckpoint);\n\n            // in case of withdraw, we have 2 branches:\n            // 1. the user withdraws less than he added in the current epoch\n            // 2. the user withdraws more than he added in the current epoch (including 0)\n            if (amount < currentEpochCheckpoint.newDeposits) {\n                uint128 avgDepositMultiplier = uint128(\n                    balanceBefore.sub(currentEpochCheckpoint.startBalance).mul(BASE_MULTIPLIER).div(currentEpochCheckpoint.newDeposits)\n                );\n\n                currentEpochCheckpoint.newDeposits = currentEpochCheckpoint.newDeposits.sub(amount);\n\n                currentEpochCheckpoint.multiplier = computeNewMultiplier(\n                    currentEpochCheckpoint.startBalance,\n                    BASE_MULTIPLIER,\n                    currentEpochCheckpoint.newDeposits,\n                    avgDepositMultiplier\n                );\n            } else {\n                currentEpochCheckpoint.startBalance = currentEpochCheckpoint.startBalance.sub(\n                    amount.sub(currentEpochCheckpoint.newDeposits)\n                );\n                currentEpochCheckpoint.newDeposits = 0;\n                currentEpochCheckpoint.multiplier = BASE_MULTIPLIER;\n            }\n\n            uint256 balanceAfter = getCheckpointEffectiveBalance(currentEpochCheckpoint);\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(balanceBefore.sub(balanceAfter));\n\n            checkpoints[last].startBalance = balances[msg.sender][tokenAddress];\n        }\n\n        emit Withdraw(msg.sender, tokenAddress, amount);\n    }\n\n    /*\n     * manualEpochInit can be used by anyone to initialize an epoch based on the previous one\n     * This is only applicable if there was no action (deposit/withdraw) in the current epoch.\n     * Any deposit and withdraw will automatically initialize the current and next epoch.\n     */\n    function manualEpochInit(address[] memory tokens, uint128 epochId) public whenNotPaused {\n        require(epochId <= getCurrentEpoch(), \"STK:E-306\");\n\n\n        for (uint i = 0; i < tokens.length; i++) {\n            Pool storage p = poolSize[tokens[i]][epochId];\n            if (epochId == 0) {\n                p.size = uint256(0);\n                p.set = true;\n            } else {\n                require(!epochIsInitialized(tokens[i], epochId), \"STK:E-002\");\n                require(epochIsInitialized(tokens[i], epochId - 1), \"STK:E-305\");\n                p.size = poolSize[tokens[i]][epochId - 1].size;\n                p.set = true;\n            }\n        }\n\n        emit ManualEpochInit(msg.sender, epochId, tokens);\n    }\n\n    function emergencyWithdraw(address tokenAddress) public {\n        require((getCurrentEpoch() - lastWithdrawEpochId[tokenAddress]) >= 10, \"STK:E-304\");\n\n        uint256 totalUserBalance = balances[msg.sender][tokenAddress];\n        require(totalUserBalance > 0, \"STK:E-205\");\n\n        balances[msg.sender][tokenAddress] = 0;\n\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(msg.sender, totalUserBalance);\n\n        emit EmergencyWithdraw(msg.sender, tokenAddress, totalUserBalance);\n    }\n\n    /*\n     * Returns the valid balance of a user that was taken into consideration in the total pool size for the epoch\n     * A deposit will only change the next epoch balance.\n     * A withdraw will decrease the current epoch (and subsequent) balance.\n     */\n    function getEpochUserBalance(address user, address token, uint128 epochId) public view returns (uint256) {\n        Checkpoint[] storage checkpoints = balanceCheckpoints[user][token];\n\n        // if there are no checkpoints, it means the user never deposited any tokens, so the balance is 0\n        if (checkpoints.length == 0 || epochId < checkpoints[0].epochId) {\n            return 0;\n        }\n\n        uint min = 0;\n        uint max = checkpoints.length - 1;\n\n        // shortcut for blocks newer than the latest checkpoint == current balance\n        if (epochId >= checkpoints[max].epochId) {\n            return getCheckpointEffectiveBalance(checkpoints[max]);\n        }\n\n        // binary search of the value in the array\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].epochId <= epochId) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n\n        return getCheckpointEffectiveBalance(checkpoints[min]);\n    }\n\n    /*\n     * Returns the amount of `token` that the `user` has currently staked\n     */\n    function balanceOf(address user, address token) public view returns (uint256) {\n        return balances[user][token];\n    }\n\n    /*\n     * Returns the id of the current epoch derived from block.timestamp\n     */\n    function getCurrentEpoch() public view returns (uint128) {\n        if (block.timestamp < epoch1Start) {\n            return 0;\n        }\n\n        return uint128((block.timestamp - epoch1Start) / epochDuration + 1);\n    }\n\n    /*\n     * Returns the total amount of `tokenAddress` that was locked from beginning to end of epoch identified by `epochId`\n     */\n    function getEpochPoolSize(address tokenAddress, uint128 epochId) public view returns (uint256) {\n        // Premises:\n        // 1. it's impossible to have gaps of uninitialized epochs\n        // - any deposit or withdraw initialize the current epoch which requires the previous one to be initialized\n        if (epochIsInitialized(tokenAddress, epochId)) {\n            return poolSize[tokenAddress][epochId].size;\n        }\n\n        // epochId not initialized and epoch 0 not initialized => there was never any action on this pool\n        if (!epochIsInitialized(tokenAddress, 0)) {\n            return 0;\n        }\n\n        // epoch 0 is initialized => there was an action at some point but none that initialized the epochId\n        // which means the current pool size is equal to the current balance of token held by the staking contract\n        IERC20 token = IERC20(tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    /*\n     * Returns the percentage of time left in the current epoch\n     */\n    function currentEpochMultiplier() public view returns (uint128) {\n        uint128 currentEpoch = getCurrentEpoch();\n        uint256 currentEpochEnd = epoch1Start + currentEpoch * epochDuration;\n        uint256 timeLeft = currentEpochEnd - block.timestamp;\n        uint128 multiplier = uint128(timeLeft * BASE_MULTIPLIER / epochDuration);\n\n        return multiplier;\n    }\n\n    function computeNewMultiplier(uint256 prevBalance, uint128 prevMultiplier, uint256 amount, uint128 currentMultiplier) public pure returns (uint128) {\n        uint256 prevAmount = prevBalance.mul(prevMultiplier).div(BASE_MULTIPLIER);\n        uint256 addAmount = amount.mul(currentMultiplier).div(BASE_MULTIPLIER);\n        uint128 newMultiplier = uint128(prevAmount.add(addAmount).mul(BASE_MULTIPLIER).div(prevBalance.add(amount)));\n\n        return newMultiplier;\n    }\n\n    /*\n     * Checks if an epoch is initialized, meaning we have a pool size set for it\n     */\n    function epochIsInitialized(address token, uint128 epochId) public view returns (bool) {\n        return poolSize[token][epochId].set;\n    }\n\n    function getCheckpointBalance(Checkpoint memory c) internal pure returns (uint256) {\n        return c.startBalance.add(c.newDeposits);\n    }\n\n    function getCheckpointEffectiveBalance(Checkpoint memory c) internal pure returns (uint256) {\n        return getCheckpointBalance(c).mul(c.multiplier).div(BASE_MULTIPLIER);\n    }\n\n\n    /***********************************|\n    |          Only Admin/DAO           |\n    |__________________________________*/\n\n    function setPausedState(bool paused) external onlyOwner {\n        _paused = paused;\n        emit PausedStateSet(paused);\n    }\n\n    // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n    function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n        _withdrawEther(receiver, amount);\n    }\n\n    modifier whenNotPaused() {\n        require(_paused != true, \"STK:E-101\");\n         _;\n    }\n\n}\n"
    },
    "contracts/v1/incentives/Staking3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\ncontract Staking3 is\n        Ownable,\n        ReentrancyGuard,\n        BlackholePrevention\n{\n    using SafeMath for uint256;\n\n    uint128 constant private BASE_MULTIPLIER = uint128(1 * 10 ** 18);\n\n    bool internal _paused;\n\n    // timestamp for the epoch 1\n    // everything before that is considered epoch 0 which won't have a reward but allows for the initial stake\n    uint256 public immutable epoch1Start;\n\n    // duration of each epoch\n    uint256 public immutable epochDuration;\n\n    // holds the current balance of the user for each token\n    mapping(address => mapping(address => uint256)) private balances;\n\n    struct Pool {\n        uint256 size;\n        bool set;\n    }\n\n    // for each token, we store the total pool size\n    mapping(address => mapping(uint256 => Pool)) private poolSize;\n\n    // a checkpoint of the valid balance of a user for an epoch\n    struct Checkpoint {\n        uint128 epochId;\n        uint128 multiplier;\n        uint256 startBalance;\n        uint256 newDeposits;\n    }\n\n    // balanceCheckpoints[user][token][]\n    mapping(address => mapping(address => Checkpoint[])) private balanceCheckpoints;\n\n    mapping(address => uint128) private lastWithdrawEpochId;\n\n    event PausedStateSet(bool isPaused);\n    event Deposit(address indexed user, address indexed tokenAddress, uint256 amount);\n    event Withdraw(address indexed user, address indexed tokenAddress, uint256 amount);\n    event ManualEpochInit(address indexed caller, uint128 indexed epochId, address[] tokens);\n    event EmergencyWithdraw(address indexed user, address indexed tokenAddress, uint256 amount);\n\n    constructor (uint256 _epoch1Start, uint256 _epochDuration) public {\n        _paused = false;\n        epoch1Start = _epoch1Start;\n        epochDuration = _epochDuration;\n    }\n\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    /*\n     * Stores `amount` of `tokenAddress` tokens for the `user` into the vault\n     */\n    function deposit(address tokenAddress, uint256 amount) public nonReentrant whenNotPaused {\n        require(amount > 0, \"STK:E-205\");\n\n        IERC20 token = IERC20(tokenAddress);\n\n        balances[msg.sender][tokenAddress] = balances[msg.sender][tokenAddress].add(amount);\n\n        token.transferFrom(msg.sender, address(this), amount);\n\n        // epoch logic\n        uint128 currentEpoch = getCurrentEpoch();\n        uint128 currentMultiplier = currentEpochMultiplier();\n        uint256 balance = balances[msg.sender][tokenAddress];\n\n        if (!epochIsInitialized(tokenAddress, currentEpoch)) {\n            address[] memory tokens = new address[](1);\n            tokens[0] = tokenAddress;\n            manualEpochInit(tokens, currentEpoch);\n        }\n\n        // update the next epoch pool size\n        Pool storage pNextEpoch = poolSize[tokenAddress][currentEpoch + 1];\n        pNextEpoch.size = token.balanceOf(address(this));\n        pNextEpoch.set = true;\n\n        Checkpoint[] storage checkpoints = balanceCheckpoints[msg.sender][tokenAddress];\n\n        uint256 balanceBefore = getEpochUserBalance(msg.sender, tokenAddress, currentEpoch);\n\n        // if there's no checkpoint yet, it means the user didn't have any activity\n        // we want to store checkpoints both for the current epoch and next epoch because\n        // if a user does a withdraw, the current epoch can also be modified and\n        // we don't want to insert another checkpoint in the middle of the array as that could be expensive\n        if (checkpoints.length == 0) {\n            checkpoints.push(Checkpoint(currentEpoch, currentMultiplier, 0, amount));\n\n            // next epoch => multiplier is 1, epoch deposits is 0\n            checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, amount, 0));\n        } else {\n            uint256 last = checkpoints.length - 1;\n\n            // the last action happened in an older epoch (e.g. a deposit in epoch 3, current epoch is >=5)\n            if (checkpoints[last].epochId < currentEpoch) {\n                uint128 multiplier = computeNewMultiplier(\n                    getCheckpointBalance(checkpoints[last]),\n                    BASE_MULTIPLIER,\n                    amount,\n                    currentMultiplier\n                );\n                checkpoints.push(Checkpoint(currentEpoch, multiplier, getCheckpointBalance(checkpoints[last]), amount));\n                checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, balance, 0));\n            }\n            // the last action happened in the previous epoch\n            else if (checkpoints[last].epochId == currentEpoch) {\n                checkpoints[last].multiplier = computeNewMultiplier(\n                    getCheckpointBalance(checkpoints[last]),\n                    checkpoints[last].multiplier,\n                    amount,\n                    currentMultiplier\n                );\n                checkpoints[last].newDeposits = checkpoints[last].newDeposits.add(amount);\n\n                checkpoints.push(Checkpoint(currentEpoch + 1, BASE_MULTIPLIER, balance, 0));\n            }\n            // the last action happened in the current epoch\n            else {\n                if (last >= 1 && checkpoints[last - 1].epochId == currentEpoch) {\n                    checkpoints[last - 1].multiplier = computeNewMultiplier(\n                        getCheckpointBalance(checkpoints[last - 1]),\n                        checkpoints[last - 1].multiplier,\n                        amount,\n                        currentMultiplier\n                    );\n                    checkpoints[last - 1].newDeposits = checkpoints[last - 1].newDeposits.add(amount);\n                }\n\n                checkpoints[last].startBalance = balance;\n            }\n        }\n\n        uint256 balanceAfter = getEpochUserBalance(msg.sender, tokenAddress, currentEpoch);\n\n        poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.add(balanceAfter.sub(balanceBefore));\n\n        emit Deposit(msg.sender, tokenAddress, amount);\n    }\n\n    /*\n     * Removes the deposit of the user and sends the amount of `tokenAddress` back to the `user`\n     */\n    function withdraw(address tokenAddress, uint256 amount) public nonReentrant {\n        require(balances[msg.sender][tokenAddress] >= amount, \"STK:E-432\");\n\n        balances[msg.sender][tokenAddress] = balances[msg.sender][tokenAddress].sub(amount);\n\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(msg.sender, amount);\n\n        // epoch logic\n        uint128 currentEpoch = getCurrentEpoch();\n\n        lastWithdrawEpochId[tokenAddress] = currentEpoch;\n\n        if (!epochIsInitialized(tokenAddress, currentEpoch)) {\n            address[] memory tokens = new address[](1);\n            tokens[0] = tokenAddress;\n            manualEpochInit(tokens, currentEpoch);\n        }\n\n        // update the pool size of the next epoch to its current balance\n        Pool storage pNextEpoch = poolSize[tokenAddress][currentEpoch + 1];\n        pNextEpoch.size = token.balanceOf(address(this));\n        pNextEpoch.set = true;\n\n        Checkpoint[] storage checkpoints = balanceCheckpoints[msg.sender][tokenAddress];\n        uint256 last = checkpoints.length - 1;\n\n        // note: it's impossible to have a withdraw and no checkpoints because the checkpoints[last] will be out of bound and revert\n\n        // there was a deposit in an older epoch (more than 1 behind [eg: previous 0, now 5]) but no other action since then\n        if (checkpoints[last].epochId < currentEpoch) {\n            checkpoints.push(Checkpoint(currentEpoch, BASE_MULTIPLIER, balances[msg.sender][tokenAddress], 0));\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(amount);\n        }\n        // there was a deposit in the `epochId - 1` epoch => we have a checkpoint for the current epoch\n        else if (checkpoints[last].epochId == currentEpoch) {\n            checkpoints[last].startBalance = balances[msg.sender][tokenAddress];\n            checkpoints[last].newDeposits = 0;\n            checkpoints[last].multiplier = BASE_MULTIPLIER;\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(amount);\n        }\n        // there was a deposit in the current epoch\n        else {\n            Checkpoint storage currentEpochCheckpoint = checkpoints[last - 1];\n\n            uint256 balanceBefore = getCheckpointEffectiveBalance(currentEpochCheckpoint);\n\n            // in case of withdraw, we have 2 branches:\n            // 1. the user withdraws less than he added in the current epoch\n            // 2. the user withdraws more than he added in the current epoch (including 0)\n            if (amount < currentEpochCheckpoint.newDeposits) {\n                uint128 avgDepositMultiplier = uint128(\n                    balanceBefore.sub(currentEpochCheckpoint.startBalance).mul(BASE_MULTIPLIER).div(currentEpochCheckpoint.newDeposits)\n                );\n\n                currentEpochCheckpoint.newDeposits = currentEpochCheckpoint.newDeposits.sub(amount);\n\n                currentEpochCheckpoint.multiplier = computeNewMultiplier(\n                    currentEpochCheckpoint.startBalance,\n                    BASE_MULTIPLIER,\n                    currentEpochCheckpoint.newDeposits,\n                    avgDepositMultiplier\n                );\n            } else {\n                currentEpochCheckpoint.startBalance = currentEpochCheckpoint.startBalance.sub(\n                    amount.sub(currentEpochCheckpoint.newDeposits)\n                );\n                currentEpochCheckpoint.newDeposits = 0;\n                currentEpochCheckpoint.multiplier = BASE_MULTIPLIER;\n            }\n\n            uint256 balanceAfter = getCheckpointEffectiveBalance(currentEpochCheckpoint);\n\n            poolSize[tokenAddress][currentEpoch].size = poolSize[tokenAddress][currentEpoch].size.sub(balanceBefore.sub(balanceAfter));\n\n            checkpoints[last].startBalance = balances[msg.sender][tokenAddress];\n        }\n\n        emit Withdraw(msg.sender, tokenAddress, amount);\n    }\n\n    /*\n     * manualEpochInit can be used by anyone to initialize an epoch based on the previous one\n     * This is only applicable if there was no action (deposit/withdraw) in the current epoch.\n     * Any deposit and withdraw will automatically initialize the current and next epoch.\n     */\n    function manualEpochInit(address[] memory tokens, uint128 epochId) public whenNotPaused {\n        require(epochId <= getCurrentEpoch(), \"STK:E-306\");\n\n\n        for (uint i = 0; i < tokens.length; i++) {\n            Pool storage p = poolSize[tokens[i]][epochId];\n            if (epochId == 0) {\n                p.size = uint256(0);\n                p.set = true;\n            } else {\n                require(!epochIsInitialized(tokens[i], epochId), \"STK:E-002\");\n                require(epochIsInitialized(tokens[i], epochId - 1), \"STK:E-305\");\n                p.size = poolSize[tokens[i]][epochId - 1].size;\n                p.set = true;\n            }\n        }\n\n        emit ManualEpochInit(msg.sender, epochId, tokens);\n    }\n\n    function emergencyWithdraw(address tokenAddress) public {\n        require((getCurrentEpoch() - lastWithdrawEpochId[tokenAddress]) >= 10, \"STK:E-304\");\n\n        uint256 totalUserBalance = balances[msg.sender][tokenAddress];\n        require(totalUserBalance > 0, \"STK:E-205\");\n\n        balances[msg.sender][tokenAddress] = 0;\n\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(msg.sender, totalUserBalance);\n\n        emit EmergencyWithdraw(msg.sender, tokenAddress, totalUserBalance);\n    }\n\n    /*\n     * Returns the valid balance of a user that was taken into consideration in the total pool size for the epoch\n     * A deposit will only change the next epoch balance.\n     * A withdraw will decrease the current epoch (and subsequent) balance.\n     */\n    function getEpochUserBalance(address user, address token, uint128 epochId) public view returns (uint256) {\n        Checkpoint[] storage checkpoints = balanceCheckpoints[user][token];\n\n        // if there are no checkpoints, it means the user never deposited any tokens, so the balance is 0\n        if (checkpoints.length == 0 || epochId < checkpoints[0].epochId) {\n            return 0;\n        }\n\n        uint min = 0;\n        uint max = checkpoints.length - 1;\n\n        // shortcut for blocks newer than the latest checkpoint == current balance\n        if (epochId >= checkpoints[max].epochId) {\n            return getCheckpointEffectiveBalance(checkpoints[max]);\n        }\n\n        // binary search of the value in the array\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].epochId <= epochId) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n\n        return getCheckpointEffectiveBalance(checkpoints[min]);\n    }\n\n    /*\n     * Returns the amount of `token` that the `user` has currently staked\n     */\n    function balanceOf(address user, address token) public view returns (uint256) {\n        return balances[user][token];\n    }\n\n    /*\n     * Returns the id of the current epoch derived from block.timestamp\n     */\n    function getCurrentEpoch() public view returns (uint128) {\n        if (block.timestamp < epoch1Start) {\n            return 0;\n        }\n\n        return uint128((block.timestamp - epoch1Start) / epochDuration + 1);\n    }\n\n    /*\n     * Returns the total amount of `tokenAddress` that was locked from beginning to end of epoch identified by `epochId`\n     */\n    function getEpochPoolSize(address tokenAddress, uint128 epochId) public view returns (uint256) {\n        // Premises:\n        // 1. it's impossible to have gaps of uninitialized epochs\n        // - any deposit or withdraw initialize the current epoch which requires the previous one to be initialized\n        if (epochIsInitialized(tokenAddress, epochId)) {\n            return poolSize[tokenAddress][epochId].size;\n        }\n\n        // epochId not initialized and epoch 0 not initialized => there was never any action on this pool\n        if (!epochIsInitialized(tokenAddress, 0)) {\n            return 0;\n        }\n\n        // epoch 0 is initialized => there was an action at some point but none that initialized the epochId\n        // which means the current pool size is equal to the current balance of token held by the staking contract\n        IERC20 token = IERC20(tokenAddress);\n        return token.balanceOf(address(this));\n    }\n\n    /*\n     * Returns the percentage of time left in the current epoch\n     */\n    function currentEpochMultiplier() public view returns (uint128) {\n        uint128 currentEpoch = getCurrentEpoch();\n        uint256 currentEpochEnd = epoch1Start + currentEpoch * epochDuration;\n        uint256 timeLeft = currentEpochEnd - block.timestamp;\n        uint128 multiplier = uint128(timeLeft * BASE_MULTIPLIER / epochDuration);\n\n        return multiplier;\n    }\n\n    function computeNewMultiplier(uint256 prevBalance, uint128 prevMultiplier, uint256 amount, uint128 currentMultiplier) public pure returns (uint128) {\n        uint256 prevAmount = prevBalance.mul(prevMultiplier).div(BASE_MULTIPLIER);\n        uint256 addAmount = amount.mul(currentMultiplier).div(BASE_MULTIPLIER);\n        uint128 newMultiplier = uint128(prevAmount.add(addAmount).mul(BASE_MULTIPLIER).div(prevBalance.add(amount)));\n\n        return newMultiplier;\n    }\n\n    /*\n     * Checks if an epoch is initialized, meaning we have a pool size set for it\n     */\n    function epochIsInitialized(address token, uint128 epochId) public view returns (bool) {\n        return poolSize[token][epochId].set;\n    }\n\n    function getCheckpointBalance(Checkpoint memory c) internal pure returns (uint256) {\n        return c.startBalance.add(c.newDeposits);\n    }\n\n    function getCheckpointEffectiveBalance(Checkpoint memory c) internal pure returns (uint256) {\n        return getCheckpointBalance(c).mul(c.multiplier).div(BASE_MULTIPLIER);\n    }\n\n\n    /***********************************|\n    |          Only Admin/DAO           |\n    |__________________________________*/\n\n    function setPausedState(bool paused) external onlyOwner {\n        _paused = paused;\n        emit PausedStateSet(paused);\n    }\n\n    // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n    function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n        _withdrawEther(receiver, amount);\n    }\n\n    modifier whenNotPaused() {\n        require(_paused != true, \"STK:E-101\");\n         _;\n    }\n\n}\n"
    },
    "contracts/v1/incentives/YieldFarm.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../interfaces/IStaking.sol\";\n\ncontract YieldFarm is Ownable, BlackholePrevention {\n\n    // lib\n    using SafeMath for uint;\n    using SafeMath for uint128;\n\n    // constants\n    uint public immutable TOTAL_DISTRIBUTED_AMOUNT;\n    uint public immutable NR_OF_EPOCHS;\n\n    // state variables\n\n    // addreses\n    address private immutable _token;\n    address private immutable _communityVault;\n    // contracts\n    IERC20 private immutable _ionx;\n    IStaking private _staking;\n\n\n    uint[] private epochs;\n    uint private immutable _genesisEpochAmount;\n    uint private _deprecationPerEpoch;\n    uint128 public lastInitializedEpoch;\n    bool internal _paused;\n    mapping(address => uint128) public lastEpochIdHarvested;\n    uint public epochDuration; // init from staking contract\n    uint public immutable epochStart; // init from staking contract\n\n    // events\n    event PausedStateSet(bool isPaused);\n    event MassHarvest(address indexed user, uint256 epochsHarvested, uint256 totalValue);\n    event Harvest(address indexed user, uint128 indexed epochId, uint256 amount);\n\n    // constructor\n    constructor(address ionxTokenAddress, address token, address stakeContract, address communityVault, uint genesisEpochAmount, uint deprecationPerEpoch, uint nrOfEpochs) public {\n        _paused = false;\n        _ionx = IERC20(ionxTokenAddress);\n        _token = token;\n        _staking = IStaking(stakeContract);\n        _communityVault = communityVault;\n        epochDuration = _staking.epochDuration();\n        epochStart = _staking.epoch1Start() + epochDuration;\n        _deprecationPerEpoch = deprecationPerEpoch;\n        uint n = nrOfEpochs;\n        uint amountEpochN = genesisEpochAmount.sub(n.sub(1).mul(_deprecationPerEpoch));\n        TOTAL_DISTRIBUTED_AMOUNT = n.mul((genesisEpochAmount.add(amountEpochN)).div(2));\n        NR_OF_EPOCHS = nrOfEpochs;\n        epochs = new uint[](nrOfEpochs + 1);\n        _genesisEpochAmount = genesisEpochAmount;\n\n    }\n\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    function getAmountClaimable() external view returns (uint) {\n        uint totalClaimable;\n        uint epochId = _getEpochId().sub(1); // fails in epoch 0\n\n        // force max number of epochs\n        if (epochId > NR_OF_EPOCHS) {\n            epochId = NR_OF_EPOCHS;\n        }\n\n        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\n            totalClaimable += _getAmountClaimableAtEpoch(msg.sender, i);\n        }\n\n        return totalClaimable;\n    }\n\n    // public method to harvest all the unharvested epochs until current epoch - 1\n    function massHarvest() external whenNotPaused returns (uint){\n        uint totalDistributedValue;\n        uint epochId = _getEpochId().sub(1); // fails in epoch 0\n        uint lastEpochIdHarvestedUser = lastEpochIdHarvested[msg.sender];\n\n        // force max number of epochs\n        if (epochId > NR_OF_EPOCHS) {\n            epochId = NR_OF_EPOCHS;\n        }\n\n        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\n            // i = epochId\n            // compute distributed Value and do one single transfer at the end\n            totalDistributedValue += _harvest(i);\n        }\n\n        emit MassHarvest(msg.sender, epochId - lastEpochIdHarvestedUser, totalDistributedValue);\n\n        if (totalDistributedValue > 0) {\n            _ionx.transferFrom(_communityVault, msg.sender, totalDistributedValue);\n        }\n\n        return totalDistributedValue;\n    }\n    function harvest (uint128 epochId) external whenNotPaused returns (uint){\n        // checks for requested epoch\n        require (_getEpochId() > epochId, \"YLD:E-306\");\n        require(epochId <= NR_OF_EPOCHS, \"YLD:E-408\");\n        require (lastEpochIdHarvested[msg.sender].add(1) == epochId, \"YLD:E-204\");\n        uint userReward = _harvest(epochId);\n        if (userReward > 0) {\n            _ionx.transferFrom(_communityVault, msg.sender, userReward);\n        }\n        emit Harvest(msg.sender, epochId, userReward);\n        return userReward;\n    }\n\n    // views\n    // calls to the staking smart contract to retrieve the epoch total pool size\n    function getPoolSize(uint128 epochId) external view returns (uint) {\n        return _getPoolSize(epochId);\n    }\n\n    function getCurrentEpoch() external view returns (uint) {\n        return _getEpochId();\n    }\n\n    // calls to the staking smart contract to retrieve user balance for an epoch\n    function getEpochStake(address userAddress, uint128 epochId) external view returns (uint) {\n        return _getUserBalancePerEpoch(userAddress, epochId);\n    }\n\n    function getGenesisEpochAmount() external view returns (uint){\n        return _genesisEpochAmount;\n    }\n\n    function getDeprecationPerEpoch() external view returns (uint){\n        return _deprecationPerEpoch;\n    }\n\n    function userLastEpochIdHarvested() external view returns (uint){\n        return lastEpochIdHarvested[msg.sender];\n    }\n\n    // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n    function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n        _withdrawEther(receiver, amount);\n    }\n\n    // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n    function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n        _withdrawERC20(receiver, tokenAddress, amount);\n    }\n\n    // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n    function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n        _withdrawERC721(receiver, tokenAddress, tokenId);\n    }\n\n    // internal methods\n\n    function _initEpoch(uint128 epochId) internal {\n        require(lastInitializedEpoch.add(1) == epochId, \"YLD:E-204\");\n        lastInitializedEpoch = epochId;\n        // call the staking smart contract to init the epoch\n        epochs[epochId] = _getPoolSize(epochId);\n    }\n\n    function _getAmountClaimableAtEpoch(address account, uint128 epochId) internal view returns (uint) {\n        if (epochs[epochId] == 0) { return 0; }\n        return _calcTotalAmountPerEpoch(epochId)\n          .mul(_getUserBalancePerEpoch(account, epochId))\n          .div(epochs[epochId]);\n    }\n\n    function _harvest (uint128 epochId) internal returns (uint) {\n        // try to initialize an epoch. if it can't it fails\n        // if it fails either user either a BarnBridge account will init not init epochs\n        if (lastInitializedEpoch < epochId) {\n            _initEpoch(epochId);\n        }\n        // Set user state for last harvested\n        lastEpochIdHarvested[msg.sender] = epochId;\n        // compute and return user total reward. For optimization reasons the transfer have been moved to an upper layer (i.e. massHarvest needs to do a single transfer)\n\n        // exit if there is no stake on the epoch\n        if (epochs[epochId] == 0) {\n            return 0;\n        }\n        return _calcTotalAmountPerEpoch(epochId)\n          .mul(_getUserBalancePerEpoch(msg.sender, epochId))\n          .div(epochs[epochId]);\n    }\n\n    function _calcTotalAmountPerEpoch(uint256 epochId) internal view returns (uint) {\n      return _genesisEpochAmount.sub(epochId.mul(_deprecationPerEpoch)); // .sub(1) ?\n    }\n\n    function _getPoolSize(uint128 epochId) internal view returns (uint) {\n        // retrieve token token balance\n        return _staking.getEpochPoolSize(_token, _stakingEpochId(epochId));\n    }\n\n    function _getUserBalancePerEpoch(address userAddress, uint128 epochId) internal view returns (uint){\n        // retrieve token token balance per user per epoch\n        return _staking.getEpochUserBalance(userAddress, _token, _stakingEpochId(epochId));\n    }\n\n    // compute epoch id from blocktimestamp and epochstart date\n    function _getEpochId() internal view returns (uint128 epochId) {\n        if (block.timestamp < epochStart) {\n            return 0;\n        }\n        epochId = uint128(block.timestamp.sub(epochStart).div(epochDuration).add(1));\n    }\n\n    // get the staking epoch which is 1 epoch more\n    function _stakingEpochId(uint128 epochId) pure internal returns (uint128) {\n        return epochId + 1;\n    }\n\n    modifier whenNotPaused() {\n        require(_paused != true, \"YLD:E-101\");\n        _;\n    }\n}"
    },
    "contracts/v1/incentives/YieldFarm2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../interfaces/IStaking.sol\";\n\ncontract YieldFarm2 is Ownable, BlackholePrevention {\n\n    // lib\n    using SafeMath for uint;\n    using SafeMath for uint128;\n\n    // constants\n    uint public immutable TOTAL_DISTRIBUTED_AMOUNT;\n    uint public immutable NR_OF_EPOCHS;\n\n    // state variables\n\n    // addreses\n    address private immutable _token;\n    address private immutable _communityVault;\n    // contracts\n    IERC20 private immutable _ionx;\n    IStaking private _staking;\n\n\n    uint[] private epochs;\n    uint private immutable _genesisEpochAmount;\n    uint private _deprecationPerEpoch;\n    uint128 public lastInitializedEpoch;\n    bool internal _paused;\n    mapping(address => uint128) public lastEpochIdHarvested;\n    uint public epochDuration; // init from staking contract\n    uint public immutable epochStart; // init from staking contract\n\n    // events\n    event PausedStateSet(bool isPaused);\n    event MassHarvest(address indexed user, uint256 epochsHarvested, uint256 totalValue);\n    event Harvest(address indexed user, uint128 indexed epochId, uint256 amount);\n\n    // constructor\n    constructor(address ionxTokenAddress, address token, address stakeContract, address communityVault, uint genesisEpochAmount, uint deprecationPerEpoch, uint nrOfEpochs) public {\n        _paused = false;\n        _ionx = IERC20(ionxTokenAddress);\n        _token = token;\n        _staking = IStaking(stakeContract);\n        _communityVault = communityVault;\n        epochDuration = _staking.epochDuration();\n        epochStart = _staking.epoch1Start() + epochDuration;\n        _deprecationPerEpoch = deprecationPerEpoch;\n        uint n = nrOfEpochs;\n        uint amountEpochN = genesisEpochAmount.sub(n.sub(1).mul(_deprecationPerEpoch));\n        TOTAL_DISTRIBUTED_AMOUNT = n.mul((genesisEpochAmount.add(amountEpochN)).div(2));\n        NR_OF_EPOCHS = nrOfEpochs;\n        epochs = new uint[](nrOfEpochs + 1);\n        _genesisEpochAmount = genesisEpochAmount;\n\n    }\n\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    function getAmountClaimable() external view returns (uint) {\n        uint totalClaimable;\n        uint epochId = _getEpochId().sub(1); // fails in epoch 0\n\n        // force max number of epochs\n        if (epochId > NR_OF_EPOCHS) {\n            epochId = NR_OF_EPOCHS;\n        }\n\n        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\n            totalClaimable += _getAmountClaimableAtEpoch(msg.sender, i);\n        }\n\n        return totalClaimable;\n    }\n\n    // public method to harvest all the unharvested epochs until current epoch - 1\n    function massHarvest() external whenNotPaused returns (uint){\n        uint totalDistributedValue;\n        uint epochId = _getEpochId().sub(1); // fails in epoch 0\n        uint lastEpochIdHarvestedUser = lastEpochIdHarvested[msg.sender];\n\n        // force max number of epochs\n        if (epochId > NR_OF_EPOCHS) {\n            epochId = NR_OF_EPOCHS;\n        }\n\n        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\n            // i = epochId\n            // compute distributed Value and do one single transfer at the end\n            totalDistributedValue += _harvest(i);\n        }\n\n        emit MassHarvest(msg.sender, epochId - lastEpochIdHarvestedUser, totalDistributedValue);\n\n        if (totalDistributedValue > 0) {\n            _ionx.transferFrom(_communityVault, msg.sender, totalDistributedValue);\n        }\n\n        return totalDistributedValue;\n    }\n    function harvest (uint128 epochId) external whenNotPaused returns (uint){\n        // checks for requested epoch\n        require (_getEpochId() > epochId, \"YLD:E-306\");\n        require(epochId <= NR_OF_EPOCHS, \"YLD:E-408\");\n        require (lastEpochIdHarvested[msg.sender].add(1) == epochId, \"YLD:E-204\");\n        uint userReward = _harvest(epochId);\n        if (userReward > 0) {\n            _ionx.transferFrom(_communityVault, msg.sender, userReward);\n        }\n        emit Harvest(msg.sender, epochId, userReward);\n        return userReward;\n    }\n\n    // views\n    // calls to the staking smart contract to retrieve the epoch total pool size\n    function getPoolSize(uint128 epochId) external view returns (uint) {\n        return _getPoolSize(epochId);\n    }\n\n    function getCurrentEpoch() external view returns (uint) {\n        return _getEpochId();\n    }\n\n    // calls to the staking smart contract to retrieve user balance for an epoch\n    function getEpochStake(address userAddress, uint128 epochId) external view returns (uint) {\n        return _getUserBalancePerEpoch(userAddress, epochId);\n    }\n\n    function getGenesisEpochAmount() external view returns (uint){\n        return _genesisEpochAmount;\n    }\n\n    function getDeprecationPerEpoch() external view returns (uint){\n        return _deprecationPerEpoch;\n    }\n\n    function userLastEpochIdHarvested() external view returns (uint){\n        return lastEpochIdHarvested[msg.sender];\n    }\n\n    // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n    function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n        _withdrawEther(receiver, amount);\n    }\n\n    // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n    function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n        _withdrawERC20(receiver, tokenAddress, amount);\n    }\n\n    // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n    function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n        _withdrawERC721(receiver, tokenAddress, tokenId);\n    }\n\n    // internal methods\n\n    function _initEpoch(uint128 epochId) internal {\n        require(lastInitializedEpoch.add(1) == epochId, \"YLD:E-204\");\n        lastInitializedEpoch = epochId;\n        // call the staking smart contract to init the epoch\n        epochs[epochId] = _getPoolSize(epochId);\n    }\n\n    function _getAmountClaimableAtEpoch(address account, uint128 epochId) internal view returns (uint) {\n        if (epochs[epochId] == 0) { return 0; }\n        return _calcTotalAmountPerEpoch(epochId)\n          .mul(_getUserBalancePerEpoch(account, epochId))\n          .div(epochs[epochId]);\n    }\n\n    function _harvest (uint128 epochId) internal returns (uint) {\n        // try to initialize an epoch. if it can't it fails\n        // if it fails either user either a BarnBridge account will init not init epochs\n        if (lastInitializedEpoch < epochId) {\n            _initEpoch(epochId);\n        }\n        // Set user state for last harvested\n        lastEpochIdHarvested[msg.sender] = epochId;\n        // compute and return user total reward. For optimization reasons the transfer have been moved to an upper layer (i.e. massHarvest needs to do a single transfer)\n\n        // exit if there is no stake on the epoch\n        if (epochs[epochId] == 0) {\n            return 0;\n        }\n        return _calcTotalAmountPerEpoch(epochId)\n          .mul(_getUserBalancePerEpoch(msg.sender, epochId))\n          .div(epochs[epochId]);\n    }\n\n    function _calcTotalAmountPerEpoch(uint256 epochId) internal view returns (uint) {\n      return _genesisEpochAmount.sub(epochId.mul(_deprecationPerEpoch)); // .sub(1) ?\n    }\n\n    function _getPoolSize(uint128 epochId) internal view returns (uint) {\n        // retrieve token token balance\n        return _staking.getEpochPoolSize(_token, _stakingEpochId(epochId));\n    }\n\n    function _getUserBalancePerEpoch(address userAddress, uint128 epochId) internal view returns (uint){\n        // retrieve token token balance per user per epoch\n        return _staking.getEpochUserBalance(userAddress, _token, _stakingEpochId(epochId));\n    }\n\n    // compute epoch id from blocktimestamp and epochstart date\n    function _getEpochId() internal view returns (uint128 epochId) {\n        if (block.timestamp < epochStart) {\n            return 0;\n        }\n        epochId = uint128(block.timestamp.sub(epochStart).div(epochDuration).add(1));\n    }\n\n    // get the staking epoch which is 1 epoch more\n    function _stakingEpochId(uint128 epochId) pure internal returns (uint128) {\n        return epochId + 1;\n    }\n\n    modifier whenNotPaused() {\n        require(_paused != true, \"YLD:E-101\");\n        _;\n    }\n}"
    },
    "contracts/v1/incentives/YieldFarm3.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.11;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../interfaces/IStaking.sol\";\n\ncontract YieldFarm3 is Ownable, BlackholePrevention {\n\n    // lib\n    using SafeMath for uint;\n    using SafeMath for uint128;\n\n    // constants\n    uint public immutable TOTAL_DISTRIBUTED_AMOUNT;\n    uint public immutable NR_OF_EPOCHS;\n\n    // state variables\n\n    // addreses\n    address private immutable _token;\n    address private immutable _communityVault;\n    // contracts\n    IERC20 private immutable _ionx;\n    IStaking private _staking;\n\n\n    uint[] private epochs;\n    uint private immutable _genesisEpochAmount;\n    uint private _deprecationPerEpoch;\n    uint128 public lastInitializedEpoch;\n    bool internal _paused;\n    mapping(address => uint128) public lastEpochIdHarvested;\n    uint public epochDuration; // init from staking contract\n    uint public immutable epochStart; // init from staking contract\n\n    // events\n    event PausedStateSet(bool isPaused);\n    event MassHarvest(address indexed user, uint256 epochsHarvested, uint256 totalValue);\n    event Harvest(address indexed user, uint128 indexed epochId, uint256 amount);\n\n    // constructor\n    constructor(address ionxTokenAddress, address token, address stakeContract, address communityVault, uint genesisEpochAmount, uint deprecationPerEpoch, uint nrOfEpochs) public {\n        _paused = false;\n        _ionx = IERC20(ionxTokenAddress);\n        _token = token;\n        _staking = IStaking(stakeContract);\n        _communityVault = communityVault;\n        epochDuration = _staking.epochDuration();\n        epochStart = _staking.epoch1Start() + epochDuration;\n        _deprecationPerEpoch = deprecationPerEpoch;\n        uint n = nrOfEpochs;\n        uint amountEpochN = genesisEpochAmount.sub(n.sub(1).mul(_deprecationPerEpoch));\n        TOTAL_DISTRIBUTED_AMOUNT = n.mul((genesisEpochAmount.add(amountEpochN)).div(2));\n        NR_OF_EPOCHS = nrOfEpochs;\n        epochs = new uint[](nrOfEpochs + 1);\n        _genesisEpochAmount = genesisEpochAmount;\n\n    }\n\n    function isPaused() external view returns (bool) {\n        return _paused;\n    }\n\n    function getAmountClaimable() external view returns (uint) {\n        uint totalClaimable;\n        uint epochId = _getEpochId().sub(1); // fails in epoch 0\n\n        // force max number of epochs\n        if (epochId > NR_OF_EPOCHS) {\n            epochId = NR_OF_EPOCHS;\n        }\n\n        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\n            totalClaimable += _getAmountClaimableAtEpoch(msg.sender, i);\n        }\n\n        return totalClaimable;\n    }\n\n    // public method to harvest all the unharvested epochs until current epoch - 1\n    function massHarvest() external whenNotPaused returns (uint){\n        uint totalDistributedValue;\n        uint epochId = _getEpochId().sub(1); // fails in epoch 0\n        uint lastEpochIdHarvestedUser = lastEpochIdHarvested[msg.sender];\n\n        // force max number of epochs\n        if (epochId > NR_OF_EPOCHS) {\n            epochId = NR_OF_EPOCHS;\n        }\n\n        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\n            // i = epochId\n            // compute distributed Value and do one single transfer at the end\n            totalDistributedValue += _harvest(i);\n        }\n\n        emit MassHarvest(msg.sender, epochId - lastEpochIdHarvestedUser, totalDistributedValue);\n\n        if (totalDistributedValue > 0) {\n            _ionx.transferFrom(_communityVault, msg.sender, totalDistributedValue);\n        }\n\n        return totalDistributedValue;\n    }\n    function harvest (uint128 epochId) external whenNotPaused returns (uint){\n        // checks for requested epoch\n        require (_getEpochId() > epochId, \"YLD:E-306\");\n        require(epochId <= NR_OF_EPOCHS, \"YLD:E-408\");\n        require (lastEpochIdHarvested[msg.sender].add(1) == epochId, \"YLD:E-204\");\n        uint userReward = _harvest(epochId);\n        if (userReward > 0) {\n            _ionx.transferFrom(_communityVault, msg.sender, userReward);\n        }\n        emit Harvest(msg.sender, epochId, userReward);\n        return userReward;\n    }\n\n    // views\n    // calls to the staking smart contract to retrieve the epoch total pool size\n    function getPoolSize(uint128 epochId) external view returns (uint) {\n        return _getPoolSize(epochId);\n    }\n\n    function getCurrentEpoch() external view returns (uint) {\n        return _getEpochId();\n    }\n\n    // calls to the staking smart contract to retrieve user balance for an epoch\n    function getEpochStake(address userAddress, uint128 epochId) external view returns (uint) {\n        return _getUserBalancePerEpoch(userAddress, epochId);\n    }\n\n    function getGenesisEpochAmount() external view returns (uint){\n        return _genesisEpochAmount;\n    }\n\n    function getDeprecationPerEpoch() external view returns (uint){\n        return _deprecationPerEpoch;\n    }\n\n    function userLastEpochIdHarvested() external view returns (uint){\n        return lastEpochIdHarvested[msg.sender];\n    }\n\n    // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n    function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n        _withdrawEther(receiver, amount);\n    }\n\n    // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n    function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n        _withdrawERC20(receiver, tokenAddress, amount);\n    }\n\n    // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n    function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n        _withdrawERC721(receiver, tokenAddress, tokenId);\n    }\n\n    // internal methods\n\n    function _initEpoch(uint128 epochId) internal {\n        require(lastInitializedEpoch.add(1) == epochId, \"YLD:E-204\");\n        lastInitializedEpoch = epochId;\n        // call the staking smart contract to init the epoch\n        epochs[epochId] = _getPoolSize(epochId);\n    }\n\n    function _getAmountClaimableAtEpoch(address account, uint128 epochId) internal view returns (uint) {\n        if (epochs[epochId] == 0) { return 0; }\n        return _calcTotalAmountPerEpoch(epochId)\n          .mul(_getUserBalancePerEpoch(account, epochId))\n          .div(epochs[epochId]);\n    }\n\n    function _harvest (uint128 epochId) internal returns (uint) {\n        // try to initialize an epoch. if it can't it fails\n        // if it fails either user either a BarnBridge account will init not init epochs\n        if (lastInitializedEpoch < epochId) {\n            _initEpoch(epochId);\n        }\n        // Set user state for last harvested\n        lastEpochIdHarvested[msg.sender] = epochId;\n        // compute and return user total reward. For optimization reasons the transfer have been moved to an upper layer (i.e. massHarvest needs to do a single transfer)\n\n        // exit if there is no stake on the epoch\n        if (epochs[epochId] == 0) {\n            return 0;\n        }\n        return _calcTotalAmountPerEpoch(epochId)\n          .mul(_getUserBalancePerEpoch(msg.sender, epochId))\n          .div(epochs[epochId]);\n    }\n\n    function _calcTotalAmountPerEpoch(uint256 epochId) internal view returns (uint) {\n      return _genesisEpochAmount.sub(epochId.mul(_deprecationPerEpoch)); // .sub(1) ?\n    }\n\n    function _getPoolSize(uint128 epochId) internal view returns (uint) {\n        // retrieve token token balance\n        return _staking.getEpochPoolSize(_token, _stakingEpochId(epochId));\n    }\n\n    function _getUserBalancePerEpoch(address userAddress, uint128 epochId) internal view returns (uint){\n        // retrieve token token balance per user per epoch\n        return _staking.getEpochUserBalance(userAddress, _token, _stakingEpochId(epochId));\n    }\n\n    // compute epoch id from blocktimestamp and epochstart date\n    function _getEpochId() internal view returns (uint128 epochId) {\n        if (block.timestamp < epochStart) {\n            return 0;\n        }\n        epochId = uint128(block.timestamp.sub(epochStart).div(epochDuration).add(1));\n    }\n\n    // get the staking epoch which is 1 epoch more\n    function _stakingEpochId(uint128 epochId) pure internal returns (uint128) {\n        return epochId + 1;\n    }\n\n    modifier whenNotPaused() {\n        require(_paused != true, \"YLD:E-101\");\n        _;\n    }\n}"
    },
    "contracts/v1/interfaces/IAaveBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IAaveBridge.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n\ninterface IAaveBridge {\n  function getReserveInterestToken(address assetToken) external view returns (address aTokenAddress);\n  function isReserveActive(address assetToken) external view returns (bool);\n\n  function getTotalBalance(address account, address assetToken) external view returns (uint256);\n  function deposit(address assetToken, uint256 assetAmount, uint256 referralCode) external returns (uint256);\n  function withdraw(address receiver, address assetToken, uint256 assetAmount) external;\n}\n"
    },
    "contracts/v1/interfaces/IBaseProton.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Proton.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../lib/RelayRecipient.sol\";\n\n\ninterface IBaseProton is IERC721 {\n  event PausedStateSet(bool isPaused);\n  event SalePriceSet(uint256 indexed tokenId, uint256 salePrice);\n  event CreatorRoyaltiesSet(uint256 indexed tokenId, uint256 royaltiesPct);\n  event FeesWithdrawn(address indexed receiver, uint256 amount);\n  event ProtonSold(uint256 indexed tokenId, address indexed oldOwner, address indexed newOwner, uint256 salePrice, address creator, uint256 creatorRoyalties);\n  event RoyaltiesClaimed(address indexed receiver, uint256 amountClaimed);\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function creatorOf(uint256 tokenId) external view returns (address);\n  function getSalePrice(uint256 tokenId) external view returns (uint256);\n  function getLastSellPrice(uint256 tokenId) external view returns (uint256);\n  function getCreatorRoyalties(address account) external view returns (uint256);\n  function getCreatorRoyaltiesPct(uint256 tokenId) external view returns (uint256);\n  function getCreatorRoyaltiesReceiver(uint256 tokenId) external view returns (address);\n\n  function buyProton(uint256 tokenId, uint256 gasLimit) external payable returns (bool);\n  function claimCreatorRoyalties() external returns (uint256);\n\n  function createProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri\n  ) external returns (uint256 newTokenId);\n\n  function createProtons(\n    address creator,\n    address receiver,\n    string[] calldata tokenMetaUris\n  ) external returns (bool);\n\n  function createProtonsForSale(\n    address creator,\n    address receiver,\n    uint256 royaltiesPercent,\n    string[] calldata tokenMetaUris,\n    uint256[] calldata salePrices\n  ) external returns (bool);\n\n  /***********************************|\n  |     Only Token Creator/Owner      |\n  |__________________________________*/\n\n  function setSalePrice(uint256 tokenId, uint256 salePrice) external;\n  function setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct) external;\n  function setCreatorRoyaltiesReceiver(uint256 tokenId, address receiver) external;\n}"
    },
    "contracts/v1/interfaces/IBasketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IBasketManager.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Particle Basket Manager interface\n * @dev The basket-manager for underlying assets attached to Charged Particles\n * @dev Manages the link between NFTs and their respective Smart-Baskets\n */\ninterface IBasketManager {\n\n  event ControllerSet(address indexed controller);\n  event ExecutorSet(address indexed executor);\n  event PausedStateSet(bool isPaused);\n  event NewSmartBasket(address indexed contractAddress, uint256 indexed tokenId, address indexed smartBasket);\n  event BasketAdd(address indexed contractAddress, uint256 indexed tokenId, address basketTokenAddress, uint256 basketTokenId, uint256 basketTokenAmount);\n  event BasketRemove(address indexed receiver, address indexed contractAddress, uint256 indexed tokenId, address basketTokenAddress, uint256 basketTokenId, uint256 basketTokenAmount);\n  event BasketRewarded(address indexed contractAddress, uint256 indexed tokenId, address indexed receiver, address rewardsToken, uint256 rewardsAmount);\n  event RewardProgramSet(address indexed rewardProgram);\n\n  function isPaused() external view returns (bool);\n\n  function getTokenTotalCount(address contractAddress, uint256 tokenId) external view returns (uint256);\n  function getTokenCountByType(address contractAddress, uint256 tokenId, address basketTokenAddress, uint256 basketTokenId) external returns (uint256);\n\n  function prepareTransferAmount(uint256 nftTokenAmount) external;\n  function addToBasket(address contractAddress, uint256 tokenId, address basketTokenAddress, uint256 basketTokenId) external returns (bool);\n  function removeFromBasket(address receiver, address contractAddress, uint256 tokenId, address basketTokenAddress, uint256 basketTokenId) external returns (bool);\n  function withdrawRewards(address receiver, address contractAddress, uint256 tokenId, address rewardsToken, uint256 rewardsAmount) external returns (uint256 amount);\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\n  function getBasketAddressById(address contractAddress, uint256 tokenId) external returns (address);\n\n  function withdrawEther(address contractAddress, uint256 tokenId, address payable receiver, uint256 amount) external;\n  function withdrawERC20(address contractAddress, uint256 tokenId, address payable receiver, address tokenAddress, uint256 amount) external;\n  function withdrawERC721(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId) external;\n  function withdrawERC1155(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId, uint256 amount) external;\n}\n"
    },
    "contracts/v1/interfaces/IChargedManagers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IChargedSettings.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"./IWalletManager.sol\";\nimport \"./IBasketManager.sol\";\n\n/**\n * @notice Interface for Charged Wallet-Managers\n */\ninterface IChargedManagers {\n\n  /***********************************|\n  |             Public API            |\n  |__________________________________*/\n\n  function isContractOwner(address contractAddress, address account) external view returns (bool);\n\n  // ERC20\n  function isWalletManagerEnabled(string calldata walletManagerId) external view returns (bool);\n  function getWalletManager(string calldata walletManagerId) external view returns (IWalletManager);\n\n  // ERC721\n  function isNftBasketEnabled(string calldata basketId) external view returns (bool);\n  function getBasketManager(string calldata basketId) external view returns (IBasketManager);\n\n  // Validation\n  function validateDeposit(\n    address sender,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  ) external;\n  function validateNftDeposit(\n    address sender,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  ) external;\n  function validateDischarge(address sender, address contractAddress, uint256 tokenId) external;\n  function validateRelease(address sender, address contractAddress, uint256 tokenId) external;\n  function validateBreakBond(address sender, address contractAddress, uint256 tokenId) external;\n\n  /***********************************|\n  |          Particle Events          |\n  |__________________________________*/\n\n  event Initialized(address indexed initiator);\n  event ControllerSet(address indexed controllerAddress, string controllerId);\n  event WalletManagerRegistered(string indexed walletManagerId, address indexed walletManager);\n  event BasketManagerRegistered(string indexed basketId, address indexed basketManager);\n}\n"
    },
    "contracts/v1/interfaces/IChargedParticles.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IChargedParticles.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @notice Interface for Charged Particles\n */\ninterface IChargedParticles {\n\n  /***********************************|\n  |             Public API            |\n  |__________________________________*/\n\n  function getStateAddress() external view returns (address stateAddress);\n  function getSettingsAddress() external view returns (address settingsAddress);\n  function getManagersAddress() external view returns (address managersAddress);\n\n  function getFeesForDeposit(uint256 assetAmount) external view returns (uint256 protocolFee);\n  function baseParticleMass(address contractAddress, uint256 tokenId, string calldata walletManagerId, address assetToken) external returns (uint256);\n  function currentParticleCharge(address contractAddress, uint256 tokenId, string calldata walletManagerId, address assetToken) external returns (uint256);\n  function currentParticleKinetics(address contractAddress, uint256 tokenId, string calldata walletManagerId, address assetToken) external returns (uint256);\n  function currentParticleCovalentBonds(address contractAddress, uint256 tokenId, string calldata basketManagerId) external view returns (uint256);\n\n  /***********************************|\n  |        Particle Mechanics         |\n  |__________________________________*/\n\n  function energizeParticle(\n      address contractAddress,\n      uint256 tokenId,\n      string calldata walletManagerId,\n      address assetToken,\n      uint256 assetAmount,\n      address referrer\n  ) external returns (uint256 yieldTokensAmount);\n\n  function dischargeParticle(\n      address receiver,\n      address contractAddress,\n      uint256 tokenId,\n      string calldata walletManagerId,\n      address assetToken\n  ) external returns (uint256 creatorAmount, uint256 receiverAmount);\n\n  function dischargeParticleAmount(\n      address receiver,\n      address contractAddress,\n      uint256 tokenId,\n      string calldata walletManagerId,\n      address assetToken,\n      uint256 assetAmount\n  ) external returns (uint256 creatorAmount, uint256 receiverAmount);\n\n  function dischargeParticleForCreator(\n      address receiver,\n      address contractAddress,\n      uint256 tokenId,\n      string calldata walletManagerId,\n      address assetToken,\n      uint256 assetAmount\n  ) external returns (uint256 receiverAmount);\n\n  function releaseParticle(\n      address receiver,\n      address contractAddress,\n      uint256 tokenId,\n      string calldata walletManagerId,\n      address assetToken\n  ) external returns (uint256 creatorAmount, uint256 receiverAmount);\n\n  function releaseParticleAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  ) external returns (uint256 creatorAmount, uint256 receiverAmount);\n\n  function covalentBond(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  ) external returns (bool success);\n\n  function breakCovalentBond(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  ) external returns (bool success);\n\n  /***********************************|\n  |          Particle Events          |\n  |__________________________________*/\n\n  event Initialized(address indexed initiator);\n  event ControllerSet(address indexed controllerAddress, string controllerId);\n  event DepositFeeSet(uint256 depositFee);\n  event ProtocolFeesCollected(address indexed assetToken, uint256 depositAmount, uint256 feesCollected);\n}\n"
    },
    "contracts/v1/interfaces/IChargedSettings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IChargedSettings.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"./IWalletManager.sol\";\nimport \"./IBasketManager.sol\";\n\n/**\n * @notice Interface for Charged Settings\n */\ninterface IChargedSettings {\n\n  /***********************************|\n  |             Public API            |\n  |__________________________________*/\n\n  // function isContractOwner(address contractAddress, address account) external view returns (bool);\n  function getCreatorAnnuities(address contractAddress, uint256 tokenId) external returns (address creator, uint256 annuityPct);\n  function getCreatorAnnuitiesRedirect(address contractAddress, uint256 tokenId) external view returns (address);\n  function getTempLockExpiryBlocks() external view returns (uint256);\n  function getTimelockApprovals(address operator) external view returns (bool timelockAny, bool timelockOwn);\n  function getAssetRequirements(\n    address contractAddress,\n    address assetToken\n  ) external view returns (\n    string memory requiredWalletManager,\n    bool energizeEnabled,\n    bool restrictedAssets,\n    bool validAsset,\n    uint256 depositCap,\n    uint256 depositMin,\n    uint256 depositMax,\n    bool invalidAsset\n  );\n  function getNftAssetRequirements(\n    address contractAddress,\n    address nftTokenAddress\n  ) external view returns (\n    string memory requiredBasketManager,\n    bool basketEnabled,\n    uint256 maxNfts\n  );\n\n  /***********************************|\n  |         Only NFT Creator          |\n  |__________________________________*/\n\n  function setCreatorAnnuities(address contractAddress, uint256 tokenId, address creator, uint256 annuityPercent) external;\n  function setCreatorAnnuitiesRedirect(address contractAddress, uint256 tokenId, address receiver) external;\n\n\n  /***********************************|\n  |      Only NFT Contract Owner      |\n  |__________________________________*/\n\n  function setRequiredWalletManager(address contractAddress, string calldata walletManager) external;\n  function setRequiredBasketManager(address contractAddress, string calldata basketManager) external;\n  function setAssetTokenRestrictions(address contractAddress, bool restrictionsEnabled) external;\n  function setAllowedAssetToken(address contractAddress, address assetToken, bool isAllowed) external;\n  function setAssetTokenLimits(address contractAddress, address assetToken, uint256 depositMin, uint256 depositMax) external;\n  function setMaxNfts(address contractAddress, address nftTokenAddress, uint256 maxNfts) external;\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function setAssetInvalidity(address assetToken, bool invalidity) external;\n  function enableNftContracts(address[] calldata contracts) external;\n  function setPermsForCharge(address contractAddress, bool state) external;\n  function setPermsForBasket(address contractAddress, bool state) external;\n  function setPermsForTimelockAny(address contractAddress, bool state) external;\n  function setPermsForTimelockSelf(address contractAddress, bool state) external;\n\n  /***********************************|\n  |          Particle Events          |\n  |__________________________________*/\n\n  event Initialized(address indexed initiator);\n  event ControllerSet(address indexed controllerAddress, string controllerId);\n  event DepositCapSet(address assetToken, uint256 depositCap);\n  event TempLockExpirySet(uint256 expiryBlocks);\n\n  event RequiredWalletManagerSet(address indexed contractAddress, string walletManager);\n  event RequiredBasketManagerSet(address indexed contractAddress, string basketManager);\n  event AssetTokenRestrictionsSet(address indexed contractAddress, bool restrictionsEnabled);\n  event AllowedAssetTokenSet(address indexed contractAddress, address assetToken, bool isAllowed);\n  event AssetTokenLimitsSet(address indexed contractAddress, address assetToken, uint256 assetDepositMin, uint256 assetDepositMax);\n  event MaxNftsSet(address indexed contractAddress, address indexed nftTokenAddress, uint256 maxNfts);\n  event AssetInvaliditySet(address indexed assetToken, bool invalidity);\n\n  event TokenCreatorConfigsSet(address indexed contractAddress, uint256 indexed tokenId, address indexed creatorAddress, uint256 annuityPercent);\n  event TokenCreatorAnnuitiesRedirected(address indexed contractAddress, uint256 indexed tokenId, address indexed redirectAddress);\n\n  event PermsSetForCharge(address indexed contractAddress, bool state);\n  event PermsSetForBasket(address indexed contractAddress, bool state);\n  event PermsSetForTimelockAny(address indexed contractAddress, bool state);\n  event PermsSetForTimelockSelf(address indexed contractAddress, bool state);\n}\n"
    },
    "contracts/v1/interfaces/IChargedState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IChargedSettings.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"./IChargedSettings.sol\";\n\n/**\n * @notice Interface for Charged State\n */\ninterface IChargedState {\n\n  /***********************************|\n  |             Public API            |\n  |__________________________________*/\n\n  function getDischargeTimelockExpiry(address contractAddress, uint256 tokenId) external view returns (uint256 lockExpiry);\n  function getReleaseTimelockExpiry(address contractAddress, uint256 tokenId) external view returns (uint256 lockExpiry);\n  function getBreakBondTimelockExpiry(address contractAddress, uint256 tokenId) external view returns (uint256 lockExpiry);\n\n  function isApprovedForDischarge(address contractAddress, uint256 tokenId, address operator) external returns (bool);\n  function isApprovedForRelease(address contractAddress, uint256 tokenId, address operator) external returns (bool);\n  function isApprovedForBreakBond(address contractAddress, uint256 tokenId, address operator) external returns (bool);\n  function isApprovedForTimelock(address contractAddress, uint256 tokenId, address operator) external returns (bool);\n\n  function isEnergizeRestricted(address contractAddress, uint256 tokenId) external view returns (bool);\n  function isCovalentBondRestricted(address contractAddress, uint256 tokenId) external view returns (bool);\n\n  function getDischargeState(address contractAddress, uint256 tokenId, address sender) external\n    returns (bool allowFromAll, bool isApproved, uint256 timelock, uint256 tempLockExpiry);\n  function getReleaseState(address contractAddress, uint256 tokenId, address sender) external\n    returns (bool allowFromAll, bool isApproved, uint256 timelock, uint256 tempLockExpiry);\n  function getBreakBondState(address contractAddress, uint256 tokenId, address sender) external\n    returns (bool allowFromAll, bool isApproved, uint256 timelock, uint256 tempLockExpiry);\n\n  /***********************************|\n  |      Only NFT Owner/Operator      |\n  |__________________________________*/\n\n  function setDischargeApproval(address contractAddress, uint256 tokenId, address operator) external;\n  function setReleaseApproval(address contractAddress, uint256 tokenId, address operator) external;\n  function setBreakBondApproval(address contractAddress, uint256 tokenId, address operator) external;\n  function setTimelockApproval(address contractAddress, uint256 tokenId, address operator) external;\n  function setApprovalForAll(address contractAddress, uint256 tokenId, address operator) external;\n\n  function setPermsForRestrictCharge(address contractAddress, uint256 tokenId, bool state) external;\n  function setPermsForAllowDischarge(address contractAddress, uint256 tokenId, bool state) external;\n  function setPermsForAllowRelease(address contractAddress, uint256 tokenId, bool state) external;\n  function setPermsForRestrictBond(address contractAddress, uint256 tokenId, bool state) external;\n  function setPermsForAllowBreakBond(address contractAddress, uint256 tokenId, bool state) external;\n\n  function setDischargeTimelock(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 unlockBlock\n  ) external;\n\n  function setReleaseTimelock(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 unlockBlock\n  ) external;\n\n  function setBreakBondTimelock(\n    address contractAddress,\n    uint256 tokenId,\n    uint256 unlockBlock\n  ) external;\n\n  /***********************************|\n  |         Only NFT Contract         |\n  |__________________________________*/\n\n  function setTemporaryLock(\n    address contractAddress,\n    uint256 tokenId,\n    bool isLocked\n  ) external;\n\n  /***********************************|\n  |          Particle Events          |\n  |__________________________________*/\n\n  event Initialized(address indexed initiator);\n  event ControllerSet(address indexed controllerAddress, string controllerId);\n\n  event DischargeApproval(address indexed contractAddress, uint256 indexed tokenId, address indexed owner, address operator);\n  event ReleaseApproval(address indexed contractAddress, uint256 indexed tokenId, address indexed owner, address operator);\n  event BreakBondApproval(address indexed contractAddress, uint256 indexed tokenId, address indexed owner, address operator);\n  event TimelockApproval(address indexed contractAddress, uint256 indexed tokenId, address indexed owner, address operator);\n\n  event TokenDischargeTimelock(address indexed contractAddress, uint256 indexed tokenId, address indexed operator, uint256 unlockBlock);\n  event TokenReleaseTimelock(address indexed contractAddress, uint256 indexed tokenId, address indexed operator, uint256 unlockBlock);\n  event TokenBreakBondTimelock(address indexed contractAddress, uint256 indexed tokenId, address indexed operator, uint256 unlockBlock);\n  event TokenTempLock(address indexed contractAddress, uint256 indexed tokenId, uint256 unlockBlock);\n\n  event PermsSetForRestrictCharge(address indexed contractAddress, uint256 indexed tokenId, bool state);\n  event PermsSetForAllowDischarge(address indexed contractAddress, uint256 indexed tokenId, bool state);\n  event PermsSetForAllowRelease(address indexed contractAddress, uint256 indexed tokenId, bool state);\n  event PermsSetForRestrictBond(address indexed contractAddress, uint256 indexed tokenId, bool state);\n  event PermsSetForAllowBreakBond(address indexed contractAddress, uint256 indexed tokenId, bool state);\n}\n"
    },
    "contracts/v1/interfaces/IDai.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IDai is IERC20Upgradeable {\n    // --- Approve by signature ---\n  function permit(address holder, address spender, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\n  function transferFrom(address src, address dst, uint wad) external override returns (bool);\n}"
    },
    "contracts/v1/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Detailed {\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/v1/interfaces/IERC721Chargeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IERC721Chargeable.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\";\n\ninterface IERC721Chargeable is IERC165Upgradeable {\n    function owner() external view returns (address);\n    function creatorOf(uint256 tokenId) external view returns (address);\n    function balanceOf(address tokenOwner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address tokenOwner);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address tokenOwner, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "contracts/v1/interfaces/ILepton.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ILepton.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Charged Particles Lepton Interface\n * @dev ...\n */\ninterface ILepton {\n\n  struct Classification {\n    string tokenUri;\n    uint256 price;\n    uint128 _upperBounds;\n    uint32 supply;\n    uint32 multiplier;\n    uint32 bonus;\n  }\n\n  function mintLepton() external payable returns (uint256 newTokenId);\n  function batchMintLepton(uint256 count) external payable;\n  function getNextType() external view returns (uint256);\n  function getNextPrice() external view returns (uint256);\n  function getMultiplier(uint256 tokenId) external view returns (uint256);\n  function getBonus(uint256 tokenId) external view returns (uint256);\n\n\n  event MaxMintPerTxSet(uint256 maxAmount);\n  event LeptonTypeAdded(string tokenUri, uint256 price, uint32 supply, uint32 multiplier, uint32 bonus, uint256 upperBounds);\n  event LeptonTypeUpdated(uint256 leptonIndex, string tokenUri, uint256 price, uint32 supply, uint32 multiplier, uint32 bonus, uint256 upperBounds);\n  event LeptonMinted(address indexed receiver, uint256 indexed tokenId, uint256 price, uint32 multiplier);\n  event LeptonBatchMinted(address indexed receiver, uint256 indexed tokenId, uint256 count, uint256 price, uint32 multiplier);\n  event PausedStateSet(bool isPaused);\n}\n"
    },
    "contracts/v1/interfaces/IMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.6.0;\n\n// Allows anyone to claim a token if they exist in a merkle root.\ninterface IMerkleDistributor {\n    // Returns the address of the token distributed by this contract.\n    function token() external view returns (address);\n    // Returns the merkle root of the merkle tree containing account balances available to claim.\n    function merkleRoot() external view returns (bytes32);\n    // Returns true if the index has been marked claimed.\n    function isClaimed(uint256 index) external view returns (bool);\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external;\n\n    // This event is triggered whenever a call to #claim succeeds.\n    event Claimed(uint256 index, address account, uint256 amount);\n}"
    },
    "contracts/v1/interfaces/IParticleSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IParticleSplitter.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @notice Interface for Particle Splitter\n */\ninterface IParticleSplitter {\n\n  /***********************************|\n  |             Public API            |\n  |__________________________________*/\n\n  function executeForWallet(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address externalAddress,\n    bytes memory encodedParams\n  ) external payable returns (bytes memory);\n\n  function executeForBasket(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address externalAddress,\n    bytes memory encodedParams\n  ) external payable returns (bytes memory);\n\n  function withdrawWalletRewards(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address rewardsToken,\n    uint256 rewardsAmount\n  ) external returns (uint256 amountWithdrawn);\n\n  function withdrawBasketRewards(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address rewardsToken,\n    uint256 rewardsAmount\n  ) external returns (uint256 amountWithdrawn);\n\n  function refreshWalletPrincipal(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  ) external;\n\n\n  /***********************************|\n  |          Particle Events          |\n  |__________________________________*/\n\n  event ChargedManagersSet(address indexed chargedManagers);\n  event TokenInfoProxySet(address indexed tokenInfoProxy);\n\n  event ExecuteForWallet(\n    address indexed contractAddress,\n    uint256 tokenId,\n    string walletManagerId,\n    address indexed externalAddress,\n    bytes encodedParams,\n    uint256 ethValue\n  );\n  event ExecuteForBasket(\n    address indexed contractAddress,\n    uint256 tokenId,\n    string basketManagerId,\n    address indexed externalAddress,\n    bytes encodedParams,\n    uint256 ethValue\n  );\n  event PrincipalRefreshed(\n    address contractAddress,\n    uint256 tokenId,\n    string walletManagerId,\n    address assetToken\n  );\n  event PermsSetForExternal(\n    address indexed contractAddress,\n    bool state\n  );\n}\n"
    },
    "contracts/v1/interfaces/IProton.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Proton.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/IUniverse.sol\";\nimport \"../interfaces/IChargedState.sol\";\nimport \"../interfaces/IChargedSettings.sol\";\nimport \"../interfaces/IChargedParticles.sol\";\n\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../lib/RelayRecipient.sol\";\n\n\ninterface IProton is IERC721 {\n  event UniverseSet(address indexed universe);\n  event ChargedStateSet(address indexed chargedState);\n  event ChargedSettingsSet(address indexed chargedSettings);\n  event ChargedParticlesSet(address indexed chargedParticles);\n  event PausedStateSet(bool isPaused);\n  event SalePriceSet(uint256 indexed tokenId, uint256 salePrice);\n  event CreatorRoyaltiesSet(uint256 indexed tokenId, uint256 royaltiesPct);\n  event FeesWithdrawn(address indexed receiver, uint256 amount);\n  event ProtonSold(uint256 indexed tokenId, address indexed oldOwner, address indexed newOwner, uint256 salePrice, address creator, uint256 creatorRoyalties);\n  event RoyaltiesClaimed(address indexed receiver, uint256 amountClaimed);\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function creatorOf(uint256 tokenId) external view returns (address);\n  function getSalePrice(uint256 tokenId) external view returns (uint256);\n  function getLastSellPrice(uint256 tokenId) external view returns (uint256);\n  function getCreatorRoyalties(address account) external view returns (uint256);\n  function getCreatorRoyaltiesPct(uint256 tokenId) external view returns (uint256);\n  function getCreatorRoyaltiesReceiver(uint256 tokenId) external view returns (address);\n\n  function buyProton(uint256 tokenId) external payable returns (bool);\n  function claimCreatorRoyalties() external returns (uint256);\n\n  function createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  ) external returns (uint256 newTokenId);\n\n  function createBasicProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri\n  ) external returns (uint256 newTokenId);\n\n  function createProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent\n  ) external returns (uint256 newTokenId);\n\n  function createProtonForSale(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    uint256 salePrice\n  ) external returns (uint256 newTokenId);\n\n  function batchProtonsForSale(\n    address creator,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    string[] calldata tokenMetaUris,\n    uint256[] calldata salePrices\n  ) external;\n\n  /***********************************|\n  |     Only Token Creator/Owner      |\n  |__________________________________*/\n\n  function setSalePrice(uint256 tokenId, uint256 salePrice) external;\n  function setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct) external;\n  function setCreatorRoyaltiesReceiver(uint256 tokenId, address receiver) external;\n}"
    },
    "contracts/v1/interfaces/IProtonB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Proton.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/IUniverse.sol\";\nimport \"../interfaces/IChargedState.sol\";\nimport \"../interfaces/IChargedSettings.sol\";\nimport \"../interfaces/IChargedParticles.sol\";\n\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../lib/RelayRecipient.sol\";\n\n\ninterface IProtonB is IERC721 {\n  event UniverseSet(address indexed universe);\n  event ChargedStateSet(address indexed chargedState);\n  event ChargedSettingsSet(address indexed chargedSettings);\n  event ChargedParticlesSet(address indexed chargedParticles);\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function createProtonForSale(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    uint256 salePrice\n  ) external returns (uint256 newTokenId);\n\n  function createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  ) external returns (uint256 newTokenId);\n}"
    },
    "contracts/v1/interfaces/IRewardNft.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IRewardNft.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2023 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Charged Particles Reward-NFT Interface\n * @dev ...\n */\ninterface IRewardNft {\n  function getMultiplier(uint256 tokenId) external view returns (uint256);\n  function getBonus(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "contracts/v1/interfaces/IRewardProgram.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IRewardProgram.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2023 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface IRewardProgram {\n  /* admin events */\n  event RewardProgramFunded(uint256 amount);\n  event RewardProgramOutOfFunds();\n\n  /* user events */\n  event RewardsClaimed(address indexed contractAddress, uint256 tokenId, address indexed receiver, uint256 rewarded, uint256 remaining);\n\n  event AssetRegistered(address indexed contractAddress, uint256 tokenId, string walletManagerId, uint256 principalAmount);\n  event AssetDeposit(address indexed contractAddress, uint256 tokenId, string walletManagerId, uint256 principalAmount);\n  event AssetRelease(address indexed contractAddress, uint256 tokenId, uint256 interestAmount);\n\n  /* data types */\n  struct ProgramRewardData {\n    address stakingToken;\n    address rewardToken;\n    uint256 baseMultiplier; // Basis Points\n  }\n\n  struct AssetStake {\n    uint256 start;\n    uint256 claimableRewards;\n    string walletManagerId;\n  }\n\n  function initialize(address stakingToken, address rewardToken, uint256 baseMultiplier, address chargedManagers, address universe, address owner) external;\n\n  /* user functions */\n  function getProgramData() external view returns (ProgramRewardData memory programData);\n  function getAssetStake(uint256 uuid) external view returns (AssetStake memory);\n  function getFundBalance() external view returns (uint256);\n  function calculateRewardsEarned(uint256 parentNftUuid, uint256 interestAmount) external view returns (uint256);\n  function getClaimableRewards(address contractAddress, uint256 tokenId) external view returns (uint256);\n\n  function registerExistingDeposits(address contractAddress, uint256 tokenId, string calldata walletManagerId) external;\n  function registerAssetDeposit(address contractAddress, uint256 tokenId, string calldata walletManagerId, uint256 principalAmount) external;\n  function registerAssetRelease(address contractAddress, uint256 tokenId, uint256 interestAmount) external returns (uint256 rewards);\n}"
    },
    "contracts/v1/interfaces/ISmartBasket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ISmartBasket.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Charged Particles Smart Basket\n * @dev Manages holding and transferring NFTs within an NFT (if any),\n */\ninterface ISmartBasket {\n  function getTokenCountByType(address contractAddress, uint256 tokenId) external view returns (uint256);\n\n  function addToBasket(address contractAddress, uint256 tokenId) external returns (bool);\n  function removeFromBasket(address receiver, address contractAddress, uint256 tokenId) external returns (bool);\n  function executeForAccount(address contractAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\n\n  function withdrawEther(address payable receiver, uint256 amount) external;\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external;\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external;\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external;\n}\n"
    },
    "contracts/v1/interfaces/ISmartBasketB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ISmartBasketB.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Charged Particles Smart Basket \"B\"\n * @dev Manages holding and transferring NFTs within an NFT (if any),\n */\ninterface ISmartBasketB {\n  function getNestedNftCount() external view returns (uint256);\n  function getTokenCountByType(address contractAddress, uint256 tokenId) external view returns (uint256);\n\n  function addToBasket(address contractAddress, uint256 tokenId, uint256 nftTokenAmount) external returns (bool);\n  function removeFromBasket(address receiver, address contractAddress, uint256 tokenId, uint256 nftTokenAmount) external returns (bool);\n  function withdrawRewards(address receiver, address rewardsToken, uint256 rewardsAmount) external returns (uint256);\n  function executeForAccount(address contractAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\n\n  function withdrawEther(address payable receiver, uint256 amount) external;\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external;\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external;\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external;\n}\n"
    },
    "contracts/v1/interfaces/ISmartWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ISmartWallet.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Charged Particles Smart Wallet\n * @dev Manages holding and transferring assets of an NFT to a specific LP for Yield (if any),\n */\ninterface ISmartWallet {\n  function getAssetTokenCount() external view returns (uint256);\n  function getAssetTokenByIndex(uint256 index) external view returns (address);\n\n  function setNftCreator(address creator, uint256 annuityPct) external;\n\n  function isReserveActive(address assetToken) external view returns (bool);\n  function getReserveInterestToken(address assetToken) external view returns (address);\n\n  function getPrincipal(address assetToken) external returns (uint256);\n  function getInterest(address assetToken) external returns (uint256 creatorInterest, uint256 ownerInterest);\n  function getTotal(address assetToken) external returns (uint256);\n  function getRewards(address assetToken) external returns (uint256);\n\n  function deposit(address assetToken, uint256 assetAmount, uint256 referralCode) external returns (uint256);\n  function withdraw(address receiver, address creatorRedirect, address assetToken) external returns (uint256 creatorAmount, uint256 receiverAmount);\n  function withdrawAmount(address receiver, address creatorRedirect, address assetToken, uint256 assetAmount) external returns (uint256 creatorAmount, uint256 receiverAmount);\n  function withdrawAmountForCreator(address receiver, address assetToken, uint256 assetAmount) external returns (uint256 receiverAmount);\n  function withdrawRewards(address receiver, address rewardsToken, uint256 rewardsAmount) external returns (uint256);\n  function executeForAccount(address contractAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\n  function refreshPrincipal(address assetToken) external;\n\n  function withdrawEther(address payable receiver, uint256 amount) external;\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external;\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external;\n}\n"
    },
    "contracts/v1/interfaces/ISmartWalletB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ISmartWallet.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Charged Particles Smart Wallet\n * @dev Manages holding and transferring assets of an NFT to a specific LP for Yield (if any),\n */\ninterface ISmartWalletB {\n  function getAssetTokenCount() external view returns (uint256);\n  function getAssetTokenByIndex(uint256 index) external view returns (address);\n\n  function isReserveActive(address assetToken) external view returns (bool);\n  function getReserveInterestToken(address assetToken) external view returns (address);\n\n  function getPrincipal(address assetToken) external returns (uint256);\n  function getInterest(address assetToken, uint256 creatorPct) external returns (uint256 creatorInterest, uint256 ownerInterest);\n  function getTotal(address assetToken) external returns (uint256);\n  function getRewards(address assetToken) external returns (uint256);\n\n  function deposit(address assetToken, uint256 assetAmount, uint256 referralCode) external returns (uint256);\n  function withdraw(\n    address receiver,\n    address creator,\n    uint256 creatorPct,\n    address assetToken\n  ) external returns (\n    uint256 creatorAmount,\n    uint256 receiverAmount\n  );\n  function withdrawAmount(\n    address receiver,\n    address creator,\n    uint256 creatorPct,\n    address assetToken,\n    uint256 assetAmount\n  ) external returns (\n    uint256 creatorAmount,\n    uint256 receiverAmount\n  );\n  function withdrawAmountForCreator(\n    address receiver,\n    uint256 creatorPct,\n    address assetToken,\n    uint256 assetAmount\n  ) external returns (\n    uint256 receiverAmount\n  );\n  function withdrawRewards(address receiver, address rewardsToken, uint256 rewardsAmount) external returns (uint256);\n  function executeForAccount(address contractAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\n  function refreshPrincipal(address assetToken) external;\n\n  function withdrawEther(address payable receiver, uint256 amount) external;\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external;\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external;\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external;\n}\n"
    },
    "contracts/v1/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ninterface IStaking {\n    function manualEpochInit(address[] memory tokens, uint128 epochId) external;\n    function getCurrentEpoch() external view returns (uint128);\n    function getEpochId(uint timestamp) external view returns (uint); // get epoch id\n    function getEpochUserBalance(address user, address token, uint128 epoch) external view returns(uint);\n    function getEpochPoolSize(address token, uint128 epoch) external view returns (uint);\n    function epoch1Start() external view returns (uint);\n    function epochDuration() external view returns (uint);\n}"
    },
    "contracts/v1/interfaces/ITokenInfoProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// TokenInfoProxy.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\n\ninterface ITokenInfoProxy {\n\n  event ContractFunctionSignatureSet(address indexed contractAddress, string fnName, bytes4 fnSig);\n\n  struct FnSignatures {\n    bytes4 ownerOf;\n    bytes4 creatorOf;\n  }\n\n  function setContractFnOwnerOf(address contractAddress, bytes4 fnSig) external;\n  function setContractFnCreatorOf(address contractAddress, bytes4 fnSig) external;\n\n  function getTokenUUID(address contractAddress, uint256 tokenId) external pure returns (uint256);\n  function isNFTOwnerOrOperator(address contractAddress, uint256 tokenId, address sender) external returns (bool);\n  function isNFTContractOrCreator(address contractAddress, uint256 tokenId, address sender) external returns (bool);\n  function getTokenOwner(address contractAddress, uint256 tokenId) external returns (address);\n  function getTokenCreator(address contractAddress, uint256 tokenId) external returns (address);\n}\n"
    },
    "contracts/v1/interfaces/IUniverse.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IUniverse.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Universal Controller interface\n * @dev ...\n */\ninterface IUniverse {\n\n  event ChargedParticlesSet(address indexed chargedParticles);\n  event PhotonSet(address indexed photonToken, uint256 maxSupply);\n  event ProtonTokenSet(address indexed protonToken);\n  event LeptonTokenSet(address indexed leptonToken);\n  event QuarkTokenSet(address indexed quarkToken);\n  event BosonTokenSet(address indexed bosonToken);\n  event EsaMultiplierSet(address indexed assetToken, uint256 multiplier);\n  event ElectrostaticAttraction(address indexed account, address photonSource, uint256 energy, uint256 multiplier);\n  event ElectrostaticDischarge(address indexed account, address photonSource, uint256 energy);\n\n  function onEnergize(\n    address sender,\n    address referrer,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata managerId,\n    address assetToken,\n    uint256 assetEnergy\n  ) external;\n\n  function onDischarge(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata managerId,\n    address assetToken,\n    uint256 creatorEnergy,\n    uint256 receiverEnergy\n  ) external;\n\n  function onDischargeForCreator(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata managerId,\n    address creator,\n    address assetToken,\n    uint256 receiverEnergy\n  ) external;\n\n  function onRelease(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata managerId,\n    address assetToken,\n    uint256 principalEnergy,\n    uint256 creatorEnergy,\n    uint256 receiverEnergy\n  ) external;\n\n  function onCovalentBond(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata managerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  ) external;\n\n  function onCovalentBreak(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata managerId,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  ) external;\n\n  function onProtonSale(\n    address contractAddress,\n    uint256 tokenId,\n    address oldOwner,\n    address newOwner,\n    uint256 salePrice,\n    address creator,\n    uint256 creatorRoyalties\n  ) external;\n}\n"
    },
    "contracts/v1/interfaces/IUniverseRP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IUniverseRP.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IUniverse.sol\";\n\n/**\n * @title Universal Controller interface for Rewards Program\n * @dev ...\n */\ninterface IUniverseRP is IUniverse {\n  event RewardProgramSet(address indexed assetToken, address indexed rewardProgram);\n  event RewardProgramRemoved(address indexed assetToken);\n  event NftDeposit(address indexed contractAddress, uint256 tokenId, address indexed nftTokenAddress, uint256 nftTokenId);\n  event NftRelease(address indexed contractAddress, uint256 tokenId, address indexed nftTokenAddress, uint256 nftTokenId);\n\n  struct NftStake {\n    uint256 multiplier; // in Basis Points\n    uint256 depositBlockNumber;\n    uint256 releaseBlockNumber;\n  }\n\n  function getRewardProgram(address asset) external view returns (address);\n  function getNftStake(uint256 uuid) external view returns (NftStake memory);\n}\n"
    },
    "contracts/v1/interfaces/IWalletManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// IWalletManager.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\n/**\n * @title Particle Wallet Manager interface\n * @dev The wallet-manager for underlying assets attached to Charged Particles\n * @dev Manages the link between NFTs and their respective Smart-Wallets\n */\ninterface IWalletManager {\n\n  event ControllerSet(address indexed controller);\n  event ExecutorSet(address indexed executor);\n  event PausedStateSet(bool isPaused);\n  event NewSmartWallet(address indexed contractAddress, uint256 indexed tokenId, address indexed smartWallet, address creator, uint256 annuityPct);\n  event WalletEnergized(address indexed contractAddress, uint256 indexed tokenId, address indexed assetToken, uint256 assetAmount, uint256 yieldTokensAmount);\n  event WalletDischarged(address indexed contractAddress, uint256 indexed tokenId, address indexed assetToken, uint256 creatorAmount, uint256 receiverAmount);\n  event WalletDischargedForCreator(address indexed contractAddress, uint256 indexed tokenId, address indexed assetToken, address creator, uint256 receiverAmount);\n  event WalletReleased(address indexed contractAddress, uint256 indexed tokenId, address indexed receiver, address assetToken, uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount);\n  event WalletRewarded(address indexed contractAddress, uint256 indexed tokenId, address indexed receiver, address rewardsToken, uint256 rewardsAmount);\n\n  function isPaused() external view returns (bool);\n\n  function isReserveActive(address contractAddress, uint256 tokenId, address assetToken) external view returns (bool);\n  function getReserveInterestToken(address contractAddress, uint256 tokenId, address assetToken) external view returns (address);\n\n  function getTotal(address contractAddress, uint256 tokenId, address assetToken) external returns (uint256);\n  function getPrincipal(address contractAddress, uint256 tokenId, address assetToken) external returns (uint256);\n  function getInterest(address contractAddress, uint256 tokenId, address assetToken) external returns (uint256 creatorInterest, uint256 ownerInterest);\n  function getRewards(address contractAddress, uint256 tokenId, address rewardToken) external returns (uint256);\n\n  function energize(address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount) external returns (uint256 yieldTokensAmount);\n  function discharge(address receiver, address contractAddress, uint256 tokenId, address assetToken, address creatorRedirect) external returns (uint256 creatorAmount, uint256 receiverAmount);\n  function dischargeAmount(address receiver, address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount, address creatorRedirect) external returns (uint256 creatorAmount, uint256 receiverAmount);\n  function dischargeAmountForCreator(address receiver, address contractAddress, uint256 tokenId, address creator, address assetToken, uint256 assetAmount) external returns (uint256 receiverAmount);\n  function release(address receiver, address contractAddress, uint256 tokenId, address assetToken, address creatorRedirect) external returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount);\n  function releaseAmount(address receiver, address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount, address creatorRedirect) external returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount);\n  function withdrawRewards(address receiver, address contractAddress, uint256 tokenId, address rewardsToken, uint256 rewardsAmount) external returns (uint256 amount);\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams) external returns (bytes memory);\n  function refreshPrincipal(address contractAddress, uint256 tokenId, address assetToken) external;\n  function getWalletAddressById(address contractAddress, uint256 tokenId, address creator, uint256 annuityPct) external returns (address);\n\n  function withdrawEther(address contractAddress, uint256 tokenId, address payable receiver, uint256 amount) external;\n  function withdrawERC20(address contractAddress, uint256 tokenId, address payable receiver, address tokenAddress, uint256 amount) external;\n  function withdrawERC721(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId) external;\n}\n"
    },
    "contracts/v1/lib/BaseProton.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ProtonB.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/IBaseProton.sol\";\nimport \"../lib/TokenInfo.sol\";\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../lib/RelayRecipient.sol\";\n\n/// @title Base Proton Contract for Charged Particles compatible ERC721 NFTs\n/// @dev MUST NOT be Upgradeable, as Upgradeable NFTs are incompatible with Charged Particles.\ncontract BaseProton is \n  IBaseProton, \n  ERC721, \n  Ownable, \n  RelayRecipient, \n  ReentrancyGuard, \n  BlackholePrevention \n{\n  using SafeMath for uint256;\n  using TokenInfo for address payable;\n  using Counters for Counters.Counter;\n\n  event Received(address, uint);\n\n  uint256 constant internal PERCENTAGE_SCALE = 1e4;   // 10000  (100%)\n\n  /// @dev Sequential Token IDs storage\n  Counters.Counter internal _tokenIds;\n\n  /// @dev NFT Token Creator settings\n  mapping (uint256 => address) internal _tokenCreator;\n  mapping (uint256 => uint256) internal _tokenCreatorRoyaltiesPct;\n  mapping (uint256 => address) internal _tokenCreatorRoyaltiesRedirect;\n  mapping (address => uint256) internal _tokenCreatorClaimableRoyalties;\n\n  /// @dev NFT Token Sale settings\n  mapping (uint256 => uint256) internal _tokenSalePrice;\n  mapping (uint256 => uint256) internal _tokenLastSellPrice;\n\n  /// @dev Whether of not the Contract is Paused\n  bool internal _paused;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  /// @dev Inherit from ERC721 standard\n  constructor(string memory _name, string memory _symbol) public ERC721(_name, _symbol) {}\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n  receive() external payable virtual {\n    emit Received(msg.sender, msg.value);\n  }\n\n  /// Returns the Creator address of an NFT by Token ID\n  /// @param tokenId The ID of the NFT Token to lookup\n  /// @return The address of the Creator account\n  function creatorOf(uint256 tokenId) external view virtual override returns (address) {\n    return _tokenCreator[tokenId];\n  }\n\n  /// Returns the Sale Price of an NFT by Token ID\n  /// @param tokenId The ID of the NFT Token to lookup\n  /// @return The sale price of the NFT\n  function getSalePrice(uint256 tokenId) external view virtual override returns (uint256) {\n    return _tokenSalePrice[tokenId];\n  }\n\n  /// Returns the Last Sale Price of an NFT by Token ID\n  /// @notice This is used to determine any increase in sale price used in royalties calculations\n  /// @param tokenId The ID of the NFT Token to lookup\n  /// @return The last sale price of the NFT\n  function getLastSellPrice(uint256 tokenId) external view virtual override returns (uint256) {\n    return _tokenLastSellPrice[tokenId];\n  }\n\n  /// Returns the Claimable Royalties for the NFT Creator\n  /// @param account The address of the Creator account to lookup\n  /// @return The amount of earned royalties for the creator account\n  function getCreatorRoyalties(address account) external view virtual override returns (uint256) {\n    return _tokenCreatorClaimableRoyalties[account];\n  }\n\n  /// Returns the Percentage of Royalties reserved for the NFT Creator\n  /// @param tokenId The ID of the NFT Token to lookup\n  /// @return The percentage of royalties reserved for the creator\n  function getCreatorRoyaltiesPct(uint256 tokenId) external view virtual override returns (uint256) {\n    return _tokenCreatorRoyaltiesPct[tokenId];\n  }\n\n  /// Returns the Receiving address of the Creator Royalties (or Creator if not set)\n  /// @dev Returns the creator address if a receiving address has not been configured\n  /// @param tokenId The ID of the NFT Token to lookup\n  /// @return The Receiving address of the Creator Royalties\n  function getCreatorRoyaltiesReceiver(uint256 tokenId) external view virtual override returns (address) {\n    return _creatorRoyaltiesReceiver(tokenId);\n  }\n\n  /// Allows an NFT Creator to Claim any Royalties that have been earned from NFT sales\n  /// @dev Must be called by the royalties receiver account (not neccessarily the creator)\n  /// @return The amout of creator royalties claimed\n  function claimCreatorRoyalties()\n    external\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256)\n  {\n    return _claimCreatorRoyalties(_msgSender());\n  }\n\n\n  /***********************************|\n  |       Create Single Protons       |\n  |__________________________________*/\n\n  /// Creates a Basic NFT with no Royalties and no initial Sale Price\n  /// @dev Royalties and Sale Price can be configured later\n  /// @param creator The address of the NFT Creator (can be different from the caller)\n  /// @param receiver The receiving address of the NFT (can be different from the caller)\n  /// @param tokenMetaUri The unique metadata URI for the NFT\n  /// @return newTokenId The newly minted NFT Token ID\n  function createProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri\n  )\n    external\n    virtual\n    override\n    whenNotPaused\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      0, // royaltiesPercent\n      0  // salePrice\n    );\n  }\n\n\n  /***********************************|\n  |      Create Multiple Protons      |\n  |__________________________________*/\n\n  function createProtons(\n    address creator,\n    address receiver,\n    string[] calldata tokenMetaUris\n  )\n    external\n    virtual\n    override\n    whenNotPaused\n    returns (bool)\n  {\n    _createProtons(\n      creator,\n      receiver,\n      0,  // royaltiesPercent\n      tokenMetaUris\n    );\n    return true;\n  }\n\n  function createProtonsForSale(\n    address creator,\n    address receiver,\n    uint256 royaltiesPercent,\n    string[] calldata tokenMetaUris,\n    uint256[] calldata salePrices\n  )\n    external\n    virtual\n    override\n    whenNotPaused\n    returns (bool)\n  {\n    _createProtonsForSale(\n      creator,\n      receiver,\n      royaltiesPercent,\n      tokenMetaUris,\n      salePrices\n    );\n    return true;\n  }\n\n\n  /***********************************|\n  |           Buy Protons             |\n  |__________________________________*/\n\n  function buyProton(uint256 tokenId, uint256 gasLimit)\n    external\n    payable\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (bool)\n  {\n    _buyProton(tokenId, gasLimit);\n    return true;\n  }\n\n  /***********************************|\n  |     Only Token Creator/Owner      |\n  |__________________________________*/\n\n  function setSalePrice(uint256 tokenId, uint256 salePrice)\n    external\n    virtual\n    override\n    whenNotPaused\n    onlyTokenOwnerOrApproved(tokenId)\n  {\n    _setSalePrice(tokenId, salePrice);\n  }\n\n  function setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct)\n    external\n    virtual\n    override\n    whenNotPaused\n    onlyTokenCreator(tokenId)\n    onlyTokenOwnerOrApproved(tokenId)\n  {\n    _setRoyaltiesPct(tokenId, royaltiesPct);\n  }\n\n  function setCreatorRoyaltiesReceiver(uint256 tokenId, address receiver)\n    external\n    virtual\n    override\n    whenNotPaused\n    onlyTokenCreator(tokenId)\n  {\n    _tokenCreatorRoyaltiesRedirect[tokenId] = receiver;\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function setPausedState(bool state) external virtual onlyOwner {\n    _paused = state;\n    emit PausedStateSet(state);\n  }\n\n  function setTrustedForwarder(address _trustedForwarder) external virtual onlyOwner {\n    trustedForwarder = _trustedForwarder;\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _setSalePrice(uint256 tokenId, uint256 salePrice) internal virtual {\n    _tokenSalePrice[tokenId] = salePrice;\n    emit SalePriceSet(tokenId, salePrice);\n  }\n\n  function _setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct) internal virtual {\n    require(royaltiesPct <= PERCENTAGE_SCALE, \"PRT:E-421\");\n    _tokenCreatorRoyaltiesPct[tokenId] = royaltiesPct;\n    emit CreatorRoyaltiesSet(tokenId, royaltiesPct);\n  }\n\n  function _creatorRoyaltiesReceiver(uint256 tokenId) internal view virtual returns (address) {\n    address receiver = _tokenCreatorRoyaltiesRedirect[tokenId];\n    if (receiver == address(0x0)) {\n      receiver = _tokenCreator[tokenId];\n    }\n    return receiver;\n  }\n\n  function _createProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 royaltiesPercent,\n    uint256 salePrice\n  )\n    internal\n    virtual\n    returns (uint256 newTokenId)\n  {\n    _tokenIds.increment();\n\n    newTokenId = _tokenIds.current();\n    _safeMint(receiver, newTokenId, \"\");\n    _tokenCreator[newTokenId] = creator;\n\n    _setTokenURI(newTokenId, tokenMetaUri);\n\n    if (royaltiesPercent > 0) {\n      _setRoyaltiesPct(newTokenId, royaltiesPercent);\n    }\n\n    if (salePrice > 0) {\n      _setSalePrice(newTokenId, salePrice);\n    }\n  }\n\n  function _createProtons(\n    address creator,\n    address receiver,\n    uint256 royaltiesPercent,\n    string[] calldata tokenMetaUris\n  )\n    internal\n    virtual\n  {\n    uint256 count = tokenMetaUris.length;\n    for (uint256 i; i < count; i++) {\n      _createProton(creator, receiver, tokenMetaUris[i], royaltiesPercent, 0);\n    }\n  }\n\n  function _createProtonsForSale(\n    address creator,\n    address receiver,\n    uint256 royaltiesPercent,\n    string[] calldata tokenMetaUris,\n    uint256[] calldata salePrices\n  )\n    internal\n    virtual\n  {\n    require(tokenMetaUris.length == salePrices.length, \"PRT:E-202\");\n\n    uint256 count = tokenMetaUris.length;\n    for (uint256 i; i < count; i++) {\n      _createProton(creator, receiver, tokenMetaUris[i], royaltiesPercent, salePrices[i]);\n    }\n  }\n\n  function _buyProton(uint256 _tokenId, uint256 _gasLimit)\n    internal\n    virtual\n    returns (\n      address contractAddress,\n      uint256 tokenId,\n      address oldOwner,\n      address newOwner,\n      uint256 salePrice,\n      address royaltiesReceiver,\n      uint256 creatorAmount\n    )\n  {\n    contractAddress = address(this);\n    tokenId = _tokenId;\n    salePrice = _tokenSalePrice[_tokenId];\n    require(salePrice > 0, \"PRT:E-416\");\n    require(msg.value >= salePrice, \"PRT:E-414\");\n\n    uint256 ownerAmount = salePrice;\n    creatorAmount;\n    oldOwner = ownerOf(_tokenId);\n    newOwner = _msgSender();\n\n    // Creator Royalties\n    royaltiesReceiver = _creatorRoyaltiesReceiver(_tokenId);\n    uint256 royaltiesPct = _tokenCreatorRoyaltiesPct[_tokenId];\n    uint256 lastSellPrice = _tokenLastSellPrice[_tokenId];\n    if (royaltiesPct > 0 && lastSellPrice > 0 && salePrice > lastSellPrice) {\n      creatorAmount = (salePrice - lastSellPrice).mul(royaltiesPct).div(PERCENTAGE_SCALE);\n      ownerAmount = ownerAmount.sub(creatorAmount);\n    }\n    _tokenLastSellPrice[_tokenId] = salePrice;\n\n    // Reserve Royalties for Creator\n    if (creatorAmount > 0) {\n      _tokenCreatorClaimableRoyalties[royaltiesReceiver] = _tokenCreatorClaimableRoyalties[royaltiesReceiver].add(creatorAmount);\n    }\n\n    // Transfer Token\n    _transfer(oldOwner, newOwner, _tokenId);\n\n    // Transfer Payment\n    if (ownerAmount > 0) {\n      payable(oldOwner).sendValue(ownerAmount, _gasLimit);\n    }\n\n    emit ProtonSold(_tokenId, oldOwner, newOwner, salePrice, royaltiesReceiver, creatorAmount);\n\n    _refundOverpayment(salePrice, _gasLimit);\n  }\n\n  /**\n    * @dev Pays out the Creator Royalties of the calling account\n    * @param receiver  The receiver of the claimable royalties\n    * @return          The amount of Creator Royalties claimed\n    */\n  function _claimCreatorRoyalties(address receiver) internal virtual returns (uint256) {\n    uint256 claimableAmount = _tokenCreatorClaimableRoyalties[receiver];\n    require(claimableAmount > 0, \"PRT:E-411\");\n\n    delete _tokenCreatorClaimableRoyalties[receiver];\n    payable(receiver).sendValue(claimableAmount, 0);\n\n    emit RoyaltiesClaimed(receiver, claimableAmount);\n  }\n\n  /**\n    * @dev Collects the Required Asset Token from the users wallet\n    * @param from         The owner address to collect the Assets from\n    * @param assetAmount  The Amount of Asset Tokens to Collect\n    */\n  function _collectAssetToken(address from, address assetToken, uint256 assetAmount) internal virtual {\n    uint256 _userAssetBalance = IERC20(assetToken).balanceOf(from);\n    require(assetAmount <= _userAssetBalance, \"PRT:E-411\");\n    // Be sure to Approve this Contract to transfer your Asset Token\n    require(IERC20(assetToken).transferFrom(from, address(this), assetAmount), \"PRT:E-401\");\n  }\n\n  function _refundOverpayment(uint256 threshold, uint256 gasLimit) internal virtual {\n    uint256 overage = msg.value.sub(threshold);\n    if (overage > 0) {\n      payable(_msgSender()).sendValue(overage, gasLimit);\n    }\n  }\n\n  function _transfer(address from, address to, uint256 tokenId) internal virtual override {\n    _tokenSalePrice[tokenId] = 0;\n    super._transfer(from, to, tokenId);\n  }\n\n\n  /***********************************|\n  |          GSN/MetaTx Relay         |\n  |__________________________________*/\n\n  /// @dev See {BaseRelayRecipient-_msgSender}.\n  function _msgSender()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, Context)\n    returns (address payable)\n  {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  /// @dev See {BaseRelayRecipient-_msgData}.\n  function _msgData()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, Context)\n    returns (bytes memory)\n  {\n    return BaseRelayRecipient._msgData();\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier whenNotPaused() {\n      require(!_paused, \"PRT:E-101\");\n      _;\n  }\n\n  modifier onlyTokenOwnerOrApproved(uint256 tokenId) {\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \"PRT:E-105\");\n    _;\n  }\n\n  modifier onlyTokenCreator(uint256 tokenId) {\n    require(_tokenCreator[tokenId] == _msgSender(), \"PRT:E-104\");\n    _;\n  }\n}"
    },
    "contracts/v1/lib/Bitwise.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Bitwise.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nlibrary Bitwise {\n  function negate(uint32 a) internal pure returns (uint32) {\n    return a ^ maxInt();\n  }\n\n  function shiftLeft(uint32 a, uint32 n) internal pure returns (uint32) {\n    return a * uint32(2) ** n;\n  }\n\n  function shiftRight(uint32 a, uint32 n) internal pure returns (uint32) {\n    return a / uint32(2) ** n;\n  }\n\n  function maxInt() internal pure returns (uint32) {\n    return uint32(-1);\n  }\n\n  // Get bit value at position\n  function hasBit(uint32 a, uint32 n) internal pure returns (bool) {\n    return a & shiftLeft(0x01, n) != 0;\n  }\n\n  // Set bit value at position\n  function setBit(uint32 a, uint32 n) internal pure returns (uint32) {\n    return a | shiftLeft(0x01, n);\n  }\n\n  // Set the bit into state \"false\"\n  function clearBit(uint32 a, uint32 n) internal pure returns (uint32) {\n    uint32 mask = negate(shiftLeft(0x01, n));\n    return a & mask;\n  }\n}\n"
    },
    "contracts/v1/lib/BlackholePrevention.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// BlackholePrevention.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n/**\n * @notice Prevents ETH or Tokens from getting stuck in a contract by allowing\n *  the Owner/DAO to pull them out on behalf of a user\n * This is only meant to contracts that are not expected to hold tokens, but do handle transferring them.\n */\ncontract BlackholePrevention {\n  using Address for address payable;\n  using SafeERC20 for IERC20;\n\n  event WithdrawStuckEther(address indexed receiver, uint256 amount);\n  event WithdrawStuckERC20(address indexed receiver, address indexed tokenAddress, uint256 amount);\n  event WithdrawStuckERC721(address indexed receiver, address indexed tokenAddress, uint256 indexed tokenId);\n  event WithdrawStuckERC1155(address indexed receiver, address indexed tokenAddress, uint256 indexed tokenId, uint256 amount);\n\n  function _withdrawEther(address payable receiver, uint256 amount) internal virtual {\n    require(receiver != address(0x0), \"BHP:E-403\");\n    if (address(this).balance >= amount) {\n      receiver.sendValue(amount);\n      emit WithdrawStuckEther(receiver, amount);\n    }\n  }\n\n  function _withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) internal virtual {\n    require(receiver != address(0x0), \"BHP:E-403\");\n    if (IERC20(tokenAddress).balanceOf(address(this)) >= amount) {\n      IERC20(tokenAddress).safeTransfer(receiver, amount);\n      emit WithdrawStuckERC20(receiver, tokenAddress, amount);\n    }\n  }\n\n  function _withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) internal virtual {\n    require(receiver != address(0x0), \"BHP:E-403\");\n    if (IERC721(tokenAddress).ownerOf(tokenId) == address(this)) {\n      IERC721(tokenAddress).transferFrom(address(this), receiver, tokenId);\n      emit WithdrawStuckERC721(receiver, tokenAddress, tokenId);\n    }\n  }\n\n  function _withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) internal virtual {\n    require(receiver != address(0x0), \"BHP:E-403\");\n    if (IERC1155(tokenAddress).balanceOf(address(this), tokenId) >= amount) {\n      IERC1155(tokenAddress).safeTransferFrom(address(this), receiver, tokenId, amount, \"\");\n      emit WithdrawStuckERC1155(receiver, tokenAddress, tokenId, amount);\n    }\n  }\n}\n"
    },
    "contracts/v1/lib/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    /**\n     * @dev Emitted when `tokenId` token is transfered from `from` to `to`.\n     */\n    event TransferBatch(address indexed from, address indexed to, uint256 startTokenId, uint256 count);\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"ERC721:E-403\");\n\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721:E-405\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721:E-405\");\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721:E-111\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721:E-105\");\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"ERC721:E-405\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721:E-111\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721:E-105\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721:E-105\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mecanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721:E-402\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721:E-405\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721:E-402\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMintBatch(address to, uint256 startTokenId, uint256 count, bytes memory _data) internal virtual {\n        _mintBatch(to, startTokenId, count);\n        require(_checkOnERC721Received(address(0), to, startTokenId, _data), \"ERC721:E-402\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721:E-403\");\n        require(!_exists(tokenId), \"ERC721:E-407\");\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mintBatch(address to, uint256 startTokenId, uint256 count) internal virtual {\n        require(to != address(0), \"ERC721:E-403\");\n        require(!_exists(startTokenId), \"ERC721:E-407\");\n\n        for (uint i = 0; i < count; i++) {\n          uint256 tokenId = startTokenId.add(i);\n          _holderTokens[to].add(tokenId);\n          _tokenOwners.set(tokenId, to);\n        }\n\n        emit TransferBatch(address(0), to, startTokenId, count);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ownerOf(tokenId) == from, \"ERC721:E-102\");\n        require(to != address(0), \"ERC721:E-403\");\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721:E-405\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721:E-402\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n}\n"
    },
    "contracts/v1/lib/ERC721Basic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Basic is Context, ERC165, IERC721, IERC721Metadata {\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // mapping from token ids to their owners\n  mapping (uint256 => address) internal _tokenOwners;\n\n  // mapping from owner to token balance\n  mapping (address => uint256) internal _ownerBalance;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) internal _tokenApprovals;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) internal _operatorApprovals;\n\n  // Token name\n  string internal _name;\n\n  // Token symbol\n  string internal _symbol;\n\n  // Token Count\n  uint256 internal _tokenCount;\n\n  /*\n    *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n    *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n    *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n    *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n    *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n    *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n    *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n    *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n    *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n    *\n    *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n    *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n    */\n  bytes4 internal constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n  /*\n    *     bytes4(keccak256('name()')) == 0x06fdde03\n    *     bytes4(keccak256('symbol()')) == 0x95d89b41\n    *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n    *\n    *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n    */\n  bytes4 internal constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n  /**\n    * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n    */\n  constructor (string memory name, string memory symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_INTERFACE_ID_ERC721);\n    _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n  }\n\n  /**\n    * @dev See {IERC721-balanceOf}.\n    */\n  function balanceOf(address owner) public view override returns (uint256) {\n    require(owner != address(0), \"ERC721:E-403\");\n    return _ownerBalance[owner];\n  }\n\n  /**\n    * @dev See {IERC721-ownerOf}.\n    */\n  function ownerOf(uint256 tokenId) public view override returns (address) {\n    return _tokenOwners[tokenId];\n  }\n\n  /**\n    * @dev See {IERC721Metadata-name}.\n    */\n  function name() public view override returns (string memory) {\n    return _name;\n  }\n\n  /**\n    * @dev See {IERC721Metadata-symbol}.\n    */\n  function symbol() public view override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n    * @dev See {IERC721Metadata-tokenURI}.\n    */\n  function tokenURI(uint256 /* tokenId */) public view virtual override returns (string memory) {\n    return \"\";\n  }\n\n  /**\n    * @dev See {IERC721-approve}.\n    */\n  function approve(address to, uint256 tokenId) public virtual override {\n    address owner = ownerOf(tokenId);\n    require(to != owner, \"ERC721:E-111\");\n\n    require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721:E-105\");\n\n    _approve(to, tokenId);\n  }\n\n  /**\n    * @dev See {IERC721-getApproved}.\n    */\n  function getApproved(uint256 tokenId) public view override returns (address) {\n    require(_exists(tokenId), \"ERC721:E-405\");\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n    * @dev See {IERC721-setApprovalForAll}.\n    */\n  function setApprovalForAll(address operator, bool approved) public virtual override {\n    require(operator != _msgSender(), \"ERC721:E-111\");\n\n    _operatorApprovals[_msgSender()][operator] = approved;\n    emit ApprovalForAll(_msgSender(), operator, approved);\n  }\n\n  /**\n    * @dev See {IERC721-isApprovedForAll}.\n    */\n  function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n    * @dev See {IERC721-transferFrom}.\n    */\n  function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n    //solhint-disable-next-line max-line-length\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721:E-105\");\n\n    _transfer(from, to, tokenId);\n  }\n\n  /**\n    * @dev See {IERC721-safeTransferFrom}.\n    */\n  function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n    * @dev See {IERC721-safeTransferFrom}.\n    */\n  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721:E-105\");\n    _safeTransfer(from, to, tokenId, _data);\n  }\n\n  /**\n    * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n    * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n    *\n    * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n    *\n    * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n    * implement alternative mecanisms to perform token transfer, such as signature-based.\n    *\n    * Requirements:\n    *\n    * - `from` cannot be the zero address.\n    * - `to` cannot be the zero address.\n    * - `tokenId` token must exist and be owned by `from`.\n    * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    *\n    * Emits a {Transfer} event.\n    */\n  function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n    _transfer(from, to, tokenId);\n    require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721:E-402\");\n  }\n\n  /**\n    * @dev Returns whether `tokenId` exists.\n    *\n    * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n    *\n    * Tokens start existing when they are minted (`_mint`),\n    * and stop existing when they are burned (`_burn`).\n    */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return _tokenOwners[tokenId] != address(0x0);\n  }\n\n  /**\n    * @dev Returns whether `spender` is allowed to manage `tokenId`.\n    *\n    * Requirements:\n    *\n    * - `tokenId` must exist.\n    */\n  function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n    require(_exists(tokenId), \"ERC721:E-405\");\n    address owner = ownerOf(tokenId);\n    return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n  }\n\n  /**\n    * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n    * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n    */\n  function _safeMint(address to, bytes memory _data) internal virtual returns (uint256) {\n    uint256 tokenId = _mint(to);\n    require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721:E-402\");\n    return tokenId;\n  }\n\n  /**\n    * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n    * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n    */\n  function _safeMintBatch(address to, uint256 count, bytes memory _data) internal virtual {\n    uint256 startTokenId = _mintBatch(to, count);\n    require(_checkOnERC721Received(address(0), to, startTokenId, _data), \"ERC721:E-402\");\n  }\n\n  /**\n    * @dev Mints `tokenId` and transfers it to `to`.\n    *\n    * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n    *\n    * Requirements:\n    *\n    * - `tokenId` must not exist.\n    * - `to` cannot be the zero address.\n    *\n    * Emits a {Transfer} event.\n    */\n  function _mint(address to) internal virtual returns (uint256) {\n    require(to != address(0), \"ERC721:E-403\");\n\n    _tokenCount = _tokenCount.add(1);\n    uint256 tokenId = _tokenCount;\n    require(!_exists(tokenId), \"ERC721:E-407\");\n\n    _tokenOwners[tokenId] = to;\n    _ownerBalance[to] = _ownerBalance[to].add(1);\n\n    emit Transfer(address(0), to, tokenId);\n    return tokenId;\n  }\n\n  /**\n    * @dev Mints `tokenId` and transfers it to `to`.\n    *\n    * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n    *\n    * Requirements:\n    *\n    * - `tokenId` must not exist.\n    * - `to` cannot be the zero address.\n    *\n    * Emits a {Transfer} event.\n    */\n  function _mintBatch(address to, uint256 count) internal virtual returns (uint256) {\n    require(to != address(0), \"ERC721:E-403\");\n\n    uint256 startTokenId = _tokenCount.add(1);\n    for (uint i = 1; i <= count; i++) {\n      uint256 tokenId = _tokenCount.add(i);\n      _tokenOwners[tokenId] = to;\n      emit Transfer(address(0), to, tokenId);\n    }\n\n    _tokenCount = _tokenCount.add(count);\n    _ownerBalance[to] = _ownerBalance[to].add(count);\n    return startTokenId;\n  }\n\n  /**\n    * @dev Transfers `tokenId` from `from` to `to`.\n    *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n    *\n    * Requirements:\n    *\n    * - `to` cannot be the zero address.\n    * - `tokenId` token must be owned by `from`.\n    *\n    * Emits a {Transfer} event.\n    */\n  function _transfer(address from, address to, uint256 tokenId) internal virtual {\n    require(ownerOf(tokenId) == from, \"ERC721:E-102\");\n    require(to != address(0), \"ERC721:E-403\");\n\n    // Clear approvals from the previous owner\n    _approve(address(0), tokenId);\n\n    _tokenOwners[tokenId] = to;\n    _ownerBalance[from] = _ownerBalance[from].sub(1);\n    _ownerBalance[to] = _ownerBalance[to].add(1);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n    * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n    * The call is not executed if the target address is not a contract.\n    *\n    * @param from address representing the previous owner of the given token ID\n    * @param to target address that will receive the tokens\n    * @param tokenId uint256 ID of the token to be transferred\n    * @param _data bytes optional data to send along with the call\n    * @return bool whether the call correctly returned the expected magic value\n    */\n  function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n    internal returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n      IERC721Receiver(to).onERC721Received.selector,\n      _msgSender(),\n      from,\n      tokenId,\n      _data\n    ), \"ERC721:E-402\");\n    bytes4 retval = abi.decode(returndata, (bytes4));\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  function _approve(address to, uint256 tokenId) internal {\n    _tokenApprovals[tokenId] = to;\n    emit Approval(ownerOf(tokenId), to, tokenId);\n  }\n}\n"
    },
    "contracts/v1/lib/IERC5192.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.6.0;\n\ninterface IERC5192 {\n  /// @notice Emitted when the locking status is changed to locked.\n  /// @dev If a token is minted and the status is locked, this event should be emitted.\n  /// @param tokenId The identifier for a token.\n  event Locked(uint256 tokenId);\n\n  /// @notice Emitted when the locking status is changed to unlocked.\n  /// @dev If a token is minted and the status is unlocked, this event should be emitted.\n  /// @param tokenId The identifier for a token.\n  event Unlocked(uint256 tokenId);\n\n  /// @notice Returns the locking status of an Soulbound Token\n  /// @dev SBTs assigned to zero address are considered invalid, and queries\n  /// about them do throw.\n  /// @param tokenId The identifier for an SBT.\n  function locked(uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/v1/lib/NftTokenType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// NftTokenType.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/introspection/IERC165.sol\";\n\nlibrary NftTokenType {\n  bytes4 constant internal INTERFACE_SIGNATURE_ERC721 = 0x80ac58cd;\n  bytes4 constant internal INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n\n  uint256 constant internal TYPE_MASK = uint256(uint128(~0)) << 128;\n  uint256 constant internal TYPE_NFT_BIT = 1 << 255;\n\n  function isERC721(address contractAddress) internal view returns (bool) {\n    return IERC165(contractAddress).supportsInterface(INTERFACE_SIGNATURE_ERC721);\n  }\n\n  function isERC1155(address contractAddress) internal view returns (bool) {\n    return IERC165(contractAddress).supportsInterface(INTERFACE_SIGNATURE_ERC1155);\n  }\n\n  function getTokenType(address contractAddress, uint256 tokenId) internal view returns (uint256) {\n    IERC165 tokenInterface = IERC165(contractAddress);\n    bool is1155 = tokenInterface.supportsInterface(INTERFACE_SIGNATURE_ERC1155);\n\n    if (!is1155 || (tokenId & TYPE_NFT_BIT != TYPE_NFT_BIT)) { return 0; }\n\n    return tokenId & TYPE_MASK;\n  }\n}\n"
    },
    "contracts/v1/lib/ReentrancyGuard.sol": {
      "content": "pragma solidity 0.6.12;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () public {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}"
    },
    "contracts/v1/lib/RelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"@opengsn/gsn/contracts/BaseRelayRecipient.sol\";\n\ncontract RelayRecipient is BaseRelayRecipient {\n  function versionRecipient() external override view returns (string memory) {\n    return \"1.0.0-beta.1/charged-particles.relay.recipient\";\n  }\n}\n"
    },
    "contracts/v1/lib/SmartWalletBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// SmartWalletBase.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../interfaces/ISmartWallet.sol\";\nimport \"./BlackholePrevention.sol\";\n\n/**\n * @notice ERC20-Token Smart-Wallet Base Contract\n * @dev Non-upgradeable Contract\n */\nabstract contract SmartWalletBase is ISmartWallet, BlackholePrevention {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  uint256 constant internal PERCENTAGE_SCALE = 1e4;  // 10000  (100%)\n\n  address internal _walletManager;\n\n  address internal nftCreator;\n  uint256 internal nftCreatorAnnuityPct;\n  uint256 internal nftCreatorAmountDischarged;\n\n  EnumerableSet.AddressSet internal _assetTokens;\n\n  //   Asset Token => Principal Balance\n  mapping (address => uint256) internal _assetPrincipalBalance;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initializeBase() public {\n    require(_walletManager == address(0x0), \"SWB:E-002\");\n    _walletManager = msg.sender;\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function getAssetTokenCount() external view virtual override returns (uint256) {\n    return _assetTokens.length();\n  }\n\n  function getAssetTokenByIndex(uint256 index) external view virtual override returns (address) {\n    if (index >= _assetTokens.length()) {\n      return address(0);\n    }\n    return _assetTokens.at(index);\n  }\n\n  function setNftCreator(address creator, uint256 annuityPct) external virtual override onlyWalletManager {\n    nftCreator = creator;\n    nftCreatorAnnuityPct = annuityPct;\n  }\n\n  function executeForAccount(\n    address contractAddress,\n    uint256 ethValue,\n    bytes memory encodedParams\n  )\n    external\n    override\n    onlyWalletManager\n    returns (bytes memory)\n  {\n    (bool success, bytes memory result) = contractAddress.call{value: ethValue}(encodedParams);\n    require(success, string(result));\n    return result;\n  }\n\n  function refreshPrincipal(address assetToken)\n    external\n    virtual\n    override\n    onlyWalletManager\n  {\n    // no-op\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual override onlyWalletManager {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external virtual override onlyWalletManager {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual override onlyWalletManager {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _getPrincipal(address assetToken) internal view virtual returns (uint256) {\n    return _assetPrincipalBalance[assetToken];\n  }\n\n  function _trackAssetToken(address assetToken) internal virtual {\n    if (!_assetTokens.contains(assetToken)) {\n      _assetTokens.add(assetToken);\n    }\n  }\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  /// @dev Throws if called by any account other than the wallet manager\n  modifier onlyWalletManager() {\n    require(_walletManager == msg.sender, \"SWB:E-109\");\n    _;\n  }\n}"
    },
    "contracts/v1/lib/SmartWalletBaseB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// SmartWalletBase.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../interfaces/ISmartWalletB.sol\";\nimport \"./BlackholePrevention.sol\";\n\n/**\n * @notice ERC20-Token Smart-Wallet Base Contract\n * @dev Non-upgradeable Contract\n */\nabstract contract SmartWalletBaseB is ISmartWalletB, BlackholePrevention {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  uint256 constant internal PERCENTAGE_SCALE = 1e4;  // 10000  (100%)\n\n  address internal _walletManager;\n\n  EnumerableSet.AddressSet internal _assetTokens;\n\n  //   Asset Token => Principal Balance\n  mapping (address => uint256) internal _assetPrincipalBalance;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initializeBase() public {\n    require(_walletManager == address(0x0), \"SWB:E-002\");\n    _walletManager = msg.sender;\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function getAssetTokenCount() external view virtual override returns (uint256) {\n    return _assetTokens.length();\n  }\n\n  function getAssetTokenByIndex(uint256 index) external view virtual override returns (address) {\n    if (index >= _assetTokens.length()) {\n      return address(0);\n    }\n    return _assetTokens.at(index);\n  }\n\n  function executeForAccount(\n    address contractAddress,\n    uint256 ethValue,\n    bytes memory encodedParams\n  )\n    external\n    override\n    onlyWalletManager\n    returns (bytes memory)\n  {\n    (bool success, bytes memory result) = contractAddress.call{value: ethValue}(encodedParams);\n    require(success, string(result));\n    return result;\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual override onlyWalletManager {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external virtual override onlyWalletManager {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual override onlyWalletManager {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual override onlyWalletManager {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _getPrincipal(address assetToken) internal view virtual returns (uint256) {\n    return _assetPrincipalBalance[assetToken];\n  }\n\n  function _trackAssetToken(address assetToken) internal virtual {\n    if (!_assetTokens.contains(assetToken)) {\n      _assetTokens.add(assetToken);\n    }\n  }\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  /// @dev Throws if called by any account other than the wallet manager\n  modifier onlyWalletManager() {\n    require(_walletManager == msg.sender, \"SWB:E-109\");\n    _;\n  }\n}"
    },
    "contracts/v1/lib/Soul.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.6.12;\n\nimport \"./IERC5192.sol\";\n\ncontract Soul is IERC5192 {\n  \n  mapping (uint256 => bool) public lockedTokens;\n\n  function _lockToken(uint256 tokenId) internal {\n    lockedTokens[tokenId] = true;\n    emit Locked(tokenId);\n  }\n\n  function _unlockToken(uint256 tokenId) internal {\n    lockedTokens[tokenId] = false;\n    emit Unlocked(tokenId);\n  }\n\n  function locked(uint256 tokenId)\n    external\n    view\n    override(IERC5192)\n    returns (bool)\n  {\n    return lockedTokens[tokenId];\n  }\n}\n"
    },
    "contracts/v1/lib/TokenInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// TokenInfo.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"../interfaces/IERC721Chargeable.sol\";\n\nlibrary TokenInfo {\n  function getTokenUUID(address contractAddress, uint256 tokenId) internal pure virtual returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(contractAddress, tokenId)));\n  }\n\n  /// @dev DEPRECATED; Prefer TokenInfoProxy\n  function getTokenOwner(address contractAddress, uint256 tokenId) internal view virtual returns (address) {\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\n    return tokenInterface.ownerOf(tokenId);\n  }\n\n  /// @dev DEPRECATED; Prefer TokenInfoProxy\n  function getTokenCreator(address contractAddress, uint256 tokenId) internal view virtual returns (address) {\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\n    return tokenInterface.creatorOf(tokenId);\n  }\n\n  /// @dev DEPRECATED; Prefer TokenInfoProxy\n  /// @dev Checks if an account is the Owner of an External NFT contract\n  /// @param contractAddress  The Address to the Contract of the NFT to check\n  /// @param account          The Address of the Account to check\n  /// @return True if the account owns the contract\n  function isContractOwner(address contractAddress, address account) internal view virtual returns (bool) {\n    address contractOwner = IERC721Chargeable(contractAddress).owner();\n    return contractOwner != address(0x0) && contractOwner == account;\n  }\n\n  /// @dev DEPRECATED; Prefer TokenInfoProxy\n  /// @dev Checks if an account is the Creator of a Proton-based NFT\n  /// @param contractAddress  The Address to the Contract of the Proton-based NFT to check\n  /// @param tokenId          The Token ID of the Proton-based NFT to check\n  /// @param sender           The Address of the Account to check\n  /// @return True if the account is the creator of the Proton-based NFT\n  function isTokenCreator(address contractAddress, uint256 tokenId, address sender) internal view virtual returns (bool) {\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\n    address tokenCreator = tokenInterface.creatorOf(tokenId);\n    return (sender == tokenCreator);\n  }\n\n  /// @dev DEPRECATED; Prefer TokenInfoProxy\n  /// @dev Checks if an account is the Creator of a Proton-based NFT or the Contract itself\n  /// @param contractAddress  The Address to the Contract of the Proton-based NFT to check\n  /// @param tokenId          The Token ID of the Proton-based NFT to check\n  /// @param sender           The Address of the Account to check\n  /// @return True if the account is the creator of the Proton-based NFT or the Contract itself\n  function isTokenContractOrCreator(address contractAddress, uint256 tokenId, address creator, address sender) internal view virtual returns (bool) {\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\n    address tokenCreator = tokenInterface.creatorOf(tokenId);\n    if (sender == contractAddress && creator == tokenCreator) { return true; }\n    return (sender == tokenCreator);\n  }\n\n  /// @dev DEPRECATED; Prefer TokenInfoProxy\n  /// @dev Checks if an account is the Owner or Operator of an External NFT\n  /// @param contractAddress  The Address to the Contract of the External NFT to check\n  /// @param tokenId          The Token ID of the External NFT to check\n  /// @param sender           The Address of the Account to check\n  /// @return True if the account is the Owner or Operator of the External NFT\n  function isErc721OwnerOrOperator(address contractAddress, uint256 tokenId, address sender) internal view virtual returns (bool) {\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\n    address tokenOwner = tokenInterface.ownerOf(tokenId);\n    return (sender == tokenOwner || tokenInterface.isApprovedForAll(tokenOwner, sender));\n  }\n\n  /**\n    * @dev Returns true if `account` is a contract.\n    * @dev Taken from OpenZeppelin library\n    *\n    * [IMPORTANT]\n    * ====\n    * It is unsafe to assume that an address for which this function returns\n    * false is an externally-owned account (EOA) and not a contract.\n    *\n    * Among others, `isContract` will return false for the following\n    * types of addresses:\n    *\n    *  - an externally-owned account\n    *  - a contract in construction\n    *  - an address where a contract will be created\n    *  - an address where a contract lived, but was destroyed\n    * ====\n    */\n  function isContract(address account) internal view returns (bool) {\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n    // for accounts without code, i.e. `keccak256('')`\n    bytes32 codehash;\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    // solhint-disable-next-line no-inline-assembly\n    assembly { codehash := extcodehash(account) }\n    return (codehash != accountHash && codehash != 0x0);\n  }\n\n  /**\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n    * `recipient`, forwarding all available gas and reverting on errors.\n    * @dev Taken from OpenZeppelin library\n    *\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\n    * imposed by `transfer`, making them unable to receive funds via\n    * `transfer`. {sendValue} removes this limitation.\n    *\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n    *\n    * IMPORTANT: because control is transferred to `recipient`, care must be\n    * taken to not create reentrancy vulnerabilities. Consider using\n    * {ReentrancyGuard} or the\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n    */\n  function sendValue(address payable recipient, uint256 amount, uint256 gasLimit) internal {\n    require(address(this).balance >= amount, \"TokenInfo: insufficient balance\");\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = (gasLimit > 0)\n      ? recipient.call{ value: amount, gas: gasLimit }(\"\")\n      : recipient.call{ value: amount }(\"\");\n    require(success, \"TokenInfo: unable to send value, recipient may have reverted\");\n  }\n}\n"
    },
    "contracts/v1/lib/TokenInfoProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// TokenInfoProxy.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ITokenInfoProxy.sol\";\nimport \"../interfaces/IERC721Chargeable.sol\";\n\n\ncontract TokenInfoProxy is ITokenInfoProxy, Ownable {\n  using Address for address;\n\n  mapping (address => FnSignatures) internal _remappedFnSigs;\n\n  function setContractFnOwnerOf(address contractAddress, bytes4 fnSig) external virtual override onlyOwner {\n    _remappedFnSigs[contractAddress].ownerOf = fnSig;\n    emit ContractFunctionSignatureSet(contractAddress, \"ownerOf\", fnSig);\n  }\n\n  function setContractFnCreatorOf(address contractAddress, bytes4 fnSig) external virtual override onlyOwner {\n    _remappedFnSigs[contractAddress].creatorOf = fnSig;\n    emit ContractFunctionSignatureSet(contractAddress, \"creatorOf\", fnSig);\n  }\n\n\n  function getTokenUUID(address contractAddress, uint256 tokenId) external pure virtual override returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(contractAddress, tokenId)));\n  }\n\n  function getTokenOwner(address contractAddress, uint256 tokenId) external virtual override returns (address) {\n    return _getTokenOwner(contractAddress, tokenId);\n  }\n\n  function getTokenCreator(address contractAddress, uint256 tokenId) external virtual override returns (address) {\n    return _getTokenCreator(contractAddress, tokenId);\n  }\n\n  function isNFTOwnerOrOperator(address contractAddress, uint256 tokenId, address sender) external virtual override returns (bool) {\n    IERC721Chargeable tokenInterface = IERC721Chargeable(contractAddress);\n    address tokenOwner = _getTokenOwner(contractAddress, tokenId);\n    return (sender == tokenOwner || tokenInterface.isApprovedForAll(tokenOwner, sender));\n  }\n\n  /// @dev Checks if an account is the Creator of a Proton-based NFT or the Contract itself\n  /// @param contractAddress  The Address to the Contract of the Proton-based NFT to check\n  /// @param tokenId          The Token ID of the Proton-based NFT to check\n  /// @param sender           The Address of the Account to check\n  /// @return True if the account is the creator of the NFT or the Contract itself\n  function isNFTContractOrCreator(address contractAddress, uint256 tokenId, address sender) external virtual override returns (bool) {\n    address tokenCreator = _getTokenCreator(contractAddress, tokenId);\n    return (sender == tokenCreator || sender == contractAddress);\n  }\n\n\n\n  function _getTokenCreator(address contractAddress, uint256 tokenId) internal returns (address) {\n    bytes4 fnSig = IERC721Chargeable.creatorOf.selector;\n    if (_remappedFnSigs[contractAddress].creatorOf != bytes4(0)) {\n      fnSig = _remappedFnSigs[contractAddress].creatorOf;\n    }\n\n    // solhint-disable-next-line\n    (bool success, bytes memory returnData) = contractAddress.call(abi.encodeWithSelector(fnSig, tokenId));\n    if (success) {\n      return abi.decode(returnData, (address));\n    } else {\n      return address(0x0);\n    }\n  }\n\n  function _getTokenOwner(address contractAddress, uint256 tokenId) internal returns (address) {\n    bytes4 fnSig = IERC721Chargeable.ownerOf.selector;\n    if (_remappedFnSigs[contractAddress].ownerOf != bytes4(0)) {\n      fnSig = _remappedFnSigs[contractAddress].ownerOf;\n    }\n\n    // solhint-disable-next-line\n    (bool success, bytes memory returnData) = contractAddress.call(abi.encodeWithSelector(fnSig, tokenId));\n    if (success) {\n      return abi.decode(returnData, (address));\n    } else {\n      return address(0x0);\n    }\n  }\n}\n"
    },
    "contracts/v1/lib/WalletManagerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// WalletManagerBase.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../interfaces/IWalletManager.sol\";\nimport \"../interfaces/ISmartWallet.sol\";\nimport \"../lib/TokenInfo.sol\";\nimport \"./BlackholePrevention.sol\";\n\n\n/**\n * @notice Wallet-Manager Base Contract\n * @dev Non-upgradeable Contract\n */\nabstract contract WalletManagerBase is Ownable, BlackholePrevention, IWalletManager {\n  using TokenInfo for address;\n\n  // The Controller Contract Address\n  address internal _controller;\n\n  // The Executor Contract Address\n  address internal _executor;\n\n  // Template Contract for creating Token Smart-Wallet Bridges\n  address internal _walletTemplate;\n\n  //       TokenID => Token Smart-Wallet Address\n  mapping (uint256 => address) internal _wallets;\n\n  // State of Wallet Manager\n  bool internal _paused;\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isPaused() external view override returns (bool) {\n    return _paused;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /**\n    * @dev Sets the Paused-state of the Wallet Manager\n    */\n  function setPausedState(bool paused) external onlyOwner {\n    _paused = paused;\n    emit PausedStateSet(paused);\n  }\n\n  /**\n    * @dev Connects to the Charged Particles Controller\n    */\n  function setController(address controller) external onlyOwner {\n    _controller = controller;\n    emit ControllerSet(controller);\n  }\n\n  /**\n    * @dev Connects to the ExecForAccount Controller\n    */\n  function setExecutor(address executor) external onlyOwner {\n    _executor = executor;\n    emit ExecutorSet(executor);\n  }\n\n  function withdrawEther(address contractAddress, uint256 tokenId, address payable receiver, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    _withdrawEther(receiver, amount);\n    return ISmartWallet(wallet).withdrawEther(receiver, amount);\n  }\n\n  function withdrawERC20(address contractAddress, uint256 tokenId, address payable receiver, address tokenAddress, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    _withdrawERC20(receiver, tokenAddress, amount);\n    return ISmartWallet(wallet).withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    _withdrawERC721(receiver, nftTokenAddress, nftTokenId);\n    return ISmartWallet(wallet).withdrawERC721(receiver, nftTokenAddress, nftTokenId);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _getTokenUUID(address contractAddress, uint256 tokenId) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(contractAddress, tokenId)));\n  }\n\n  /**\n    * @dev Creates Contracts from a Template via Cloning\n    * see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n    */\n  function _createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  /// @dev Throws if called by any account other than the Controller contract\n  modifier onlyController() {\n    require(_controller == msg.sender, \"WMB:E-108\");\n    _;\n  }\n\n  /// @dev Throws if called by any account other than the Executor contract\n  modifier onlyExecutor() {\n    require(_executor == msg.sender, \"WMB:E-108\");\n    _;\n  }\n\n  /// @dev Throws if called by any account other than the Controller or Executor contract\n  modifier onlyControllerOrExecutor() {\n    require(_executor == msg.sender || _controller == msg.sender, \"WMB:E-108\");\n    _;\n  }\n\n  // Throws if called by any account other than the Charged Particles Escrow Controller.\n  modifier whenNotPaused() {\n    require(_paused != true, \"WMB:E-101\");\n    _;\n  }\n\n}\n"
    },
    "contracts/v1/ParticleSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ParticleSplitter.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/IParticleSplitter.sol\";\nimport \"./interfaces/IChargedManagers.sol\";\nimport \"./interfaces/IWalletManager.sol\";\nimport \"./interfaces/IBasketManager.sol\";\nimport \"./interfaces/ITokenInfoProxy.sol\";\nimport \"./lib/BlackholePrevention.sol\";\n\n/**\n * @notice Charged Particles Contract\n * @dev Upgradeable Contract\n */\ncontract ParticleSplitter is IParticleSplitter, Ownable, ReentrancyGuard, BlackholePrevention\n{\n  IChargedManagers internal _chargedManagers;\n  ITokenInfoProxy internal _tokenInfoProxy;\n\n  mapping (address => bool) internal _externalAddressesAllowed;\n\n\n  /***********************************|\n  |        Execute for Account        |\n  |__________________________________*/\n\n  /// @notice Executes an arbitrary command on an NFT Wallet\n  /// @param contractAddress      The Address to the Contract of the Token\n  /// @param tokenId              The ID of the Token\n  /// @param walletManagerId      The Wallet Manager controlling the NFT Wallet to execute on\n  /// @param externalAddress      The Address of the External Contract to execute on\n  /// @param encodedParams        The encoded function call to execute\n  function executeForWallet(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address externalAddress,\n    bytes memory encodedParams\n  )\n    external\n    payable\n    virtual\n    override\n    onlyTokenOwner(contractAddress, tokenId)\n    nonReentrant\n    returns (bytes memory)\n  {\n    require(_chargedManagers.isWalletManagerEnabled(walletManagerId), \"PS:E-419\");\n    require(_externalAddressesAllowed[externalAddress], \"PS:E-117\");\n\n    // Validate Owner/Operator & Timelocks\n    _chargedManagers.validateRelease(msg.sender, contractAddress, tokenId);\n\n    // Get appropriate Wallet Manager\n    IWalletManager walletMgr = _chargedManagers.getWalletManager(walletManagerId);\n\n    // Get Address of Wallet to send any ETH into\n    if (msg.value > 0) {\n      address wallet = walletMgr.getWalletAddressById(contractAddress, tokenId, address(0), 0);\n      payable(wallet).sendValue(msg.value);\n    }\n\n    emit ExecuteForWallet(contractAddress, tokenId, walletManagerId, externalAddress, encodedParams, msg.value);\n\n    // Execute command for NFT Wallet\n    return walletMgr.executeForAccount(contractAddress, tokenId, externalAddress, msg.value, encodedParams);\n  }\n\n  /// @notice Executes an arbitrary command on an NFT Basket\n  /// @param contractAddress      The Address to the Contract of the Token\n  /// @param tokenId              The ID of the Token\n  /// @param basketManagerId      The Basket Manager controlling the NFT Wallet to execute on\n  /// @param externalAddress      The Address of the External Contract to execute on\n  /// @param encodedParams        The encoded function call to execute\n  function executeForBasket(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address externalAddress,\n    bytes memory encodedParams\n  )\n    external\n    payable\n    virtual\n    override\n    onlyTokenOwner(contractAddress, tokenId)\n    nonReentrant\n    returns (bytes memory)\n  {\n    require(_chargedManagers.isNftBasketEnabled(basketManagerId), \"PS:E-419\");\n    require(_externalAddressesAllowed[externalAddress], \"PS:E-117\");\n\n    // Validate Owner/Operator & Timelocks\n    _chargedManagers.validateRelease(msg.sender, contractAddress, tokenId);\n\n    // Get appropriate Basket Manager\n    IBasketManager basketMgr = _chargedManagers.getBasketManager(basketManagerId);\n\n    // Get Address of Wallet to send any ETH into\n    if (msg.value > 0) {\n      address wallet = basketMgr.getBasketAddressById(contractAddress, tokenId);\n      payable(wallet).sendValue(msg.value);\n    }\n\n    emit ExecuteForBasket(contractAddress, tokenId, basketManagerId, externalAddress, encodedParams, msg.value);\n\n    // Execute command for NFT Wallet\n    return basketMgr.executeForAccount(contractAddress, tokenId, externalAddress, msg.value, encodedParams);\n  }\n\n  function withdrawWalletRewards(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address rewardsToken,\n    uint256 rewardsAmount\n  )\n    external\n    virtual\n    override\n    onlyTokenOwner(contractAddress, tokenId)\n    nonReentrant\n    returns (uint256 amountWithdrawn)\n  {\n    require(_chargedManagers.isWalletManagerEnabled(walletManagerId), \"PS:E-419\");\n\n    // Validate Owner/Operator & Timelocks\n    _chargedManagers.validateRelease(msg.sender, contractAddress, tokenId);\n\n    // Get appropriate Wallet Manager\n    IWalletManager walletMgr = _chargedManagers.getWalletManager(walletManagerId);\n\n    // Withdraw Rewards for NFT Wallet\n    return walletMgr.withdrawRewards(receiver, contractAddress, tokenId, rewardsToken, rewardsAmount);\n  }\n\n  function withdrawBasketRewards(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata basketManagerId,\n    address rewardsToken,\n    uint256 rewardsAmount\n  )\n    external\n    virtual\n    override\n    onlyTokenOwner(contractAddress, tokenId)\n    nonReentrant\n    returns (uint256 amountWithdrawn)\n  {\n    require(_chargedManagers.isNftBasketEnabled(basketManagerId), \"PS:E-419\");\n\n    // Validate Owner/Operator & Timelocks\n    _chargedManagers.validateRelease(msg.sender, contractAddress, tokenId);\n\n    // Get appropriate Basket Manager\n    IBasketManager basketMgr = _chargedManagers.getBasketManager(basketManagerId);\n\n    // Withdraw Rewards for NFT Basket\n    return basketMgr.withdrawRewards(receiver, contractAddress, tokenId, rewardsToken, rewardsAmount);\n  }\n\n  function refreshWalletPrincipal(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken\n  )\n    external\n    virtual\n    override\n  {\n    require(_chargedManagers.isWalletManagerEnabled(walletManagerId), \"PS:E-419\");\n\n    IWalletManager walletMgr = _chargedManagers.getWalletManager(walletManagerId);\n    walletMgr.refreshPrincipal(contractAddress, tokenId, assetToken);\n\n    emit PrincipalRefreshed(contractAddress, tokenId, walletManagerId, assetToken);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /**\n    * @dev Setup the ChargedManagers Interface\n    */\n  function setChargedManagers(address chargedManagers) external virtual onlyOwner {\n    _chargedManagers = IChargedManagers(chargedManagers);\n    emit ChargedManagersSet(chargedManagers);\n  }\n\n  /**\n    * @dev Setup the ChargedManagers Interface\n    */\n  function setTokenInfoProxy(address tokenInfoProxy) external virtual onlyOwner {\n    _tokenInfoProxy = ITokenInfoProxy(tokenInfoProxy);\n    emit TokenInfoProxySet(tokenInfoProxy);\n  }\n\n  /**\n    * @dev Allows/Disallows execute from on specific contracts\n    */\n  function setExternalContracts(address[] calldata contracts, bool state) external onlyOwner {\n    uint count = contracts.length;\n    for (uint i; i < count; i++) {\n      address externalContract = contracts[i];\n      _externalAddressesAllowed[externalContract] = state;\n      emit PermsSetForExternal(externalContract, state);\n    }\n  }\n\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier onlyTokenOwner(address contractAddress, uint256 tokenId) {\n    address tokenOwner = _tokenInfoProxy.getTokenOwner(contractAddress, tokenId);\n    require(msg.sender == tokenOwner, \"PS:E-102\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/test/Dai.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"../interfaces/IDai.sol\";\n\ncontract Dai is IDai {\n  using SafeMathUpgradeable for uint256;\n  using AddressUpgradeable for address;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  /**\n    * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n    * a default value of 18.\n    *\n    * To select a different value for {decimals}, use {_setupDecimals}.\n    *\n    * All three of these values are immutable: they can only be set once during\n    * construction.\n    */\n  constructor (uint256 chainId_) public {\n    string memory version = \"1\";\n\n    _name = \"Dai Stablecoin\";\n    _symbol = \"DAI\";\n    _decimals = 18;\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(bytes(_name)),\n        keccak256(bytes(version)),\n        chainId_,\n        address(this)\n      )\n    );\n  }\n\n  /**\n    * @dev Returns the name of the token.\n    */\n  function name() public view returns (string memory) {\n      return _name;\n  }\n\n  /**\n    * @dev Returns the symbol of the token, usually a shorter version of the\n    * name.\n    */\n  function symbol() public view returns (string memory) {\n      return _symbol;\n  }\n\n  /**\n    * @dev Returns the number of decimals used to get its user representation.\n    * For example, if `decimals` equals `2`, a balance of `505` tokens should\n    * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n    *\n    * Tokens usually opt for a value of 18, imitating the relationship between\n    * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n    * called.\n    *\n    * NOTE: This information is only used for _display_ purposes: it in\n    * no way affects any of the arithmetic of the contract, including\n    * {IERC20-balanceOf} and {IERC20-transfer}.\n    */\n  function decimals() public view returns (uint8) {\n      return _decimals;\n  }\n\n  /**\n    * @dev See {IERC20-totalSupply}.\n    */\n  function totalSupply() public view override returns (uint256) {\n      return _totalSupply;\n  }\n\n  /**\n    * @dev See {IERC20-balanceOf}.\n    */\n  function balanceOf(address account) public view override returns (uint256) {\n      return _balances[account];\n  }\n\n  /**\n    * @dev See {IERC20-transfer}.\n    *\n    * Requirements:\n    *\n    * - `recipient` cannot be the zero address.\n    * - the caller must have a balance of at least `amount`.\n    */\n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      return true;\n  }\n\n  /**\n    * @dev See {IERC20-allowance}.\n    */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n      return _allowances[owner][spender];\n  }\n\n  /**\n    * @dev See {IERC20-approve}.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n      _approve(msg.sender, spender, amount);\n      return true;\n  }\n\n  /**\n    * @dev See {IERC20-transferFrom}.\n    *\n    * Emits an {Approval} event indicating the updated allowance. This is not\n    * required by the EIP. See the note at the beginning of {ERC20};\n    *\n    * Requirements:\n    * - `sender` and `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    * - the caller must have allowance for ``sender``'s tokens of at least\n    * `amount`.\n    */\n  function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n      _transfer(sender, recipient, amount);\n      _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n      return true;\n  }\n\n  /**\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n      _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n      return true;\n  }\n\n  /**\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    * - `spender` must have allowance for the caller of at least\n    * `subtractedValue`.\n    */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n      _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n      return true;\n  }\n\n  /**\n    * @dev Moves tokens `amount` from `sender` to `recipient`.\n    *\n    * This is internal function is equivalent to {transfer}, and can be used to\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\n    *\n    * Emits a {Transfer} event.\n    *\n    * Requirements:\n    *\n    * - `sender` cannot be the zero address.\n    * - `recipient` cannot be the zero address.\n    * - `sender` must have a balance of at least `amount`.\n    */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n      require(sender != address(0), \"ERC20:E-403\");\n      require(recipient != address(0), \"ERC20:E-403\");\n\n      _beforeTokenTransfer(sender, recipient, amount);\n\n      _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n      _balances[recipient] = _balances[recipient].add(amount);\n      emit Transfer(sender, recipient, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n    * the total supply.\n    *\n    * Emits a {Transfer} event with `from` set to the zero address.\n    *\n    * Requirements\n    *\n    * - `to` cannot be the zero address.\n    */\n  function _mint(address account, uint256 amount) internal virtual {\n      require(account != address(0), \"ERC20:E-403\");\n\n      _beforeTokenTransfer(address(0), account, amount);\n\n      _totalSupply = _totalSupply.add(amount);\n      _balances[account] = _balances[account].add(amount);\n      emit Transfer(address(0), account, amount);\n  }\n\n  /**\n    * @dev Destroys `amount` tokens from `account`, reducing the\n    * total supply.\n    *\n    * Emits a {Transfer} event with `to` set to the zero address.\n    *\n    * Requirements\n    *\n    * - `account` cannot be the zero address.\n    * - `account` must have at least `amount` tokens.\n    */\n  function _burn(address account, uint256 amount) internal virtual {\n      require(account != address(0), \"ERC20:E-403\");\n\n      _beforeTokenTransfer(account, address(0), amount);\n\n      _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n      _totalSupply = _totalSupply.sub(amount);\n      emit Transfer(account, address(0), amount);\n  }\n\n  /**\n    * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n    *\n    * This internal function is equivalent to `approve`, and can be used to\n    * e.g. set automatic allowances for certain subsystems, etc.\n    *\n    * Emits an {Approval} event.\n    *\n    * Requirements:\n    *\n    * - `owner` cannot be the zero address.\n    * - `spender` cannot be the zero address.\n    */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n      require(owner != address(0), \"ERC20:E-403\");\n      require(spender != address(0), \"ERC20:E-403\");\n\n      _allowances[owner][spender] = amount;\n      emit Approval(owner, spender, amount);\n  }\n\n  /**\n    * @dev Sets {decimals} to a value other than the default one of 18.\n    *\n    * WARNING: This function should only be called from the constructor. Most\n    * applications that interact with token contracts will not expect\n    * {decimals} to ever change, and may work incorrectly if it does.\n    */\n  function _setupDecimals(uint8 decimals_) internal {\n      _decimals = decimals_;\n  }\n\n  /**\n    * @dev Hook that is called before any transfer of tokens. This includes\n    * minting and burning.\n    *\n    * Calling conditions:\n    *\n    * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n    * will be to transferred to `to`.\n    * - when `from` is zero, `amount` tokens will be minted for `to`.\n    * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n    * - `from` and `to` are never both zero.\n    *\n    * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n    */\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n  mapping (address => uint)                      public nonces;\n\n  // --- EIP712 niceties ---\n  bytes32 public DOMAIN_SEPARATOR;\n  // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n  bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n  // --- Approve by signature ---\n  function permit(\n    address holder, address spender, uint256 nonce, uint256 expiry,\n    bool allowed, uint8 v, bytes32 r, bytes32 s) external override\n  {\n    bytes32 digest = keccak256(\n      abi.encodePacked(\n        \"\\x19\\x01\",\n        DOMAIN_SEPARATOR,\n        keccak256(\n          abi.encode(\n            PERMIT_TYPEHASH,\n            holder,\n            spender,\n            nonce,\n            expiry,\n            allowed\n          )\n        )\n      )\n    );\n\n    require(holder != address(0), \"Dai/invalid-address-0\");\n    require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\n    require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\n    require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\n    uint wad = allowed ? uint(-1) : 0;\n    _allowances[holder][spender] = wad;\n    emit Approval(holder, spender, wad);\n  }\n\n  function mint(address to, uint256 amount) external {\n    _mint(to, amount);\n  }\n}"
    },
    "contracts/v1/test/ERC20Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a set of accounts with the {MinterRole},\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20Upgradeable {\n\n    constructor(string memory _name, string memory _symbol) public {\n        __ERC20_init(_name, _symbol);\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the {MinterRole}.\n     */\n    function mint(address account, uint256 amount) public returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n\n    function burn(address account, uint256 amount) public returns (bool) {\n        _burn(account, amount);\n        return true;\n    }\n}"
    },
    "contracts/v1/test/ERC721Mintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\n/**\n * @dev Extension of {ERC721} for Minting/Burning\n */\ncontract ERC721Mintable is ERC721Upgradeable {\n\n    constructor () public {\n        __ERC721_init(\"ERC 721\", \"NFT\");\n    }\n\n    /**\n     * @dev See {ERC721-_mint}.\n     */\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n\n    /**\n     * @dev See {ERC721-_burn}.\n     */\n    function burn(uint256 tokenId) public {\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/v1/tokens/ExternalERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ExternalERC721.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract ExternalERC721 is ERC721 {\n  using Counters for Counters.Counter;\n\n  Counters.Counter internal _tokenCount;\n\n  constructor() public ERC721(\"Charged Particles - ExternalERC721\", \"ExNFT\") {}\n\n  function mintNft(address receiver, string memory tokenUri) external returns (uint256 newTokenId) {\n    return _mintNft(receiver, tokenUri);\n  }\n\n  function _mintNft(address receiver, string memory tokenUri) internal returns (uint256 newTokenId) {\n    _tokenCount.increment();\n    newTokenId = _tokenCount.current();\n\n    _safeMint(receiver, newTokenId, \"\");\n\n    _setTokenURI(newTokenId, tokenUri);\n  }\n}\n"
    },
    "contracts/v1/tokens/FungibleERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// FungibleERC1155.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract FungibleERC1155 is ERC1155 {\n  using Counters for Counters.Counter;\n\n  Counters.Counter internal _tokenCount;\n\n  constructor() public ERC1155(\"https://staging.app.charged.fi/erc1155/metadata.json\") {}\n\n  function mintNft(address receiver, uint256 amount) external returns (uint256 newTokenId) {\n    return _mintNft(receiver, amount);\n  }\n\n  function _mintNft(address receiver, uint256 amount) internal returns (uint256 newTokenId) {\n    _tokenCount.increment();\n    newTokenId = _tokenCount.current();\n    _mint(receiver, newTokenId, amount, \"\");\n  }\n}\n"
    },
    "contracts/v1/tokens/Ionx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Ionx.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"erc20permit/contracts/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\n\ncontract Ionx is ERC20Permit, Ownable, BlackholePrevention {\n  using SafeMath for uint256;\n\n  /// @notice An event thats emitted when the minter address is changed\n  event MinterChanged(address minter, address newMinter);\n\n  /// @notice Total number of tokens in circulation\n  uint256 constant public INITIAL_SUPPLY = 1e8 ether;\n\n  /// @notice Minimum time between mints\n  uint32 public constant INFLATION_EPOCH = 1 days * 365;\n\n  /// @notice Cap on the percentage of totalSupply that can be minted at each mint\n  uint8 public constant INFLATION_CAP = 2;\n\n  /// @notice Address which may mint new tokens\n  address public minter;\n\n  /// @notice The timestamp after which minting may occur\n  uint256 public mintingAllowedAfter;\n\n\n  constructor() public ERC20Permit(\"Charged Particles - IONX\", \"IONX\") {}\n\n\n  /**\n    * @notice Change the minter address\n    * @param newMinter The address of the new minter\n    */\n  function setMinter(address newMinter) external onlyOwner {\n    emit MinterChanged(minter, newMinter);\n    minter = newMinter;\n  }\n\n  /**\n    * @notice Mint new tokens\n    * @param receiver The address of the destination account\n    * @param amount The number of tokens to be minted\n    */\n  function mint(address receiver, uint256 amount) external onlyMinter {\n    require(block.timestamp >= mintingAllowedAfter, \"Ionx:E-114\");\n    require(receiver != address(0), \"Ionx:E-403\");\n\n    uint256 amountToMint = amount;\n    uint256 _totalSupply = totalSupply();\n\n    // From Inflationary Supply\n    if (_totalSupply >= INITIAL_SUPPLY) {\n      mintingAllowedAfter = mintingAllowedAfter.add(INFLATION_EPOCH);\n      amountToMint = _totalSupply.mul(INFLATION_CAP).div(100);\n    }\n\n    // From Initial Supply\n    else {\n      if (_totalSupply.add(amountToMint) > INITIAL_SUPPLY) {\n        amountToMint = INITIAL_SUPPLY.sub(_totalSupply);\n      }\n      if (_totalSupply.add(amountToMint) == INITIAL_SUPPLY) {\n        mintingAllowedAfter = block.timestamp.add(INFLATION_EPOCH);\n      }\n    }\n\n    // transfer the amount to the recipient\n    _mint(receiver, amountToMint);\n  }\n\n  // Note: This contract should never hold ETH, if any is accidentally sent in then the DAO can return it\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  // Note: This contract should never hold any tokens, if any are accidentally sent in then the DAO can return them\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  modifier onlyMinter() {\n    require(msg.sender == minter, \"Ionx:E-113\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/tokens/Lepton.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Lepton.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"../lib/ERC721.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/ILepton.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\n\ncontract Lepton is ILepton, ERC721, Ownable, ReentrancyGuard, BlackholePrevention {\n  using SafeMath for uint256;\n  using Address for address payable;\n  using Counters for Counters.Counter;\n\n  Counters.Counter internal _tokenIds;\n  Classification[] internal _leptonTypes;\n  mapping (uint256 => Classification) internal _leptonData;\n\n  uint256 internal _typeIndex;\n  uint256 internal _maxSupply;\n  uint256 internal _maxMintPerTx;\n  bool internal _paused;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor() public ERC721(\"Charged Particles - Lepton\", \"LEPTON\") {\n    _paused = true;\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function mintLepton() external payable virtual override nonReentrant whenNotPaused returns (uint256 newTokenId) {\n    newTokenId = _mintLepton(msg.sender);\n  }\n\n  function batchMintLepton(uint256 count) external payable virtual override nonReentrant whenNotPaused {\n    _batchMintLepton(msg.sender, count);\n  }\n\n  function getNextType() external view virtual override returns (uint256) {\n    if (_typeIndex >= _leptonTypes.length) { return 0; }\n    return _typeIndex;\n  }\n\n  function getNextPrice() external view virtual override returns (uint256) {\n    if (_typeIndex >= _leptonTypes.length) { return 0; }\n    return _leptonTypes[_typeIndex].price;\n  }\n\n  function getMultiplier(uint256 tokenId) external view virtual override returns (uint256) {\n    return _leptonData[tokenId].multiplier;\n  }\n\n  function getBonus(uint256 tokenId) external view virtual override returns (uint256) {\n    return _leptonData[tokenId].bonus;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function addLeptonType(\n    string calldata tokenUri,\n    uint256 price,\n    uint32 supply,\n    uint32 multiplier,\n    uint32 bonus\n  )\n    external\n    virtual\n    onlyOwner\n  {\n    _maxSupply = _maxSupply.add(uint256(supply));\n\n    Classification memory lepton = Classification({\n      tokenUri: tokenUri,\n      price: price,\n      supply: supply,\n      multiplier: multiplier,\n      bonus: bonus,\n      _upperBounds: uint128(_maxSupply)\n    });\n    _leptonTypes.push(lepton);\n\n    emit LeptonTypeAdded(tokenUri, price, supply, multiplier, bonus, _maxSupply);\n  }\n\n  function updateLeptonType(\n    uint256 leptonIndex,\n    string calldata tokenUri,\n    uint256 price,\n    uint32 supply,\n    uint32 multiplier,\n    uint32 bonus\n  )\n    external\n    virtual\n    onlyOwner\n  {\n    _leptonTypes[leptonIndex].tokenUri = tokenUri;\n    _leptonTypes[leptonIndex].price = price;\n    _leptonTypes[leptonIndex].supply = supply;\n    _leptonTypes[leptonIndex].multiplier = multiplier;\n    _leptonTypes[leptonIndex].bonus = bonus;\n\n    emit LeptonTypeUpdated(leptonIndex, tokenUri, price, supply, multiplier, bonus, _maxSupply);\n  }\n\n  function setMaxMintPerTx(uint256 maxAmount) external virtual  onlyOwner {\n    _maxMintPerTx = maxAmount;\n    emit MaxMintPerTxSet(maxAmount);\n  }\n\n  function setPausedState(bool state) external virtual  onlyOwner {\n    _paused = state;\n    emit PausedStateSet(state);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _mintLepton(address receiver) internal virtual returns (uint256 newTokenId) {\n    require(_typeIndex < _leptonTypes.length, \"LPT:E-408\");\n\n    Classification memory lepton = _leptonTypes[_typeIndex];\n    require(msg.value >= lepton.price, \"LPT:E-414\");\n\n    _tokenIds.increment();\n    newTokenId = _tokenIds.current();\n\n    _leptonData[newTokenId] = lepton;\n    _safeMint(receiver, newTokenId, \"\");\n    _setTokenURI(newTokenId, lepton.tokenUri);\n\n    // Distribute Next Type\n    if (newTokenId == lepton._upperBounds) {\n      _typeIndex = _typeIndex.add(1);\n    }\n\n    emit LeptonMinted(receiver, newTokenId, lepton.price, lepton.multiplier);\n\n    _refundOverpayment(lepton.price);\n  }\n\n\n  function _batchMintLepton(address receiver, uint256 count) internal virtual {\n    require(_typeIndex < _leptonTypes.length, \"LPT:E-408\");\n    require(_maxMintPerTx == 0 || count <= _maxMintPerTx, \"LPT:E-429\");\n\n    Classification memory lepton = _leptonTypes[_typeIndex];\n\n    uint256 startTokenId = _tokenIds.current();\n    uint256 endTokenId = startTokenId.add(count);\n    if (endTokenId > lepton._upperBounds) {\n      count = count.sub(endTokenId.sub(lepton._upperBounds));\n    }\n\n    uint256 salePrice = lepton.price.mul(count);\n    require(msg.value >= salePrice, \"LPT:E-414\");\n\n    _safeMintBatch(receiver, startTokenId.add(1), count, \"\");\n\n    for (uint i = 0; i < count; i++) {\n      _tokenIds.increment();\n      startTokenId = _tokenIds.current();\n\n      _leptonData[startTokenId] = lepton;\n      _setTokenURI(startTokenId, lepton.tokenUri);\n    }\n\n    // Distribute Next Type\n    if (startTokenId >= lepton._upperBounds) {\n      _typeIndex = _typeIndex.add(1);\n    }\n\n    emit LeptonBatchMinted(receiver, startTokenId, count, lepton.price, lepton.multiplier);\n\n    _refundOverpayment(salePrice);\n  }\n\n  function _refundOverpayment(uint256 threshold) internal virtual {\n    uint256 overage = msg.value.sub(threshold);\n    if (overage > 0) {\n      payable(_msgSender()).sendValue(overage);\n    }\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier whenNotPaused() {\n      require(!_paused, \"LPT:E-101\");\n      _;\n  }\n}"
    },
    "contracts/v1/tokens/Lepton2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Lepton2.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"../lib/ERC721Basic.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\";\n\nimport \"../interfaces/ILepton.sol\";\nimport \"../lib/BlackholePrevention.sol\";\n\ncontract Lepton2 is ILepton, ERC721Basic, Ownable, ReentrancyGuard, BlackholePrevention {\n  using SafeMath for uint256;\n  using Address for address payable;\n\n  Classification[] internal _leptonTypes;\n\n  uint256 internal _typeIndex;\n  uint256 internal _maxSupply;\n  uint256 internal _maxMintPerTx;\n  uint256 internal _migratedCount;\n\n  bool internal _paused;\n  bool internal _migrationComplete;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor() public ERC721Basic(\"Charged Particles - Lepton2\", \"LEPTON2\") {\n    _paused = true;\n    _migrationComplete = false;\n    _migratedCount = 0;\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function mintLepton() external payable override nonReentrant whenNotPaused returns (uint256 newTokenId) {\n    newTokenId = _mintLepton(msg.sender);\n  }\n\n  function batchMintLepton(uint256 count) external payable override nonReentrant whenNotPaused {\n    _batchMintLepton(msg.sender, count);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _tokenCount;\n  }\n\n  function maxSupply() external view returns (uint256) {\n    return _maxSupply;\n  }\n\n  function getNextType() external view override returns (uint256) {\n    if (_typeIndex >= _leptonTypes.length) { return 0; }\n    return _typeIndex;\n  }\n\n  function getNextPrice() external view override returns (uint256) {\n    if (_typeIndex >= _leptonTypes.length) { return 0; }\n    return _leptonTypes[_typeIndex].price;\n  }\n\n  function getMultiplier(uint256 tokenId) external view override returns (uint256) {\n    require(_exists(tokenId), \"LPT:E-405\");\n    return _getLepton(tokenId).multiplier;\n  }\n\n  function getBonus(uint256 tokenId) external view override returns (uint256) {\n    require(_exists(tokenId), \"LPT:E-405\");\n    return _getLepton(tokenId).bonus;\n  }\n\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    require(_exists(tokenId), \"LPT:E-405\");\n    return _getLepton(tokenId).tokenUri;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function addLeptonType(\n    string calldata tokenUri,\n    uint256 price,\n    uint32 supply,\n    uint32 multiplier,\n    uint32 bonus\n  )\n    external\n    onlyOwner\n  {\n    _maxSupply = _maxSupply.add(uint256(supply));\n\n    Classification memory lepton = Classification({\n      tokenUri: tokenUri,\n      price: price,\n      supply: supply,\n      multiplier: multiplier,\n      bonus: bonus,\n      _upperBounds: uint128(_maxSupply)\n    });\n    _leptonTypes.push(lepton);\n\n    emit LeptonTypeAdded(tokenUri, price, supply, multiplier, bonus, _maxSupply);\n  }\n\n  function updateLeptonType(\n    uint256 leptonIndex,\n    string calldata tokenUri,\n    uint256 price,\n    uint32 supply,\n    uint32 multiplier,\n    uint32 bonus\n  )\n    external\n    onlyOwner\n  {\n    _leptonTypes[leptonIndex].tokenUri = tokenUri;\n    _leptonTypes[leptonIndex].price = price;\n    _leptonTypes[leptonIndex].supply = supply;\n    _leptonTypes[leptonIndex].multiplier = multiplier;\n    _leptonTypes[leptonIndex].bonus = bonus;\n\n    emit LeptonTypeUpdated(leptonIndex, tokenUri, price, supply, multiplier, bonus, _maxSupply);\n  }\n\n  function setMaxMintPerTx(uint256 maxAmount) external onlyOwner {\n    _maxMintPerTx = maxAmount;\n    emit MaxMintPerTxSet(maxAmount);\n  }\n\n  function setPausedState(bool state) external onlyOwner {\n    _paused = state;\n    emit PausedStateSet(state);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function migrateAccounts(address oldLeptonContract, uint256 count) external onlyOwner whenNotMigrated {\n    uint256 oldSupply = IERC721Enumerable(oldLeptonContract).totalSupply();\n    require(oldSupply == 0 || oldSupply > _migratedCount, \"LPT:E-004\");\n\n    if (oldSupply > 0) {\n      uint256 endTokenId = _migratedCount.add(count);\n      if (endTokenId > oldSupply) {\n        count = count.sub(endTokenId.sub(oldSupply));\n      }\n\n      for (uint256 i = 1; i <= count; i++) {\n        uint256 tokenId = _migratedCount.add(i);\n        address tokenOwner = IERC721(oldLeptonContract).ownerOf(tokenId);\n        _mint(tokenOwner);\n      }\n      _migratedCount = _migratedCount.add(count);\n    }\n\n    if (oldSupply == _migratedCount) {\n      _finalizeMigration();\n    }\n  }\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _getLepton(uint256 tokenId) internal view returns (Classification memory) {\n    uint256 types = _leptonTypes.length;\n    for (uint256 i = 0; i < types; i++) {\n      Classification memory lepton = _leptonTypes[i];\n      if (tokenId <= lepton._upperBounds) {\n        return lepton;\n      }\n    }\n  }\n\n  function _mintLepton(address receiver) internal returns (uint256 newTokenId) {\n    require(_typeIndex < _leptonTypes.length, \"LPT:E-408\");\n\n    Classification memory lepton = _leptonTypes[_typeIndex];\n    require(msg.value >= lepton.price, \"LPT:E-414\");\n\n    newTokenId = _safeMint(receiver, \"\");\n\n    // Determine Next Type\n    if (newTokenId == lepton._upperBounds) {\n      _typeIndex = _typeIndex.add(1);\n    }\n\n    _refundOverpayment(lepton.price);\n  }\n\n  function _batchMintLepton(address receiver, uint256 count) internal {\n    require(_typeIndex < _leptonTypes.length, \"LPT:E-408\");\n    require(_maxMintPerTx == 0 || count <= _maxMintPerTx, \"LPT:E-429\");\n\n    Classification memory lepton = _leptonTypes[_typeIndex];\n\n    uint256 endTokenId = _tokenCount.add(count);\n    if (endTokenId > lepton._upperBounds) {\n      count = count.sub(endTokenId.sub(lepton._upperBounds));\n    }\n\n    uint256 salePrice = lepton.price.mul(count);\n    require(msg.value >= salePrice, \"LPT:E-414\");\n\n    _safeMintBatch(receiver, count, \"\");\n\n    // Determine Next Type\n    if (endTokenId >= lepton._upperBounds) {\n      _typeIndex = _typeIndex.add(1);\n    }\n\n    _refundOverpayment(salePrice);\n  }\n\n  function _refundOverpayment(uint256 threshold) internal {\n    uint256 overage = msg.value.sub(threshold);\n    if (overage > 0) {\n      payable(_msgSender()).sendValue(overage);\n    }\n  }\n\n  function _finalizeMigration() internal {\n    // Determine Next Type\n    _typeIndex = 0;\n    for (uint256 i = 0; i < _leptonTypes.length; i++) {\n      Classification memory lepton = _leptonTypes[i];\n      if (_migratedCount >= lepton._upperBounds) {\n        _typeIndex = i + 1;\n      }\n    }\n    _migrationComplete = true;\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier whenNotMigrated() {\n    require(!_migrationComplete, \"LPT:E-004\");\n    _;\n  }\n\n  modifier whenNotPaused() {\n    require(!_paused, \"LPT:E-101\");\n    _;\n  }\n}"
    },
    "contracts/v1/tokens/NonFungibleERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// NonFungibleERC1155.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract NonFungibleERC1155 is ERC1155 {\n  using Counters for Counters.Counter;\n\n  Counters.Counter internal _tokenCount;\n  mapping (uint256 => address) internal _tokenCreator;\n  mapping (uint256 => address) internal _tokenOwner;\n\n  constructor() public ERC1155(\"https://staging.app.charged.fi/erc1155/metadata.json\") {}\n\n  function creatorOf(uint256 tokenId) external view returns (address) {\n    return _tokenCreator[tokenId];\n  }\n\n  function ownerOf(uint256 tokenId) external view returns (address) {\n    return _tokenOwner[tokenId];\n  }\n\n  function mintNft(address receiver) external returns (uint256 newTokenId) {\n    return _mintNft(msg.sender, receiver);\n  }\n\n  function _mintNft(address creator, address receiver) internal returns (uint256 newTokenId) {\n    _tokenCount.increment();\n    newTokenId = _tokenCount.current();\n\n    _mint(receiver, newTokenId, 1, \"\");\n    _tokenCreator[newTokenId] = creator;\n    _tokenOwner[newTokenId] = receiver;\n  }\n}\n"
    },
    "contracts/v1/tokens/Proton.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Proton.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../lib/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/IProton.sol\";\nimport \"../interfaces/IUniverse.sol\";\nimport \"../interfaces/IChargedState.sol\";\nimport \"../interfaces/IChargedSettings.sol\";\nimport \"../interfaces/IChargedParticles.sol\";\n\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../lib/RelayRecipient.sol\";\n\n\ncontract Proton is IProton, ERC721, Ownable, RelayRecipient, ReentrancyGuard, BlackholePrevention {\n  using SafeMath for uint256;\n  using Address for address payable;\n  using Counters for Counters.Counter;\n\n  uint256 constant internal PERCENTAGE_SCALE = 1e4;   // 10000  (100%)\n  uint256 constant internal MAX_ROYALTIES = 8e3;      // 8000   (80%)\n\n  IUniverse internal _universe;\n  IChargedState internal _chargedState;\n  IChargedSettings internal _chargedSettings;\n  IChargedParticles internal _chargedParticles;\n\n  Counters.Counter internal _tokenIds;\n\n  mapping (uint256 => address) internal _tokenCreator;\n  mapping (uint256 => uint256) internal _tokenCreatorRoyaltiesPct;\n  mapping (uint256 => address) internal _tokenCreatorRoyaltiesRedirect;\n  mapping (address => uint256) internal _tokenCreatorClaimableRoyalties;\n\n  mapping (uint256 => uint256) internal _tokenSalePrice;\n  mapping (uint256 => uint256) internal _tokenLastSellPrice;\n\n  bool internal _paused;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor() public ERC721(\"Charged Particles - Proton\", \"PROTON\") {}\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function creatorOf(uint256 tokenId) external view virtual override returns (address) {\n    return _tokenCreator[tokenId];\n  }\n\n  function getSalePrice(uint256 tokenId) external view virtual override returns (uint256) {\n    return _tokenSalePrice[tokenId];\n  }\n\n  function getLastSellPrice(uint256 tokenId) external view virtual override returns (uint256) {\n    return _tokenLastSellPrice[tokenId];\n  }\n\n  function getCreatorRoyalties(address account) external view virtual override returns (uint256) {\n    return _tokenCreatorClaimableRoyalties[account];\n  }\n\n  function getCreatorRoyaltiesPct(uint256 tokenId) external view virtual override returns (uint256) {\n    return _tokenCreatorRoyaltiesPct[tokenId];\n  }\n\n  function getCreatorRoyaltiesReceiver(uint256 tokenId) external view virtual override returns (address) {\n    return _creatorRoyaltiesReceiver(tokenId);\n  }\n\n  function claimCreatorRoyalties()\n    external\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256)\n  {\n    return _claimCreatorRoyalties(_msgSender());\n  }\n\n  function createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  )\n    external\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createChargedParticle(\n      creator,\n      receiver,\n      referrer,\n      tokenMetaUri,\n      walletManagerId,\n      assetToken,\n      assetAmount,\n      annuityPercent\n    );\n  }\n\n  function createBasicProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri\n  )\n    external\n    virtual\n    override\n    whenNotPaused\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      0, // annuityPercent,\n      0, // royaltiesPercent\n      0  // salePrice\n    );\n  }\n\n  function createProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent\n  )\n    external\n    virtual\n    override\n    whenNotPaused\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      annuityPercent,\n      0, // royaltiesPercent\n      0  // salePrice\n    );\n  }\n\n  function createProtonForSale(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    uint256 salePrice\n  )\n    external\n    virtual\n    override\n    whenNotPaused\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      annuityPercent,\n      royaltiesPercent,\n      salePrice\n    );\n  }\n\n  function batchProtonsForSale(\n    address creator,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    string[] calldata tokenMetaUris,\n    uint256[] calldata salePrices\n  )\n    external\n    virtual\n    override\n    whenNotPaused\n  {\n    _batchProtonsForSale(\n      creator,\n      annuityPercent,\n      royaltiesPercent,\n      tokenMetaUris,\n      salePrices\n    );\n  }\n\n  function buyProton(uint256 tokenId)\n    external\n    payable\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (bool)\n  {\n    return _buyProton(tokenId);\n  }\n\n  /***********************************|\n  |     Only Token Creator/Owner      |\n  |__________________________________*/\n\n  function setSalePrice(uint256 tokenId, uint256 salePrice)\n    external\n    virtual\n    override\n    whenNotPaused\n    onlyTokenOwnerOrApproved(tokenId)\n  {\n    _setSalePrice(tokenId, salePrice);\n  }\n\n  function setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct)\n    external\n    virtual\n    override\n    whenNotPaused\n    onlyTokenCreator(tokenId)\n    onlyTokenOwnerOrApproved(tokenId)\n  {\n    _setRoyaltiesPct(tokenId, royaltiesPct);\n  }\n\n  function setCreatorRoyaltiesReceiver(uint256 tokenId, address receiver)\n    external\n    virtual\n    override\n    whenNotPaused\n    onlyTokenCreator(tokenId)\n  {\n    _tokenCreatorRoyaltiesRedirect[tokenId] = receiver;\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function setPausedState(bool state) external virtual onlyOwner {\n    _paused = state;\n    emit PausedStateSet(state);\n  }\n\n  /**\n    * @dev Setup the ChargedParticles Interface\n    */\n  function setUniverse(address universe) external virtual onlyOwner {\n    _universe = IUniverse(universe);\n    emit UniverseSet(universe);\n  }\n\n  /**\n    * @dev Setup the ChargedParticles Interface\n    */\n  function setChargedParticles(address chargedParticles) external virtual onlyOwner {\n    _chargedParticles = IChargedParticles(chargedParticles);\n    emit ChargedParticlesSet(chargedParticles);\n  }\n\n  /// @dev Setup the Charged-State Controller\n  function setChargedState(address stateController) external virtual onlyOwner {\n    _chargedState = IChargedState(stateController);\n    emit ChargedStateSet(stateController);\n  }\n\n  /// @dev Setup the Charged-Settings Controller\n  function setChargedSettings(address settings) external virtual onlyOwner {\n    _chargedSettings = IChargedSettings(settings);\n    emit ChargedSettingsSet(settings);\n  }\n\n  function setTrustedForwarder(address _trustedForwarder) external virtual onlyOwner {\n    trustedForwarder = _trustedForwarder;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _setSalePrice(uint256 tokenId, uint256 salePrice) internal virtual {\n    // Temp-Lock/Unlock NFT\n    //  prevents front-running the sale and draining the value of the NFT just before sale\n    _chargedState.setTemporaryLock(address(this), tokenId, (salePrice > 0));\n\n    _tokenSalePrice[tokenId] = salePrice;\n    emit SalePriceSet(tokenId, salePrice);\n  }\n\n  function _setRoyaltiesPct(uint256 tokenId, uint256 royaltiesPct) internal virtual {\n    require(royaltiesPct <= MAX_ROYALTIES, \"PRT:E-421\");\n    _tokenCreatorRoyaltiesPct[tokenId] = royaltiesPct;\n    emit CreatorRoyaltiesSet(tokenId, royaltiesPct);\n  }\n\n  function _creatorRoyaltiesReceiver(uint256 tokenId) internal view virtual returns (address) {\n    address receiver = _tokenCreatorRoyaltiesRedirect[tokenId];\n    if (receiver == address(0x0)) {\n      receiver = _tokenCreator[tokenId];\n    }\n    return receiver;\n  }\n\n  function _createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  )\n    internal\n    virtual\n    returns (uint256 newTokenId)\n  {\n    require(address(_chargedParticles) != address(0x0), \"PRT:E-107\");\n\n    newTokenId = _createProton(creator, receiver, tokenMetaUri, annuityPercent, 0, 0);\n\n    _chargeParticle(newTokenId, walletManagerId, assetToken, assetAmount, referrer);\n  }\n\n  function _createProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    uint256 salePrice\n  )\n    internal\n    virtual\n    returns (uint256 newTokenId)\n  {\n    _tokenIds.increment();\n\n    newTokenId = _tokenIds.current();\n    _safeMint(receiver, newTokenId, \"\");\n    _tokenCreator[newTokenId] = creator;\n\n    _setTokenURI(newTokenId, tokenMetaUri);\n\n    if (royaltiesPercent > 0) {\n      _setRoyaltiesPct(newTokenId, royaltiesPercent);\n    }\n\n    if (salePrice > 0) {\n      _setSalePrice(newTokenId, salePrice);\n    }\n\n    if (annuityPercent > 0) {\n      _chargedSettings.setCreatorAnnuities(\n        address(this),\n        newTokenId,\n        creator,\n        annuityPercent\n      );\n    }\n  }\n\n  function _batchProtonsForSale(\n    address creator,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    string[] calldata tokenMetaUris,\n    uint256[] calldata salePrices\n  )\n    internal\n    virtual\n  {\n    require(tokenMetaUris.length == salePrices.length, \"PRT:E-202\");\n    address self = address(this);\n\n    uint256 count = tokenMetaUris.length;\n    for (uint256 i = 0; i < count; i++) {\n      _tokenIds.increment();\n      uint256 newTokenId = _tokenIds.current();\n\n      _safeMint(creator, newTokenId, \"\");\n      _tokenCreator[newTokenId] = creator;\n\n      _setTokenURI(newTokenId, tokenMetaUris[i]);\n\n      if (royaltiesPercent > 0) {\n        _setRoyaltiesPct(newTokenId, royaltiesPercent);\n      }\n\n      uint256 salePrice = salePrices[i];\n      if (salePrice > 0) {\n        _setSalePrice(newTokenId, salePrice);\n      }\n\n      if (annuityPercent > 0) {\n        _chargedSettings.setCreatorAnnuities(\n          self,\n          newTokenId,\n          creator,\n          annuityPercent\n        );\n      }\n    }\n  }\n\n  function _chargeParticle(\n    uint256 tokenId,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    address referrer\n  )\n    internal\n    virtual\n  {\n    _collectAssetToken(_msgSender(), assetToken, assetAmount);\n\n    IERC20(assetToken).approve(address(_chargedParticles), assetAmount);\n\n    _chargedParticles.energizeParticle(\n      address(this),\n      tokenId,\n      walletManagerId,\n      assetToken,\n      assetAmount,\n      referrer\n    );\n  }\n\n  function _buyProton(uint256 tokenId)\n    internal\n    virtual\n    returns (bool)\n  {\n    uint256 salePrice = _tokenSalePrice[tokenId];\n    require(salePrice > 0, \"PRT:E-416\");\n    require(msg.value >= salePrice, \"PRT:E-414\");\n\n    uint256 ownerAmount = salePrice;\n    uint256 creatorAmount;\n    address oldOwner = ownerOf(tokenId);\n    address newOwner = _msgSender();\n\n    // Creator Royalties\n    address royaltiesReceiver = _creatorRoyaltiesReceiver(tokenId);\n    uint256 royaltiesPct = _tokenCreatorRoyaltiesPct[tokenId];\n    uint256 lastSellPrice = _tokenLastSellPrice[tokenId];\n    if (royaltiesPct > 0 && lastSellPrice > 0 && salePrice > lastSellPrice) {\n      creatorAmount = (salePrice - lastSellPrice).mul(royaltiesPct).div(PERCENTAGE_SCALE);\n      ownerAmount = ownerAmount.sub(creatorAmount);\n    }\n    _tokenLastSellPrice[tokenId] = salePrice;\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onProtonSale(address(this), tokenId, oldOwner, newOwner, salePrice, royaltiesReceiver, creatorAmount);\n    }\n\n    // Reserve Royalties for Creator\n    if (creatorAmount > 0) {\n      _tokenCreatorClaimableRoyalties[royaltiesReceiver] = _tokenCreatorClaimableRoyalties[royaltiesReceiver].add(creatorAmount);\n    }\n\n    // Transfer Token\n    _transfer(oldOwner, newOwner, tokenId);\n\n    // Transfer Payment\n    payable(oldOwner).sendValue(ownerAmount);\n\n    emit ProtonSold(tokenId, oldOwner, newOwner, salePrice, royaltiesReceiver, creatorAmount);\n\n    _refundOverpayment(salePrice);\n    return true;\n  }\n\n  /**\n    * @dev Pays out the Creator Royalties of the calling account\n    * @param receiver  The receiver of the claimable royalties\n    * @return          The amount of Creator Royalties claimed\n    */\n  function _claimCreatorRoyalties(address receiver) internal virtual returns (uint256) {\n    uint256 claimableAmount = _tokenCreatorClaimableRoyalties[receiver];\n    require(claimableAmount > 0, \"PRT:E-411\");\n\n    delete _tokenCreatorClaimableRoyalties[receiver];\n    payable(receiver).sendValue(claimableAmount);\n\n    emit RoyaltiesClaimed(receiver, claimableAmount);\n  }\n\n  /**\n    * @dev Collects the Required Asset Token from the users wallet\n    * @param from         The owner address to collect the Assets from\n    * @param assetAmount  The Amount of Asset Tokens to Collect\n    */\n  function _collectAssetToken(address from, address assetToken, uint256 assetAmount) internal virtual {\n    uint256 _userAssetBalance = IERC20(assetToken).balanceOf(from);\n    require(assetAmount <= _userAssetBalance, \"PRT:E-411\");\n    // Be sure to Approve this Contract to transfer your Asset Token\n    require(IERC20(assetToken).transferFrom(from, address(this), assetAmount), \"PRT:E-401\");\n  }\n\n  function _refundOverpayment(uint256 threshold) internal virtual {\n    uint256 overage = msg.value.sub(threshold);\n    if (overage > 0) {\n      payable(_msgSender()).sendValue(overage);\n    }\n  }\n\n  function _transfer(address from, address to, uint256 tokenId) internal virtual override {\n    _tokenSalePrice[tokenId] = 0;\n    _chargedState.setTemporaryLock(address(this), tokenId, false);\n    super._transfer(from, to, tokenId);\n  }\n\n\n  /***********************************|\n  |          GSN/MetaTx Relay         |\n  |__________________________________*/\n\n  /// @dev See {BaseRelayRecipient-_msgSender}.\n  function _msgSender()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, Context)\n    returns (address payable)\n  {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  /// @dev See {BaseRelayRecipient-_msgData}.\n  function _msgData()\n    internal\n    view\n    virtual\n    override(BaseRelayRecipient, Context)\n    returns (bytes memory)\n  {\n    return BaseRelayRecipient._msgData();\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  modifier whenNotPaused() {\n      require(!_paused, \"PRT:E-101\");\n      _;\n  }\n\n  modifier onlyTokenOwnerOrApproved(uint256 tokenId) {\n    require(_isApprovedOrOwner(_msgSender(), tokenId), \"PRT:E-105\");\n    _;\n  }\n\n  modifier onlyTokenCreator(uint256 tokenId) {\n    require(_tokenCreator[tokenId] == _msgSender(), \"PRT:E-104\");\n    _;\n  }\n}"
    },
    "contracts/v1/tokens/ProtonB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ProtonB.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/IUniverse.sol\";\nimport \"../interfaces/IChargedState.sol\";\nimport \"../interfaces/IChargedSettings.sol\";\nimport \"../interfaces/IChargedParticles.sol\";\nimport \"../interfaces/IProtonB.sol\";\n\nimport \"../lib/BaseProton.sol\";\nimport \"../lib/TokenInfo.sol\";\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../lib/RelayRecipient.sol\";\n\n\ncontract ProtonB is BaseProton, IProtonB {\n  using SafeMath for uint256;\n  using TokenInfo for address payable;\n  using Counters for Counters.Counter;\n\n  IUniverse internal _universe;\n  IChargedState internal _chargedState;\n  IChargedSettings internal _chargedSettings;\n  IChargedParticles internal _chargedParticles;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor() public BaseProton(\"Charged Particles - ProtonB\", \"PROTON.B\") {}\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function createProtonForSale(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    uint256 salePrice\n  )\n    external\n    virtual\n    override\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      royaltiesPercent,\n      salePrice\n    );\n\n    if (annuityPercent > 0) {\n      _chargedSettings.setCreatorAnnuities(\n        address(this),\n        newTokenId,\n        creator,\n        annuityPercent\n      );\n    }\n  }\n\n  function createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  )\n    external\n    virtual\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createChargedParticle(\n      creator,\n      receiver,\n      referrer,\n      tokenMetaUri,\n      walletManagerId,\n      assetToken,\n      assetAmount,\n      annuityPercent\n    );\n  }\n\n  /// @dev for backwards compatibility with v1\n  function createBasicProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri\n  )\n    external\n    virtual\n    whenNotPaused\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      0, // royaltiesPercent\n      0  // salePrice\n    );\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /**\n    * @dev Setup the ChargedParticles Interface\n    */\n  function setUniverse(address universe) external virtual onlyOwner {\n    _universe = IUniverse(universe);\n    emit UniverseSet(universe);\n  }\n\n  /**\n    * @dev Setup the ChargedParticles Interface\n    */\n  function setChargedParticles(address chargedParticles) external virtual onlyOwner {\n    _chargedParticles = IChargedParticles(chargedParticles);\n    emit ChargedParticlesSet(chargedParticles);\n  }\n\n  /// @dev Setup the Charged-State Controller\n  function setChargedState(address stateController) external virtual onlyOwner {\n    _chargedState = IChargedState(stateController);\n    emit ChargedStateSet(stateController);\n  }\n\n  /// @dev Setup the Charged-Settings Controller\n  function setChargedSettings(address settings) external virtual onlyOwner {\n    _chargedSettings = IChargedSettings(settings);\n    emit ChargedSettingsSet(settings);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  )\n    internal\n    virtual\n    returns (uint256 newTokenId)\n  {\n    require(address(_chargedParticles) != address(0x0), \"PRT:E-107\");\n\n    newTokenId = _createProton(creator, receiver, tokenMetaUri, 0, 0);\n\n    if (annuityPercent > 0) {\n      _chargedSettings.setCreatorAnnuities(\n        address(this),\n        newTokenId,\n        creator,\n        annuityPercent\n      );\n    }\n\n    _chargeParticle(newTokenId, walletManagerId, assetToken, assetAmount, referrer);\n  }\n\n  function _chargeParticle(\n    uint256 tokenId,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    address referrer\n  )\n    internal\n    virtual\n  {\n    _collectAssetToken(_msgSender(), assetToken, assetAmount);\n\n    IERC20(assetToken).approve(address(_chargedParticles), assetAmount);\n\n    _chargedParticles.energizeParticle(\n      address(this),\n      tokenId,\n      walletManagerId,\n      assetToken,\n      assetAmount,\n      referrer\n    );\n  }\n\n\n  /***********************************|\n  |        Function Overrides         |\n  |__________________________________*/\n\n  function _setSalePrice(uint256 tokenId, uint256 salePrice) internal virtual override {\n    super._setSalePrice(tokenId, salePrice);\n\n    // Temp-Lock/Unlock NFT\n    //  prevents front-running the sale and draining the value of the NFT just before sale\n    _chargedState.setTemporaryLock(address(this), tokenId, (salePrice > 0));\n  }\n\n\n  function _buyProton(uint256 _tokenId, uint256 _gasLimit)\n    internal\n    virtual\n    override\n    returns (\n      address contractAddress,\n      uint256 tokenId,\n      address oldOwner,\n      address newOwner,\n      uint256 salePrice,\n      address royaltiesReceiver,\n      uint256 creatorAmount\n    )\n  {\n    (contractAddress, tokenId, oldOwner, newOwner, salePrice, royaltiesReceiver, creatorAmount) = super._buyProton(_tokenId, _gasLimit);\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onProtonSale(contractAddress, tokenId, oldOwner, newOwner, salePrice, royaltiesReceiver, creatorAmount);\n    }\n  }\n\n\n  function _transfer(address from, address to, uint256 tokenId) internal virtual override {\n    // Unlock NFT\n    _chargedState.setTemporaryLock(address(this), tokenId, false);\n\n    super._transfer(from, to, tokenId);\n  }\n}"
    },
    "contracts/v1/tokens/ProtonC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// ProtonB.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\nimport \"../interfaces/IUniverse.sol\";\nimport \"../interfaces/IChargedState.sol\";\nimport \"../interfaces/IChargedSettings.sol\";\nimport \"../interfaces/IChargedParticles.sol\";\n\nimport \"../lib/BaseProton.sol\";\nimport \"../lib/TokenInfo.sol\";\nimport \"../lib/BlackholePrevention.sol\";\nimport \"../lib/RelayRecipient.sol\";\nimport \"../lib/Soul.sol\";\n\n\ncontract ProtonC is BaseProton, Soul {\n  using SafeMath for uint256;\n  using TokenInfo for address payable;\n  using Counters for Counters.Counter;\n\n  IUniverse internal _universe;\n  IChargedState internal _chargedState;\n  IChargedSettings internal _chargedSettings;\n  IChargedParticles internal _chargedParticles;\n\n  event UniverseSet(address indexed universe);\n  event ChargedStateSet(address indexed chargedState);\n  event ChargedSettingsSet(address indexed chargedSettings);\n  event ChargedParticlesSet(address indexed chargedParticles);\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor() public BaseProton(\"Charged Particles - ProtonC\", \"PROTON.C\") {}\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function createBondedToken(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent\n  )\n    external\n    virtual\n    payable\n    returns (uint256 newTokenId)\n  {\n    uint256 tokenId = createProtonForSale(\n      creator,\n      receiver,\n      tokenMetaUri,\n      annuityPercent,\n      royaltiesPercent,\n      0\n    );\n    lockToken(tokenId);\n\n    return tokenId;\n  }\n\n function createProtonForSale(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri,\n    uint256 annuityPercent,\n    uint256 royaltiesPercent,\n    uint256 salePrice\n  )\n    public \n    virtual\n    payable\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      royaltiesPercent,\n      salePrice\n    );\n\n    if (annuityPercent > 0) {\n      _chargedSettings.setCreatorAnnuities(\n        address(this),\n        newTokenId,\n        creator,\n        annuityPercent\n      );\n    }\n  }\n\n  function createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  )\n    external\n    virtual\n    nonReentrant\n    whenNotPaused\n    payable\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createChargedParticle(\n      creator,\n      receiver,\n      referrer,\n      tokenMetaUri,\n      walletManagerId,\n      assetToken,\n      assetAmount,\n      annuityPercent\n    );\n  }\n\n  /// @dev for backwards compatibility with v1\n  function createBasicProton(\n    address creator,\n    address receiver,\n    string memory tokenMetaUri\n  )\n    external\n    virtual\n    whenNotPaused\n    payable\n    returns (uint256 newTokenId)\n  {\n    newTokenId = _createProton(\n      creator,\n      receiver,\n      tokenMetaUri,\n      0, // royaltiesPercent\n      0  // salePrice\n    );\n  }\n\n  function burn(uint256 tokenId) public {\n    requireTokenOwner(tokenId); \n    _burn(tokenId);\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /**\n    * @dev Setup the ChargedParticles Interface\n    */\n  function setUniverse(address universe) external virtual onlyOwner {\n    _universe = IUniverse(universe);\n    emit UniverseSet(universe);\n  }\n\n  /**\n    * @dev Setup the ChargedParticles Interface\n    */\n  function setChargedParticles(address chargedParticles) external virtual onlyOwner {\n    _chargedParticles = IChargedParticles(chargedParticles);\n    emit ChargedParticlesSet(chargedParticles);\n  }\n\n  /// @dev Setup the Charged-State Controller\n  function setChargedState(address stateController) external virtual onlyOwner {\n    _chargedState = IChargedState(stateController);\n    emit ChargedStateSet(stateController);\n  }\n\n  /// @dev Setup the Charged-Settings Controller\n  function setChargedSettings(address settings) external virtual onlyOwner {\n    _chargedSettings = IChargedSettings(settings);\n    emit ChargedSettingsSet(settings);\n  }\n\n  function requireTokenOwner(uint256 tokenId) public view {\n    require(ownerOf(tokenId) == msg.sender, \"Only token owner\");\n  }\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _createChargedParticle(\n    address creator,\n    address receiver,\n    address referrer,\n    string memory tokenMetaUri,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    uint256 annuityPercent\n  )\n    internal\n    virtual\n    returns (uint256 newTokenId)\n  {\n    require(address(_chargedParticles) != address(0x0), \"PRT:E-107\");\n\n    newTokenId = _createProton(creator, receiver, tokenMetaUri, 0, 0);\n\n    if (annuityPercent > 0) {\n      _chargedSettings.setCreatorAnnuities(\n        address(this),\n        newTokenId,\n        creator,\n        annuityPercent\n      );\n    }\n\n    _chargeParticle(newTokenId, walletManagerId, assetToken, assetAmount, referrer);\n  }\n\n  function _chargeParticle(\n    uint256 tokenId,\n    string memory walletManagerId,\n    address assetToken,\n    uint256 assetAmount,\n    address referrer\n  )\n    internal\n    virtual\n  {\n    _collectAssetToken(_msgSender(), assetToken, assetAmount);\n\n    IERC20(assetToken).approve(address(_chargedParticles), assetAmount);\n\n    _chargedParticles.energizeParticle(\n      address(this),\n      tokenId,\n      walletManagerId,\n      assetToken,\n      assetAmount,\n      referrer\n    );\n  }\n\n  function _burn(uint256 tokenId) internal {\n    _unlockToken(tokenId);\n    _transfer(ownerOf(tokenId), address(0x000000000000000000000000000000000000dEaD), tokenId);\n  }\n\n  /***********************************|\n  |        Soul bounded               |\n  |__________________________________*/\n\n  function lockToken(uint256 tokenId) public {\n    requireTokenOwner(tokenId);\n    _lockToken(tokenId);\n  }\n\n  /***********************************|\n  |        Function Overrides         |\n  |__________________________________*/\n\n  function _setSalePrice(uint256 tokenId, uint256 salePrice) internal virtual override {\n    super._setSalePrice(tokenId, salePrice);\n\n    // Temp-Lock/Unlock NFT\n    //  prevents front-running the sale and draining the value of the NFT just before sale\n    _chargedState.setTemporaryLock(address(this), tokenId, (salePrice > 0));\n  }\n\n\n  function _buyProton(uint256 _tokenId, uint256 _gasLimit)\n    internal\n    virtual\n    override\n    returns (\n      address contractAddress,\n      uint256 tokenId,\n      address oldOwner,\n      address newOwner,\n      uint256 salePrice,\n      address royaltiesReceiver,\n      uint256 creatorAmount\n    )\n  {\n    (contractAddress, tokenId, oldOwner, newOwner, salePrice, royaltiesReceiver, creatorAmount) = super._buyProton(_tokenId, _gasLimit);\n\n    // Signal to Universe Controller\n    if (address(_universe) != address(0)) {\n      _universe.onProtonSale(contractAddress, tokenId, oldOwner, newOwner, salePrice, royaltiesReceiver, creatorAmount);\n    }\n  }\n\n  function _transfer(address from, address to, uint256 tokenId) internal virtual override {\n    require(lockedTokens[tokenId] == false, \"BondedToken: Token is locked\");\n\n    // Unlock NFT\n    _chargedState.setTemporaryLock(address(this), tokenId, false);\n\n    super._transfer(from, to, tokenId);\n  }\n}"
    },
    "contracts/v1/Universe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Universe.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IUniverse.sol\";\nimport \"./interfaces/IChargedParticles.sol\";\nimport \"./interfaces/ILepton.sol\";\nimport \"./lib/TokenInfo.sol\";\nimport \"./lib/BlackholePrevention.sol\";\n\n\n/**\n * @notice Charged Particles Universe Contract\n * @dev Upgradeable Contract\n */\ncontract Universe is IUniverse, Initializable, OwnableUpgradeable, BlackholePrevention {\n  using SafeMathUpgradeable for uint256;\n  using TokenInfo for address;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  // The ChargedParticles Contract Address\n  address public chargedParticles;\n  address public proton;\n  address public lepton;\n  address public quark;\n  address public boson;\n\n  uint256 constant internal PERCENTAGE_SCALE = 1e4;  // 10000  (100%)\n\n  // Positive Charge\n  uint256 internal photonMaxSupply;\n  uint256 internal totalPhotonDischarged;\n\n  // Source of Positive Charge\n  IERC20Upgradeable public photonSource;\n\n  //   Asset Token => Electrostatic Attraction Multiplier\n  mapping (address => uint256) internal esaMultiplier;\n\n  //       Account => Electrostatic Attraction Levels\n  mapping (address => uint256) internal esaLevel;\n\n  // Energizing Account => Referral Source\n  mapping (address => address) internal referralSource;\n\n  // NFT Token UUID => Bonded Lepton Mass\n  mapping (uint256 => uint256) internal bondedLeptonMass;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n\n  /***********************************|\n  |         Public Functions          |\n  |__________________________________*/\n\n  function getStaticCharge(address /* account */) external pure virtual returns (uint256 positiveEnergy) {\n    return 0;\n  }\n\n  function conductElectrostaticDischarge(address /* account */, uint256 /* amount */) external pure virtual returns (uint256 positiveEnergy) {\n    return 0;\n  }\n\n  /***********************************|\n  |      Only Charged Particles       |\n  |__________________________________*/\n\n  function onEnergize(\n    address /* sender */,\n    address /* referrer */,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    // no-op\n  }\n\n  function onDischarge(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* walletManagerId */,\n    address assetToken,\n    uint256 creatorEnergy,\n    uint256 receiverEnergy\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    // no-op\n  }\n\n  function onDischargeForCreator(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* walletManagerId */,\n    address /* creator */,\n    address assetToken,\n    uint256 receiverEnergy\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    // no-op\n  }\n\n  function onRelease(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* walletManagerId */,\n    address assetToken,\n    uint256 principalAmount,\n    uint256 creatorEnergy,\n    uint256 receiverEnergy\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    // no-op\n  }\n\n  function onCovalentBond(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* managerId */,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    // no-op\n  }\n\n  function onCovalentBreak(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* managerId */,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    // no-op\n  }\n\n  function onProtonSale(\n    address contractAddress,\n    uint256 tokenId,\n    address oldOwner,\n    address newOwner,\n    uint256 salePrice,\n    address creator,\n    uint256 creatorRoyalties\n  )\n    external\n    virtual\n    override\n    onlyProton\n  {\n    // no-op\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function setChargedParticles(\n    address controller\n  )\n    external\n    virtual\n    onlyOwner\n    onlyValidContractAddress(controller)\n  {\n    chargedParticles = controller;\n    emit ChargedParticlesSet(controller);\n  }\n\n  function setPhoton(\n    address token,\n    uint256 maxSupply\n  )\n    external\n    virtual\n    onlyOwner\n    onlyValidContractAddress(token)\n  {\n    photonSource = IERC20Upgradeable(token);\n    photonMaxSupply = maxSupply;\n    emit PhotonSet(token, maxSupply);\n  }\n\n  function setProtonToken(\n    address token\n  )\n    external\n    virtual\n    onlyOwner\n    onlyValidContractAddress(token)\n  {\n    proton = token;\n    emit ProtonTokenSet(token);\n  }\n\n  function setLeptonToken(\n    address token\n  )\n    external\n    virtual\n    onlyOwner\n    onlyValidContractAddress(token)\n  {\n    lepton = token;\n    emit LeptonTokenSet(token);\n  }\n\n  function setQuarkToken(\n    address token\n  )\n    external\n    virtual\n    onlyOwner\n    onlyValidContractAddress(token)\n  {\n    quark = token;\n    emit QuarkTokenSet(token);\n  }\n\n  function setBosonToken(\n    address token\n  )\n    external\n    virtual\n    onlyOwner\n    onlyValidContractAddress(token)\n  {\n    boson = token;\n    emit BosonTokenSet(token);\n  }\n\n  function setEsaMultiplier(\n    address assetToken,\n    uint256 multiplier\n  )\n    external\n    virtual\n    onlyOwner\n  {\n    esaMultiplier[assetToken] = multiplier;\n    emit EsaMultiplierSet(assetToken, multiplier);\n  }\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _electrostaticAttraction(uint256 tokenUuid, address receiver, address assetToken, uint256 baseAmount) internal virtual {\n  }\n\n  function _conductElectrostaticDischarge(address /* account */, uint256 /* energy */) internal virtual pure returns (uint256) {\n    return 0;\n  }\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  /// @dev Throws if called by any non-account\n  modifier onlyValidContractAddress(address account) {\n    require(account != address(0x0) && account.isContract(), \"UNI:E-417\");\n    _;\n  }\n\n  /// @dev Throws if called by any account other than the Charged Particles contract\n  modifier onlyChargedParticles() {\n    require(chargedParticles == msg.sender, \"UNI:E-108\");\n    _;\n  }\n\n  /// @dev Throws if called by any account other than the Proton NFT contract\n  modifier onlyProton() {\n    require(proton == msg.sender, \"UNI:E-110\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/UniverseRP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Universe.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\nimport \"./interfaces/IUniverseRP.sol\";\nimport \"./interfaces/IChargedParticles.sol\";\nimport \"./interfaces/ILepton.sol\";\nimport \"./interfaces/IRewardNft.sol\";\nimport \"./lib/TokenInfo.sol\";\nimport \"./lib/BlackholePrevention.sol\";\nimport \"./interfaces/IRewardProgram.sol\";\n\n/**\n * @notice Charged Particles Universe Contract with Rewards Program\n * @dev Upgradeable Contract\n */\ncontract UniverseRP is IUniverseRP, Initializable, OwnableUpgradeable, BlackholePrevention {\n  using SafeMathUpgradeable for uint256;\n  using TokenInfo for address;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  uint256 constant private LEPTON_MULTIPLIER_SCALE = 1e2;\n  uint256 constant internal PERCENTAGE_SCALE = 1e4;  // 10000  (100%)\n\n  // The ChargedParticles Contract Address\n  address public _chargedParticles;\n\n  // The Lepton NFT Contract Address\n  address public _multiplierNft;\n\n  // Asset Token => Reward Program\n  mapping (address => address) internal _assetRewardPrograms;\n  mapping (uint256 => EnumerableSet.UintSet) internal _multiplierNftsSet;\n\n  // Token UUID => NFT Staking Data\n  mapping (uint256 => NftStake) private _nftStake;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize() public initializer {\n    __Ownable_init();\n  }\n\n  function getRewardProgram(address asset) external view override returns (address) {\n    return _getRewardProgram(asset);\n  }\n\n  function getNftStake(uint256 uuid) external view override returns (NftStake memory) {\n    return _nftStake[uuid];\n  }\n\n  /***********************************|\n  |      Only Charged Particles       |\n  |__________________________________*/\n\n  function onEnergize(\n    address /* sender */,\n    address /* referrer */,\n    address contractAddress,\n    uint256 tokenId,\n    string calldata walletManagerId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    address rewardProgram = _getRewardProgram(assetToken);\n    if (rewardProgram != address(0)) {\n      IRewardProgram(rewardProgram).registerAssetDeposit(\n        contractAddress,\n        tokenId,\n        walletManagerId,\n        assetAmount\n      );\n    }\n  }\n\n  function onDischarge(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* walletManagerId */,\n    address assetToken,\n    uint256 creatorEnergy,\n    uint256 receiverEnergy\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    address rewardProgram = _getRewardProgram(assetToken);\n    if (rewardProgram != address(0)) {\n      uint256 totalInterest = receiverEnergy.add(creatorEnergy);\n      IRewardProgram(rewardProgram).registerAssetRelease(contractAddress, tokenId, totalInterest);\n    }\n  }\n\n  function onDischargeForCreator(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* walletManagerId */,\n    address /* creator */,\n    address assetToken,\n    uint256 receiverEnergy\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    address rewardProgram = _getRewardProgram(assetToken);\n    if (rewardProgram != address(0)) {\n      IRewardProgram(rewardProgram).registerAssetRelease(contractAddress, tokenId, receiverEnergy);\n    }\n  }\n\n  function onRelease(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* walletManagerId */,\n    address assetToken,\n    uint256 principalAmount,\n    uint256 creatorEnergy,\n    uint256 receiverEnergy\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    address rewardProgram = _getRewardProgram(assetToken);\n    if (rewardProgram != address(0)) {\n      // \"receiverEnergy\" includes the \"principalAmount\"\n      uint256 totalInterest = receiverEnergy.sub(principalAmount).add(creatorEnergy);\n      IRewardProgram(rewardProgram).registerAssetRelease(contractAddress, tokenId, totalInterest);\n    }\n  }\n\n  function onCovalentBond(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* managerId */,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    _registerNftDeposit(contractAddress, tokenId, nftTokenAddress, nftTokenId, nftTokenAmount);\n  }\n\n  function onCovalentBreak(\n    address contractAddress,\n    uint256 tokenId,\n    string calldata /* managerId */,\n    address nftTokenAddress,\n    uint256 nftTokenId,\n    uint256 nftTokenAmount\n  )\n    external\n    virtual\n    override\n    onlyChargedParticles\n  {\n    _registerNftRelease(contractAddress, tokenId, nftTokenAddress, nftTokenId, nftTokenAmount);\n  }\n\n  function onProtonSale(\n    address contractAddress,\n    uint256 tokenId,\n    address oldOwner,\n    address newOwner,\n    uint256 salePrice,\n    address creator,\n    uint256 creatorRoyalties\n  )\n    external\n    virtual\n    override\n  {\n    // no-op\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function setChargedParticles(\n    address controller\n  )\n    external\n    onlyOwner\n    onlyValidContractAddress(controller)\n  {\n    _chargedParticles = controller;\n    emit ChargedParticlesSet(controller);\n  }\n\n  function setMultiplierNft(address nftTokenAddress)\n    external\n    onlyOwner\n    onlyValidContractAddress(nftTokenAddress)\n  {\n    _multiplierNft = nftTokenAddress;\n  }\n\n  function setRewardProgram(\n    address rewardProgam,\n    address assetToken\n  )\n    external\n    onlyOwner\n    onlyValidContractAddress(rewardProgam)\n  {\n    require(assetToken != address(0x0), \"UNI:E-403\");\n    _assetRewardPrograms[assetToken] = rewardProgam;\n    emit RewardProgramSet(assetToken, rewardProgam);\n  }\n\n  function removeRewardProgram(address assetToken) external onlyOwner {\n    delete _assetRewardPrograms[assetToken];\n    emit RewardProgramRemoved(assetToken);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external virtual onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual onlyOwner {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _getRewardProgram(address assetToken) internal view returns (address) {\n    return _assetRewardPrograms[assetToken];\n  }\n\n  function _registerNftDeposit(address contractAddress, uint256 tokenId, address depositNftAddress, uint256 depositNftTokenId, uint256 /* nftTokenAmount */)\n    internal\n  {\n    // We only care about the Multiplier NFT\n    if (_multiplierNft != depositNftAddress) { return; }\n\n    uint256 parentNftUuid = contractAddress.getTokenUUID(tokenId);\n    uint256 multiplier = _getNftMultiplier(depositNftAddress, depositNftTokenId);\n\n    if (multiplier > 0 && !_multiplierNftsSet[parentNftUuid].contains(multiplier)) {\n      // Add to Multipliers Set\n      _multiplierNftsSet[parentNftUuid].add(multiplier);\n\n      // Update NFT Stake\n      uint256 combinedMultiplier = _calculateTotalMultiplier(parentNftUuid);\n      if (_nftStake[parentNftUuid].depositBlockNumber == 0) {\n        _nftStake[parentNftUuid] = NftStake(combinedMultiplier, block.number, 0);\n      } else {\n        uint256 blockDiff = block.number - _nftStake[parentNftUuid].depositBlockNumber;\n        _nftStake[parentNftUuid].multiplier = combinedMultiplier;\n        _nftStake[parentNftUuid].depositBlockNumber = _nftStake[parentNftUuid].depositBlockNumber.add(blockDiff.div(2));\n      }\n    }\n\n    emit NftDeposit(contractAddress, tokenId, depositNftAddress, depositNftTokenId);\n  }\n\n  function _registerNftRelease(\n    address contractAddress,\n    uint256 tokenId,\n    address releaseNftAddress,\n    uint256 releaseNftTokenId,\n    uint256 /* nftTokenAmount */\n  )\n    internal\n  {\n    // We only care about the Multiplier NFT\n    if (_multiplierNft != releaseNftAddress) { return; }\n\n    uint256 parentNftUuid = contractAddress.getTokenUUID(tokenId);\n    NftStake storage nftStake = _nftStake[parentNftUuid];\n\n    // Remove from Multipliers Set\n    uint256 multiplier = _getNftMultiplier(releaseNftAddress, releaseNftTokenId);\n    _multiplierNftsSet[parentNftUuid].remove(multiplier);\n\n    // Determine New Multiplier or Mark as Released\n    if (_multiplierNftsSet[parentNftUuid].length() > 0) {\n      nftStake.multiplier = _calculateTotalMultiplier(parentNftUuid);\n    } else {\n      nftStake.releaseBlockNumber = block.number;\n    }\n\n    emit NftRelease(contractAddress, tokenId, releaseNftAddress, releaseNftTokenId);\n  }\n\n  function _calculateTotalMultiplier(uint256 parentNftUuid) internal view returns (uint256) {\n    uint256 len = _multiplierNftsSet[parentNftUuid].length();\n    uint256 multiplier = 0;\n    uint256 loss = 50;\n    uint256 i = 0;\n\n    for (; i < len; i++) {\n      multiplier = multiplier.add(_multiplierNftsSet[parentNftUuid].at(i));\n    }\n    if (len > 1) {\n      multiplier = multiplier.sub(loss.mul(len));\n    }\n    return multiplier;\n  }\n\n  function _getNftMultiplier(address contractAddress, uint256 tokenId) internal returns (uint256) {\n    bytes4 fnSig = IRewardNft.getMultiplier.selector;\n    (bool success, bytes memory returnData) = contractAddress.call(abi.encodeWithSelector(fnSig, tokenId));\n\n    if (success) {\n      return abi.decode(returnData, (uint256));\n    } else {\n      return 0;\n    }\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  /// @dev Throws if called by any non-account\n  modifier onlyValidContractAddress(address account) {\n    require(account != address(0x0) && account.isContract(), \"UNI:E-417\");\n    _;\n  }\n\n  /// @dev Throws if called by any account other than the Charged Particles contract\n  modifier onlyChargedParticles() {\n    require(_chargedParticles == msg.sender, \"UNI:E-108\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/vesting/VestingClaim7.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\nimport \"../interfaces/IMerkleDistributor.sol\";\n\ncontract VestingClaim7 is IMerkleDistributor {\n    address public immutable override token;\n    bytes32 public immutable override merkleRoot;\n\n    address public owner;\n    uint256 public immutable expiryDate;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // This is a packed array of booleans.\n    mapping(uint256 => uint256) private claimedBitMap;\n\n    constructor(address token_, bytes32 merkleRoot_, uint256 expiryDate_) public {\n        owner = msg.sender;\n        token = token_;\n        merkleRoot = merkleRoot_;\n        expiryDate = expiryDate_;\n    }\n\n    function isClaimed(uint256 index) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 index) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\n    }\n\n    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {\n        require(!isClaimed(index), \"VestingClaim7: Drop already claimed.\");\n\n        // Verify the merkle proof.\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(MerkleProof.verify(merkleProof, merkleRoot, node), \"VestingClaim7: Invalid proof.\");\n\n        // Mark it claimed and send the token.\n        _setClaimed(index);\n        require(IERC20(token).transfer(account, amount), \"VestingClaim7: Transfer failed.\");\n\n        emit Claimed(index, account, amount);\n    }\n\n    function expire(address exitAddress) external onlyOwner {\n        require(block.timestamp >= expiryDate, \"VestingClaim7: expiry date not reached\");\n        uint256 remainingBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(exitAddress, remainingBalance);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"VestingClaim7: new owner is the zero address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"VestingClaim7: not owner\");\n        _;\n    }\n}\n"
    },
    "contracts/v1/yield/aave/AaveSmartWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// AaveSmartWallet.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../interfaces/IAaveBridge.sol\";\nimport \"../../lib/SmartWalletBase.sol\";\n\n/**\n * @notice ERC20-Token Smart-Wallet for Aave Assets\n * @dev Non-upgradeable Contract\n */\ncontract AaveSmartWallet is SmartWalletBase {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 constant internal RAY = 1e27;\n\n  IAaveBridge internal _bridge;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize(\n    address aaveBridge\n  )\n    public\n  {\n    SmartWalletBase.initializeBase();\n    _bridge = IAaveBridge(aaveBridge);\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isReserveActive(address assetToken) external view override returns (bool) {\n    return _bridge.isReserveActive(assetToken);\n  }\n\n  function getReserveInterestToken(address assetToken) external view override returns (address) {\n    return _bridge.getReserveInterestToken(assetToken);\n  }\n\n  function getPrincipal(address assetToken) external override returns (uint256) {\n    return _getPrincipal(assetToken);\n  }\n\n  function getInterest(address assetToken) external override returns (uint256 creatorInterest, uint256 ownerInterest) {\n    return _getInterest(assetToken);\n  }\n\n  function getTotal(address assetToken) external override returns (uint256) {\n    return _getTotal(assetToken);\n  }\n\n  function getRewards(address rewardToken) external override returns (uint256) {\n    return IERC20(rewardToken).balanceOf(address(this));\n  }\n\n  function deposit(\n    address assetToken,\n    uint256 assetAmount,\n    uint256 referralCode\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    return _deposit(assetToken, assetAmount, referralCode);\n  }\n\n\n  function withdraw(\n    address receiver,\n    address creatorRedirect,\n    address assetToken\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 walletPrincipal = _getPrincipal(assetToken);\n    (, uint256 ownerInterest) = _getInterest(assetToken);\n    return _withdraw(receiver, creatorRedirect, assetToken, walletPrincipal.add(ownerInterest));\n  }\n\n  function withdrawAmount(\n    address receiver,\n    address creatorRedirect,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    return _withdraw(receiver, creatorRedirect, assetToken, assetAmount);\n  }\n\n  function withdrawAmountForCreator(\n    address receiver,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 receiverAmount)\n  {\n    return _withdrawForCreator(receiver, assetToken, assetAmount);\n  }\n\n  function withdrawRewards(\n    address receiver,\n    address rewardsToken,\n    uint256 rewardsAmount\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    return _withdrawRewards(receiver, rewardsToken, rewardsAmount);\n  }\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _deposit(\n    address assetToken,\n    uint256 assetAmount,\n    uint256 referralCode\n  )\n    internal\n    returns (uint256)\n  {\n    _trackAssetToken(assetToken);\n\n    // Track Principal\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].add(assetAmount);\n\n    // Deposit Assets into Aave (reverts on fail)\n    _sendToken(address(_bridge), assetToken, assetAmount);\n    uint256 aTokensAmount = _bridge.deposit(assetToken, assetAmount, referralCode);\n\n    // Return amount of aTokens transfered\n    return aTokensAmount;\n  }\n\n  function _withdraw(\n    address receiver,\n    address creatorRedirect,\n    address assetToken,\n    uint256 assetAmount\n  )\n    internal\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 walletPrincipal = _getPrincipal(assetToken);\n    (uint256 creatorInterest, uint256 ownerInterest) = _getInterest(assetToken);\n\n    // Withdraw from Interest only\n    if (assetAmount < ownerInterest) {\n      if (creatorInterest > 0) {\n        uint256 ratio = assetAmount.mul(RAY).div(ownerInterest);\n        creatorAmount = creatorInterest.add(nftCreatorAmountDischarged).mul(ratio).div(RAY);\n\n        if (creatorAmount <= nftCreatorAmountDischarged) {\n          nftCreatorAmountDischarged = nftCreatorAmountDischarged.sub(creatorAmount);\n          creatorAmount = 0;\n        }\n\n        else {\n          creatorAmount = creatorAmount.sub(nftCreatorAmountDischarged);\n          nftCreatorAmountDischarged = 0;\n        }\n      }\n      receiverAmount = assetAmount;\n    }\n\n    // Withdraw from Interest + Principal\n    else {\n      uint256 fromPrincipal = assetAmount.sub(ownerInterest);\n      if (fromPrincipal > walletPrincipal) {\n        fromPrincipal = walletPrincipal.sub(ownerInterest);\n      }\n\n      creatorAmount = creatorInterest;\n      receiverAmount = ownerInterest.add(fromPrincipal);\n      nftCreatorAmountDischarged = 0;\n\n      // Track Principal\n      _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].sub(fromPrincipal);\n    }\n\n    // Send aTokens to Bridge\n    address aTokenAddress = _bridge.getReserveInterestToken(assetToken);\n    _sendToken(address(_bridge), aTokenAddress, receiverAmount.add(creatorAmount));\n\n    // Withdraw Assets for Creator\n    if (creatorAmount > 0) {\n      address receivesForCreator = (creatorRedirect != address(0x0)) ? creatorRedirect : nftCreator;\n      _bridge.withdraw(receivesForCreator, assetToken, creatorAmount);\n    }\n\n    // Withdraw Assets for Receiver\n    _bridge.withdraw(receiver, assetToken, receiverAmount);\n  }\n\n  function _withdrawForCreator(\n    address receiver,\n    address assetToken,\n    uint256 assetAmount\n  )\n    internal\n    returns (uint256 receiverAmount)\n  {\n    (uint256 creatorInterest,) = _getInterest(assetToken);\n    if (creatorInterest == 0) { return 0; }\n    if (assetAmount > creatorInterest) {\n      assetAmount = creatorInterest;\n    }\n\n    nftCreatorAmountDischarged = nftCreatorAmountDischarged.add(assetAmount);\n\n    // Send aTokens to Bridge\n    address aTokenAddress = _bridge.getReserveInterestToken(assetToken);\n    _sendToken(address(_bridge), aTokenAddress, assetAmount);\n\n    // Withdraw Assets for Receiver on behalf of Creator\n    _bridge.withdraw(receiver, assetToken, assetAmount);\n  }\n\n  function _withdrawRewards(\n    address receiver,\n    address rewardsTokenAddress,\n    uint256 rewardsAmount\n  )\n    internal\n    returns (uint256)\n  {\n    address self = address(this);\n    IERC20 rewardsToken = IERC20(rewardsTokenAddress);\n\n    uint256 walletBalance = rewardsToken.balanceOf(self);\n    require(walletBalance >= rewardsAmount, \"ASW:E-411\");\n\n    // Transfer Rewards to Receiver\n    rewardsToken.safeTransfer(receiver, rewardsAmount);\n    return rewardsAmount;\n  }\n\n  function _getTotal(address assetToken) internal view returns (uint256) {\n    return _bridge.getTotalBalance(address(this), assetToken);\n  }\n\n  function _getInterest(address assetToken) internal view returns (uint256 creatorInterest, uint256 ownerInterest) {\n    uint256 total = _getTotal(assetToken);\n    uint256 principal = _getPrincipal(assetToken);\n    uint256 interest = total.sub(principal);\n\n    // Creator Royalties\n    if (nftCreatorAnnuityPct > 0) {\n\n      // Interest too small to calculate percentage;\n      if (interest <= PERCENTAGE_SCALE) {\n        // creatorInterest = interest.div(2); // split evenly?\n        creatorInterest = 0; // All to owner\n      }\n\n      // Calculate percentage for Creator\n      else {\n        creatorInterest = interest\n          .add(nftCreatorAmountDischarged)\n          .mul(nftCreatorAnnuityPct)\n          .div(PERCENTAGE_SCALE)\n          .sub(nftCreatorAmountDischarged);\n      }\n    }\n\n    // Owner Portion\n    ownerInterest = interest.sub(creatorInterest);\n  }\n\n  function _sendToken(address to, address token, uint256 amount) internal {\n    IERC20(token).safeTransfer(to, amount);\n  }\n}\n"
    },
    "contracts/v1/yield/aave/AaveSmartWalletB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// AaveSmartWallet.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"../../interfaces/IAaveBridge.sol\";\nimport \"../../lib/SmartWalletBaseB.sol\";\n\n/**\n * @notice ERC20-Token Smart-Wallet for Aave Assets\n * @dev Non-upgradeable Contract\n */\ncontract AaveSmartWalletB is SmartWalletBaseB {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  uint256 constant internal RAY = 1e27;\n\n  IAaveBridge internal _bridge;\n\n  uint256 internal _nftCreatorAmountDischarged;\n\n  mapping (address => address) internal _assetATokens;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize(\n    address aaveBridge\n  )\n    public\n  {\n    SmartWalletBaseB.initializeBase();\n    _bridge = IAaveBridge(aaveBridge);\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isReserveActive(address assetToken) external view override returns (bool) {\n    return _bridge.isReserveActive(assetToken);\n  }\n\n  function getReserveInterestToken(address assetToken) external view override returns (address) {\n    return _bridge.getReserveInterestToken(assetToken);\n  }\n\n  function getPrincipal(address assetToken) external override returns (uint256) {\n    return _getPrincipal(assetToken);\n  }\n\n  function getInterest(address assetToken, uint256 creatorPct) external override returns (uint256 creatorInterest, uint256 ownerInterest) {\n    return _getInterest(assetToken, creatorPct);\n  }\n\n  function getTotal(address assetToken) external override returns (uint256) {\n    return _getTotal(assetToken);\n  }\n\n  function getRewards(address rewardToken) external override returns (uint256) {\n    return IERC20(rewardToken).balanceOf(address(this));\n  }\n\n  function deposit(\n    address assetToken,\n    uint256 assetAmount,\n    uint256 referralCode\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    return _deposit(assetToken, assetAmount, referralCode);\n  }\n\n\n  function withdraw(\n    address receiver,\n    address creator,\n    uint256 creatorPct,\n    address assetToken\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 walletPrincipal = _getPrincipal(assetToken);\n    (, uint256 ownerInterest) = _getInterest(assetToken, creatorPct);\n    return _withdraw(receiver, creator, creatorPct, assetToken, walletPrincipal.add(ownerInterest));\n  }\n\n  function withdrawAmount(\n    address receiver,\n    address creator,\n    uint256 creatorPct,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    return _withdraw(receiver, creator, creatorPct, assetToken, assetAmount);\n  }\n\n  function withdrawAmountForCreator(\n    address receiver,\n    uint256 creatorPct,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 receiverAmount)\n  {\n    return _withdrawForCreator(receiver, creatorPct, assetToken, assetAmount);\n  }\n\n  function withdrawRewards(\n    address receiver,\n    address rewardsToken,\n    uint256 rewardsAmount\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    return _withdrawRewards(receiver, rewardsToken, rewardsAmount);\n  }\n\n  function refreshPrincipal(address assetToken) external virtual override onlyWalletManager {\n    uint256 aTokenBalance = IERC20(_assetATokens[assetToken]).balanceOf(address(this));\n    if (_assetPrincipalBalance[assetToken] > aTokenBalance) {\n      _assetPrincipalBalance[assetToken] = aTokenBalance;\n    }\n  }\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _deposit(\n    address assetToken,\n    uint256 assetAmount,\n    uint256 referralCode\n  )\n    internal\n    returns (uint256)\n  {\n    _trackAssetToken(assetToken);\n\n    // Track Principal\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].add(assetAmount);\n\n    // Deposit Assets into Aave (reverts on fail)\n    _sendToken(address(_bridge), assetToken, assetAmount);\n    uint256 aTokensAmount = _bridge.deposit(assetToken, assetAmount, referralCode);\n\n    // Return amount of aTokens transfered\n    return aTokensAmount;\n  }\n\n  function _withdraw(\n    address receiver,\n    address creator,\n    uint256 creatorPct,\n    address assetToken,\n    uint256 assetAmount\n  )\n    internal\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 walletPrincipal = _getPrincipal(assetToken);\n    (uint256 creatorInterest, uint256 ownerInterest) = _getInterest(assetToken, creatorPct);\n\n    // Withdraw from Interest only\n    if (assetAmount < ownerInterest) {\n      if (creatorInterest > 0) {\n        uint256 ratio = assetAmount.mul(RAY).div(ownerInterest);\n        creatorAmount = creatorInterest.add(_nftCreatorAmountDischarged).mul(ratio).div(RAY);\n\n        if (creatorAmount <= _nftCreatorAmountDischarged) {\n          _nftCreatorAmountDischarged = _nftCreatorAmountDischarged.sub(creatorAmount);\n          creatorAmount = 0;\n        }\n        else {\n          creatorAmount = creatorAmount.sub(_nftCreatorAmountDischarged);\n          _nftCreatorAmountDischarged = 0;\n        }\n      }\n      receiverAmount = assetAmount;\n    }\n\n    // Withdraw from Interest + Principal\n    else {\n      uint256 fromPrincipal = assetAmount.sub(ownerInterest);\n      if (fromPrincipal > walletPrincipal) {\n        fromPrincipal = walletPrincipal.sub(ownerInterest);\n      }\n\n      creatorAmount = creatorInterest;\n      receiverAmount = ownerInterest.add(fromPrincipal);\n      _nftCreatorAmountDischarged = 0;\n\n      // Track Principal\n      _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].sub(fromPrincipal);\n    }\n\n    // Send aTokens to Bridge\n    address aTokenAddress = _bridge.getReserveInterestToken(assetToken);\n    _sendToken(address(_bridge), aTokenAddress, receiverAmount.add(creatorAmount));\n\n    // Withdraw Assets for Creator\n    if (creatorAmount > 0) {\n      if (creator != address(0)) {\n        _bridge.withdraw(creator, assetToken, creatorAmount);\n      } else {\n        receiverAmount = receiverAmount.add(creatorAmount);\n        creatorAmount = 0;\n      }\n    }\n\n    // Withdraw Assets for Receiver\n    _bridge.withdraw(receiver, assetToken, receiverAmount);\n  }\n\n  function _withdrawForCreator(\n    address receiver,\n    uint256 creatorPct,\n    address assetToken,\n    uint256 assetAmount\n  )\n    internal\n    returns (uint256 receiverAmount)\n  {\n    (uint256 creatorInterest,) = _getInterest(assetToken, creatorPct);\n    if (creatorInterest == 0) { return 0; }\n    if (assetAmount > creatorInterest) {\n      assetAmount = creatorInterest;\n    }\n\n    _nftCreatorAmountDischarged = _nftCreatorAmountDischarged.add(assetAmount);\n\n    // Send aTokens to Bridge\n    address aTokenAddress = _bridge.getReserveInterestToken(assetToken);\n    _sendToken(address(_bridge), aTokenAddress, assetAmount);\n\n    // Withdraw Assets for Receiver on behalf of Creator\n    _bridge.withdraw(receiver, assetToken, assetAmount);\n  }\n\n  function _withdrawRewards(\n    address receiver,\n    address rewardsTokenAddress,\n    uint256 rewardsAmount\n  )\n    internal\n    returns (uint256)\n  {\n    address self = address(this);\n    IERC20 rewardsToken = IERC20(rewardsTokenAddress);\n\n    uint256 walletBalance = rewardsToken.balanceOf(self);\n    require(walletBalance >= rewardsAmount, \"ASW:E-411\");\n\n    // Transfer Rewards to Receiver\n    rewardsToken.safeTransfer(receiver, rewardsAmount);\n    return rewardsAmount;\n  }\n\n  function _getTotal(address assetToken) internal view returns (uint256) {\n    return _bridge.getTotalBalance(address(this), assetToken);\n  }\n\n  function _getInterest(address assetToken, uint256 creatorPct) internal view returns (uint256 creatorInterest, uint256 ownerInterest) {\n    uint256 total = _getTotal(assetToken);\n    uint256 principal = _getPrincipal(assetToken);\n    uint256 interest = total.sub(principal);\n\n    // Creator Royalties\n    if (creatorPct > 0) {\n\n      // Interest too small to calculate percentage;\n      if (interest <= PERCENTAGE_SCALE) {\n        // creatorInterest = interest.div(2); // split evenly?\n        creatorInterest = 0; // All to owner\n      }\n\n      // Calculate percentage for Creator\n      else {\n        creatorInterest = interest\n          .add(_nftCreatorAmountDischarged)\n          .mul(creatorPct)\n          .div(PERCENTAGE_SCALE)\n          .sub(_nftCreatorAmountDischarged);\n      }\n    }\n\n    // Owner Portion\n    ownerInterest = interest.sub(creatorInterest);\n  }\n\n  function _trackAssetToken(address assetToken) internal override {\n    if (!_assetTokens.contains(assetToken)) {\n      _assetTokens.add(assetToken);\n      address aTokenAddress = _bridge.getReserveInterestToken(assetToken);\n      _assetATokens[assetToken] = aTokenAddress;\n    }\n  }\n\n  function _sendToken(address to, address token, uint256 amount) internal {\n    IERC20(token).safeTransfer(to, amount);\n  }\n}\n"
    },
    "contracts/v1/yield/aave/AaveWalletManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// AaveWalletManager.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../lib/WalletManagerBase.sol\";\n\nimport \"./AaveSmartWallet.sol\";\n\n/**\n * @notice Wallet Manager for Aave\n * @dev Non-upgradeable Contract\n */\ncontract AaveWalletManager is WalletManagerBase {\n  using SafeMath for uint256;\n\n  event AaveBridgeSet(address indexed aaveBridge);\n  event ValidRewardsTokenSet(address indexed rewardsToken, bool state);\n\n  address internal _aaveBridge;\n  uint256 internal _referralCode;\n\n  mapping (address => bool) public rewardsTokenWhitelist;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor () public {\n    _walletTemplate = address(new AaveSmartWallet());\n  }\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isReserveActive(address contractAddress, uint256 tokenId, address assetToken) external view override returns (bool) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return false; }\n    return AaveSmartWallet(_wallets[uuid]).isReserveActive(assetToken);\n  }\n\n  function getReserveInterestToken(address contractAddress, uint256 tokenId, address assetToken) external view override returns (address) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return address(0x0); }\n    return AaveSmartWallet(_wallets[uuid]).getReserveInterestToken(assetToken);\n  }\n\n  /**\n    * @notice Gets the Principal-Amount of Assets held in the Smart-Wallet\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Principal-Balance of the Smart-Wallet\n    */\n  function getPrincipal(address contractAddress, uint256 tokenId, address assetToken) external override returns (uint256) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return AaveSmartWallet(_wallets[uuid]).getPrincipal(assetToken);\n  }\n\n  /**\n    * @notice Gets the Interest-Amount that the Token has generated\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return creatorInterest The NFT Creator's portion of the Interest\n    * @return ownerInterest The NFT Owner's portion of the Interest\n    */\n  function getInterest(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256 creatorInterest, uint256 ownerInterest)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] != address(0x0)) {\n      return AaveSmartWallet(_wallets[uuid]).getInterest(assetToken);\n    }\n  }\n\n  /**\n    * @notice Gets the Available Balance of Assets held in the Token\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Available Balance of the Token\n    */\n  function getTotal(address contractAddress, uint256 tokenId, address assetToken) external override returns (uint256) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return AaveSmartWallet(_wallets[uuid]).getTotal(assetToken);\n  }\n\n  function getRewards(address contractAddress, uint256 tokenId, address _rewardToken) external override returns (uint256) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return AaveSmartWallet(_wallets[uuid]).getRewards(_rewardToken);\n  }\n\n\n  /***********************************|\n  |          Only Controller          |\n  |__________________________________*/\n\n  function energize(\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyController\n    returns (uint256 yieldTokensAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Deposit into Smart-Wallet\n    yieldTokensAmount = AaveSmartWallet(wallet).deposit(assetToken, assetAmount, _referralCode);\n\n    // Log Event\n    emit WalletEnergized(contractAddress, tokenId, assetToken, assetAmount, yieldTokensAmount);\n  }\n\n  function discharge(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (, uint256 ownerInterest) = AaveSmartWallet(wallet).getInterest(assetToken);\n    require(ownerInterest > 0, \"AWM:E-412\");\n\n    // Discharge the full amount of interest\n    (creatorAmount, receiverAmount) = AaveSmartWallet(wallet).withdrawAmount(receiver, creatorRedirect, assetToken, ownerInterest);\n\n    // Log Event\n    emit WalletDischarged(contractAddress, tokenId, assetToken, creatorAmount, receiverAmount);\n  }\n\n  function dischargeAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (, uint256 ownerInterest) = AaveSmartWallet(wallet).getInterest(assetToken);\n    require(assetAmount > 0 && ownerInterest >= assetAmount, \"AWM:E-412\");\n\n    // Discharge a portion of the interest\n    (creatorAmount, receiverAmount) = AaveSmartWallet(wallet).withdrawAmount(receiver, creatorRedirect, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletDischarged(contractAddress, tokenId, assetToken, creatorAmount, receiverAmount);\n  }\n\n  function dischargeAmountForCreator(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address creator,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyController\n    returns (uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (uint256 creatorInterest,) = AaveSmartWallet(wallet).getInterest(assetToken);\n    require(assetAmount > 0 && creatorInterest >= assetAmount, \"AWM:E-412\");\n\n    // Discharge a portion of the interest\n    receiverAmount = AaveSmartWallet(wallet).withdrawAmountForCreator(receiver, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletDischargedForCreator(contractAddress, tokenId, assetToken, creator, receiverAmount);\n  }\n\n  function release(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    // Release Principal + Interest\n    principalAmount = AaveSmartWallet(wallet).getPrincipal(assetToken);\n    (creatorAmount, receiverAmount) = AaveSmartWallet(wallet).withdraw(receiver, creatorRedirect, assetToken);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function releaseAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (, uint256 ownerInterest) = AaveSmartWallet(wallet).getInterest(assetToken);\n    principalAmount = (ownerInterest < assetAmount) ? assetAmount.sub(ownerInterest) : 0;\n\n    // Release from interest first + principal if needed\n    (creatorAmount, receiverAmount) = AaveSmartWallet(wallet).withdrawAmount(receiver, creatorRedirect, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function withdrawRewards(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address rewardsToken,\n    uint256 rewardsAmount\n  )\n    external\n    override\n    onlyController\n    returns (uint256 amount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n    require(rewardsTokenWhitelist[rewardsToken], \"AWM:E-423\");\n\n    // Withdraw Rewards to Receiver\n    amount = AaveSmartWallet(wallet).withdrawRewards(receiver, rewardsToken, rewardsAmount);\n\n    // Log Event\n    emit WalletRewarded(contractAddress, tokenId, receiver, rewardsToken, amount);\n  }\n\n  function executeForAccount(\n    address contractAddress,\n    uint256 tokenId,\n    address externalAddress,\n    uint256 ethValue,\n    bytes memory encodedParams\n  )\n    external\n    override\n    onlyController\n    returns (bytes memory)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    return AaveSmartWallet(wallet).executeForAccount(externalAddress, ethValue, encodedParams);\n  }\n\n  function refreshPrincipal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    onlyControllerOrExecutor\n  {\n    // no-op\n  }\n\n  function getWalletAddressById(\n    address contractAddress,\n    uint256 tokenId,\n    address creator,\n    uint256 annuityPct\n  )\n    external\n    override\n    onlyController\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Create Smart-Wallet if none exists\n    if (wallet == address(0x0)) {\n      wallet = _createWallet();\n      _wallets[uuid] = wallet;\n\n      if (creator != address(0x0)) {\n        AaveSmartWallet(wallet).setNftCreator(creator, annuityPct);\n      }\n\n      emit NewSmartWallet(contractAddress, tokenId, wallet, creator, annuityPct);\n    }\n\n    return wallet;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function setAaveBridge(address aaveBridge) external onlyOwner {\n    require(aaveBridge != address(0x0), \"AWM:E-403\");\n    _aaveBridge = aaveBridge;\n    emit AaveBridgeSet(aaveBridge);\n  }\n\n  // ref: https://docs.aave.com/developers/developing-on-aave/the-protocol/lendingpool\n  function setReferralCode(uint256 referralCode) external onlyOwner {\n    _referralCode = referralCode;\n  }\n\n  function setValidRewardsToken(address rewardsToken, bool state) external onlyOwner {\n    rewardsTokenWhitelist[rewardsToken] = state;\n    emit ValidRewardsTokenSet(rewardsToken, state);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _createWallet()\n    internal\n    returns (address)\n  {\n    address newWallet = _createClone(_walletTemplate);\n    AaveSmartWallet(newWallet).initialize(_aaveBridge);\n    return newWallet;\n  }\n}"
    },
    "contracts/v1/yield/aave/AaveWalletManagerB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// AaveWalletManager.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../lib/WalletManagerBase.sol\";\nimport \"../../interfaces/IChargedSettings.sol\";\nimport \"./AaveSmartWalletB.sol\";\n\n/**\n * @notice Wallet Manager for Aave\n * @dev Non-upgradeable Contract\n */\ncontract AaveWalletManagerB is WalletManagerBase {\n  using SafeMath for uint256;\n\n  event AaveBridgeSet(address indexed aaveBridge);\n  event ChargedSettingsSet(address indexed settings);\n  event ValidRewardsTokenSet(address indexed rewardsToken, bool state);\n\n  IChargedSettings internal _chargedSettings;\n\n  address internal _aaveBridge;\n  uint256 internal _referralCode;\n\n  mapping (address => bool) public _rewardsTokenWhitelist;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor () public {\n    _walletTemplate = address(new AaveSmartWalletB());\n  }\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isReserveActive(address contractAddress, uint256 tokenId, address assetToken) external view override returns (bool) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return false; }\n    return AaveSmartWalletB(_wallets[uuid]).isReserveActive(assetToken);\n  }\n\n  function getReserveInterestToken(address contractAddress, uint256 tokenId, address assetToken) external view override returns (address) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return address(0x0); }\n    return AaveSmartWalletB(_wallets[uuid]).getReserveInterestToken(assetToken);\n  }\n\n  /**\n    * @notice Gets the Principal-Amount of Assets held in the Smart-Wallet\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Principal-Balance of the Smart-Wallet\n    */\n  function getPrincipal(address contractAddress, uint256 tokenId, address assetToken) external override returns (uint256) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return AaveSmartWalletB(_wallets[uuid]).getPrincipal(assetToken);\n  }\n\n  /**\n    * @notice Gets the Interest-Amount that the Token has generated\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return creatorInterest The NFT Creator's portion of the Interest\n    * @return ownerInterest The NFT Owner's portion of the Interest\n    */\n  function getInterest(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256 creatorInterest, uint256 ownerInterest)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] != address(0x0)) {\n      (, uint256 annuityPct) = _chargedSettings.getCreatorAnnuities(contractAddress, tokenId);\n      return AaveSmartWalletB(_wallets[uuid]).getInterest(assetToken, annuityPct);\n    }\n  }\n\n  /**\n    * @notice Gets the Available Balance of Assets held in the Token\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Available Balance of the Token\n    */\n  function getTotal(address contractAddress, uint256 tokenId, address assetToken) external override returns (uint256) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return AaveSmartWalletB(_wallets[uuid]).getTotal(assetToken);\n  }\n\n  function getRewards(address contractAddress, uint256 tokenId, address _rewardToken) external override returns (uint256) {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return AaveSmartWalletB(_wallets[uuid]).getRewards(_rewardToken);\n  }\n\n\n  /***********************************|\n  |          Only Controller          |\n  |__________________________________*/\n\n  function energize(\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyController\n    returns (uint256 yieldTokensAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Deposit into Smart-Wallet\n    yieldTokensAmount = AaveSmartWalletB(wallet).deposit(assetToken, assetAmount, _referralCode);\n\n    // Log Event\n    emit WalletEnergized(contractAddress, tokenId, assetToken, assetAmount, yieldTokensAmount);\n  }\n\n  function discharge(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (address creator, uint256 annuityPct) = _chargedSettings.getCreatorAnnuities(contractAddress, tokenId);\n    (, uint256 ownerInterest) = AaveSmartWalletB(wallet).getInterest(assetToken, annuityPct);\n    require(ownerInterest > 0, \"AWM:E-412\");\n\n    if (creatorRedirect != address(0)) {\n      creator = creatorRedirect;\n    }\n\n    // Discharge the full amount of interest\n    (creatorAmount, receiverAmount) = AaveSmartWalletB(wallet).withdrawAmount(receiver, creator, annuityPct, assetToken, ownerInterest);\n\n    // Log Event\n    emit WalletDischarged(contractAddress, tokenId, assetToken, creatorAmount, receiverAmount);\n  }\n\n  function dischargeAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (address creator, uint256 annuityPct) = _chargedSettings.getCreatorAnnuities(contractAddress, tokenId);\n    (, uint256 ownerInterest) = AaveSmartWalletB(wallet).getInterest(assetToken, annuityPct);\n    require(assetAmount > 0 && ownerInterest >= assetAmount, \"AWM:E-412\");\n\n    if (creatorRedirect != address(0)) {\n      creator = creatorRedirect;\n    }\n\n    // Discharge a portion of the interest\n    (creatorAmount, receiverAmount) = AaveSmartWalletB(wallet).withdrawAmount(receiver, creator, annuityPct, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletDischarged(contractAddress, tokenId, assetToken, creatorAmount, receiverAmount);\n  }\n\n  function dischargeAmountForCreator(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address creator,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n    onlyController\n    returns (uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (, uint256 annuityPct) = _chargedSettings.getCreatorAnnuities(contractAddress, tokenId);\n    (uint256 creatorInterest,) = AaveSmartWalletB(wallet).getInterest(assetToken, annuityPct);\n    require(assetAmount > 0 && creatorInterest >= assetAmount, \"AWM:E-412\");\n\n    // Discharge a portion of the interest\n    receiverAmount = AaveSmartWalletB(wallet).withdrawAmountForCreator(receiver, annuityPct, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletDischargedForCreator(contractAddress, tokenId, assetToken, creator, receiverAmount);\n  }\n\n  function release(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (address creator, uint256 annuityPct) = _chargedSettings.getCreatorAnnuities(contractAddress, tokenId);\n    if (creatorRedirect != address(0)) {\n      creator = creatorRedirect;\n    }\n\n    // Release Principal + Interest\n    principalAmount = AaveSmartWalletB(wallet).getPrincipal(assetToken);\n    (creatorAmount, receiverAmount) = AaveSmartWalletB(wallet).withdraw(receiver, creator, annuityPct, assetToken);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function releaseAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n\n    (address creator, uint256 annuityPct) = _chargedSettings.getCreatorAnnuities(contractAddress, tokenId);\n    if (creatorRedirect != address(0)) {\n      creator = creatorRedirect;\n    }\n\n    (, uint256 ownerInterest) = AaveSmartWalletB(wallet).getInterest(assetToken, annuityPct);\n    principalAmount = (ownerInterest < assetAmount) ? assetAmount.sub(ownerInterest) : 0;\n\n    // Release from interest first + principal if needed\n    (creatorAmount, receiverAmount) = AaveSmartWalletB(wallet).withdrawAmount(receiver, creator, annuityPct, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function withdrawRewards(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address rewardsToken,\n    uint256 rewardsAmount\n  )\n    external\n    override\n    onlyController\n    returns (uint256 amount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"AWM:E-403\");\n    require(_rewardsTokenWhitelist[rewardsToken], \"AWM:E-423\");\n\n    // Withdraw Rewards to Receiver\n    amount = AaveSmartWalletB(wallet).withdrawRewards(receiver, rewardsToken, rewardsAmount);\n\n    // Log Event\n    emit WalletRewarded(contractAddress, tokenId, receiver, rewardsToken, amount);\n  }\n\n  function executeForAccount(\n    address contractAddress,\n    uint256 tokenId,\n    address externalAddress,\n    uint256 ethValue,\n    bytes memory encodedParams\n  )\n    external\n    override\n    onlyControllerOrExecutor\n    returns (bytes memory)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    return AaveSmartWalletB(wallet).executeForAccount(externalAddress, ethValue, encodedParams);\n  }\n\n  function refreshPrincipal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    onlyControllerOrExecutor\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    AaveSmartWalletB(wallet).refreshPrincipal(assetToken);\n  }\n\n  function getWalletAddressById(\n    address contractAddress,\n    uint256 tokenId,\n    address /* creator */,\n    uint256 /* annuityPct */\n  )\n    external\n    override\n    onlyControllerOrExecutor\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Create Smart-Wallet if none exists\n    if (wallet == address(0x0)) {\n      wallet = _createWallet();\n      _wallets[uuid] = wallet;\n      emit NewSmartWallet(contractAddress, tokenId, wallet, address(0), 0);\n    }\n\n    return wallet;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  function setAaveBridge(address aaveBridge) external onlyOwner {\n    require(aaveBridge != address(0x0), \"AWM:E-403\");\n    _aaveBridge = aaveBridge;\n    emit AaveBridgeSet(aaveBridge);\n  }\n\n  function setChargedSettings(address settings) external onlyOwner {\n    require(settings != address(0x0), \"AWM:E-403\");\n    _chargedSettings = IChargedSettings(settings);\n    emit ChargedSettingsSet(settings);\n  }\n\n  // ref: https://docs.aave.com/developers/developing-on-aave/the-protocol/lendingpool\n  function setReferralCode(uint256 referralCode) external onlyOwner {\n    _referralCode = referralCode;\n  }\n\n  function setValidRewardsToken(address rewardsToken, bool state) external onlyOwner {\n    _rewardsTokenWhitelist[rewardsToken] = state;\n    emit ValidRewardsTokenSet(rewardsToken, state);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _createWallet()\n    internal\n    returns (address)\n  {\n    address newWallet = _createClone(_walletTemplate);\n    AaveSmartWalletB(newWallet).initialize(_aaveBridge);\n    return newWallet;\n  }\n}"
    },
    "contracts/v1/yield/aave/v2/AaveBridgeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// AaveBridgeV2.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\nimport \"./IATokenV2.sol\";\nimport \"./ILendingPoolV2.sol\";\nimport \"./ILendingPoolAddressesProviderV2.sol\";\n\nimport \"../../../interfaces/IAaveBridge.sol\";\nimport \"../../../lib/BlackholePrevention.sol\";\n\ncontract AaveBridgeV2 is Ownable, IAaveBridge, BlackholePrevention {\n  using SafeMath for uint256;\n  using SafeCast for uint256;\n  using SafeERC20 for IERC20;\n  using ReserveLogic for ReserveLogic.ReserveData;\n\n  ILendingPoolAddressesProviderV2 public provider;\n  ILendingPoolV2 public lendingPool;\n\n  constructor (address lendingPoolProvider) public {\n    provider = ILendingPoolAddressesProviderV2(lendingPoolProvider);\n    lendingPool = ILendingPoolV2(provider.getLendingPool());\n  }\n\n  function getReserveInterestToken(address assetToken) external view override returns (address aTokenAddress) {\n    return _getReserveInterestToken(assetToken);\n  }\n\n  function isReserveActive(address assetToken) external view override returns (bool) {\n    return _isReserveActive(assetToken);\n  }\n\n  function getTotalBalance(address account, address assetToken) external view override returns (uint256) {\n    address aTokenAddress = _getReserveInterestToken(assetToken);\n    if (aTokenAddress == address(0x0)) { return 0; }\n    return IATokenV2(aTokenAddress).balanceOf(account);\n  }\n\n  function deposit(\n    address assetToken,\n    uint256 assetAmount,\n    uint256 referralCode\n  )\n    external\n    override\n    returns (uint256)\n  {\n    address self = address(this);\n    address aTokenAddress = _getReserveInterestToken(assetToken);\n    require(_isReserveActive(assetToken), \"ABV2:E-424\");\n\n    IERC20 token = IERC20(assetToken);\n    IATokenV2 aToken = IATokenV2(aTokenAddress);\n\n    if (token.allowance(address(this), address(lendingPool)) < assetAmount) {\n      token.approve(address(lendingPool), uint256(-1));\n    }\n\n    // Deposit Assets into Aave\n    uint256 preBalance = aToken.balanceOf(self);\n    lendingPool.deposit(assetToken, assetAmount, self, referralCode.toUint16());\n    uint256 postBalance = aToken.balanceOf(self);\n    uint256 aTokensAmount = postBalance.sub(preBalance);\n\n    // Transfer back the Interest Tokens\n    _sendToken(msg.sender, aTokenAddress, aTokensAmount);\n\n    // Return amount of aTokens transfered\n    return aTokensAmount;\n  }\n\n  function withdraw(\n    address receiver,\n    address assetToken,\n    uint256 assetAmount\n  )\n    external\n    override\n  {\n    address self = address(this);\n    require(_isReserveActive(assetToken), \"ABV2:E-424\");\n\n    // Redeem aTokens for Asset Tokens\n    lendingPool.withdraw(assetToken, assetAmount, self);\n\n    // Transfer back the Asset Tokens\n    _sendToken(receiver, assetToken, assetAmount);\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external onlyOwner {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawErc20(address payable receiver, address tokenAddress, uint256 amount) external onlyOwner {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external onlyOwner {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _sendToken(address to, address token, uint256 amount) internal {\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  function _getReserveInterestToken(address assetToken) internal view returns (address aTokenAddress) {\n    ReserveLogic.ReserveData memory config = lendingPool.getReserveData(assetToken);\n    return config.aTokenAddress;\n  }\n\n  function _isReserveActive(address assetToken) internal view returns (bool) {\n    ReserveLogic.ReserveData memory config = lendingPool.getReserveData(assetToken);\n    uint256 isActiveFlag = 2 ** 56; // bit 56: reserve is active\n    return (config.configuration.data & isActiveFlag) == isActiveFlag;\n  }\n}\n"
    },
    "contracts/v1/yield/aave/v2/IATokenV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.0;\n\ninterface IATokenV2 {\n  function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/v1/yield/aave/v2/ILendingPoolAddressesProviderV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.0;\n\ninterface ILendingPoolAddressesProviderV2 {\n  function getLendingPool() external view returns (address);\n}"
    },
    "contracts/v1/yield/aave/v2/ILendingPoolV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./ILendingPoolAddressesProviderV2.sol\";\n\nlibrary ReserveConfiguration {\n  struct Map {\n    uint256 data;\n  }\n}\n\nlibrary ReserveLogic {\n  struct ReserveData {\n    ReserveConfiguration.Map configuration;\n    uint128 liquidityIndex;\n    uint128 variableBorrowIndex;\n    uint128 currentLiquidityRate;\n    uint128 currentVariableBorrowRate;\n    uint128 currentStableBorrowRate;\n    uint40 lastUpdateTimestamp;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    address interestRateStrategyAddress;\n    uint8 id;\n  }\n}\n\ninterface ILendingPoolV2 {\n  function deposit(address reserve, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n  function withdraw(address reserve, uint256 amount, address to) external;\n  function getReserveData(address asset) external view returns (ReserveLogic.ReserveData memory);\n}\n"
    },
    "contracts/v1/yield/generic/ERC20/GenericSmartWallet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericSmartWallet.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../lib/SmartWalletBase.sol\";\n\n\n/**\n * @notice Generic ERC20-Token Smart-Wallet Bridge\n * @dev Non-upgradeable Contract\n */\ncontract GenericSmartWallet is SmartWalletBase {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize()\n    public\n  {\n    SmartWalletBase.initializeBase();\n  }\n\n  function isReserveActive(address assetToken)\n    external\n    override\n    view\n    returns (bool)\n  {\n    return _getPrincipal(assetToken) == 0;\n  }\n\n  function getReserveInterestToken(address assetToken)\n    external\n    override\n    view\n    returns (address)\n  {\n    return assetToken;\n  }\n\n  function getPrincipal(address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    return _getPrincipal(assetToken);\n  }\n\n  function getInterest(address /* assetToken */)\n    external\n    override\n    returns (uint256 creatorInterest, uint256 ownerInterest)\n  {\n    return (0, 0);\n  }\n\n  function getTotal(address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    return _getPrincipal(assetToken);\n  }\n\n  function getRewards(address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    return IERC20(assetToken).balanceOf(address(this));\n  }\n\n  function deposit(address assetToken, uint256 assetAmount, uint256 /* referralCode */)\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    // Track Principal\n    _trackAssetToken(assetToken);\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].add(assetAmount);\n  }\n\n  function withdraw(address receiver, address /* creatorRedirect */, address assetToken)\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    creatorAmount = 0;\n    receiverAmount = _getPrincipal(assetToken);\n    // Track Principal\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].sub(receiverAmount);\n    IERC20(assetToken).safeTransfer(receiver, receiverAmount);\n  }\n\n  function withdrawAmount(address receiver, address /* creatorRedirect */, address assetToken, uint256 assetAmount)\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    creatorAmount = 0;\n    receiverAmount = _getPrincipal(assetToken);\n    if (receiverAmount >= assetAmount) {\n      receiverAmount = assetAmount;\n    }\n    // Track Principal\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].sub(receiverAmount);\n    IERC20(assetToken).safeTransfer(receiver, receiverAmount);\n  }\n\n  function withdrawAmountForCreator(\n    address /* receiver */,\n    address /* assetToken */,\n    uint256 /* assetID */\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 receiverAmount)\n  {\n    return 0;\n  }\n\n  function withdrawRewards(address receiver, address rewardsTokenAddress, uint256 rewardsAmount)\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    address self = address(this);\n    IERC20 rewardsToken = IERC20(rewardsTokenAddress);\n\n    uint256 walletBalance = rewardsToken.balanceOf(self);\n    require(walletBalance >= rewardsAmount, \"GSW:E-411\");\n\n    // Transfer Rewards to Receiver\n    rewardsToken.safeTransfer(receiver, rewardsAmount);\n    return rewardsAmount;\n  }\n\n}\n"
    },
    "contracts/v1/yield/generic/ERC20/GenericSmartWalletB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericSmartWalletB.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../lib/SmartWalletBaseB.sol\";\n\n\n/**\n * @notice Generic ERC20-Token Smart-Wallet Bridge\n * @dev Non-upgradeable Contract\n */\ncontract GenericSmartWalletB is SmartWalletBaseB {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize()\n    public\n  {\n    SmartWalletBaseB.initializeBase();\n  }\n\n  function isReserveActive(address assetToken)\n    external\n    override\n    view\n    returns (bool)\n  {\n    return _getPrincipal(assetToken) == 0;\n  }\n\n  function getReserveInterestToken(address assetToken)\n    external\n    override\n    view\n    returns (address)\n  {\n    return assetToken;\n  }\n\n  function getPrincipal(address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    return _getPrincipal(assetToken);\n  }\n\n  function getInterest(address /* assetToken */,  uint256 /* creatorPct */)\n    external\n    override\n    returns (uint256 creatorInterest, uint256 ownerInterest)\n  {\n    return (0, 0);\n  }\n\n  function getTotal(address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    return _getPrincipal(assetToken);\n  }\n\n  function getRewards(address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    return IERC20(assetToken).balanceOf(address(this));\n  }\n\n  function deposit(address assetToken, uint256 assetAmount, uint256 /* referralCode */)\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    // Track Principal\n    _trackAssetToken(assetToken);\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].add(assetAmount);\n  }\n\n  function withdraw(address receiver, address /* creator */, uint256 /* creatorPct */, address assetToken)\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    creatorAmount = 0;\n    receiverAmount = _getPrincipal(assetToken);\n    // Track Principal\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].sub(receiverAmount);\n    IERC20(assetToken).safeTransfer(receiver, receiverAmount);\n  }\n\n  function withdrawAmount(address receiver, address /* creator */, uint256 /* creatorPct */, address assetToken, uint256 assetAmount)\n    external\n    override\n    onlyWalletManager\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    creatorAmount = 0;\n    receiverAmount = _getPrincipal(assetToken);\n    if (receiverAmount >= assetAmount) {\n      receiverAmount = assetAmount;\n    }\n    // Track Principal\n    _assetPrincipalBalance[assetToken] = _assetPrincipalBalance[assetToken].sub(receiverAmount);\n    IERC20(assetToken).safeTransfer(receiver, receiverAmount);\n  }\n\n  function withdrawAmountForCreator(\n    address /* receiver */,\n    uint256 /* creatorPct */,\n    address /* assetToken */,\n    uint256 /* assetID */\n  )\n    external\n    override\n    onlyWalletManager\n    returns (uint256 receiverAmount)\n  {\n    return 0;\n  }\n\n  function withdrawRewards(address receiver, address rewardsTokenAddress, uint256 rewardsAmount)\n    external\n    override\n    onlyWalletManager\n    returns (uint256)\n  {\n    address self = address(this);\n    IERC20 rewardsToken = IERC20(rewardsTokenAddress);\n\n    uint256 walletBalance = rewardsToken.balanceOf(self);\n    require(walletBalance >= rewardsAmount, \"GSW:E-411\");\n\n    // Transfer Rewards to Receiver\n    rewardsToken.safeTransfer(receiver, rewardsAmount);\n    return rewardsAmount;\n  }\n\n  function refreshPrincipal(address assetToken) external virtual override onlyWalletManager {\n    _assetPrincipalBalance[assetToken] = IERC20(assetToken).balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/v1/yield/generic/ERC20/GenericWalletManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericWalletManager.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../lib/WalletManagerBase.sol\";\nimport \"./GenericSmartWallet.sol\";\n\n/**\n * @notice Generic ERC20 Wallet Manager\n * @dev Non-upgradeable Contract\n */\ncontract GenericWalletManager is WalletManagerBase {\n  using SafeMath for uint256;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor () public {\n    _walletTemplate = address(new GenericSmartWallet());\n  }\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isReserveActive(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    view\n    returns (bool)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return false; }\n    return GenericSmartWallet(_wallets[uuid]).isReserveActive(assetToken);\n  }\n\n  function getReserveInterestToken(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    view\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return address(0x0); }\n    return GenericSmartWallet(_wallets[uuid]).getReserveInterestToken(assetToken);\n  }\n\n  /**\n    * @notice Gets the Available Balance of Assets held in the Token\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Available Balance of the Token\n    */\n  function getTotal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return GenericSmartWallet(_wallets[uuid]).getTotal(assetToken);\n  }\n\n  /**\n    * @notice Gets the Principal-Amount of Assets held in the Smart-Wallet\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Principal-Balance of the Smart-Wallet\n    */\n  function getPrincipal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return GenericSmartWallet(_wallets[uuid]).getPrincipal(assetToken);\n  }\n\n  /**\n    * @notice Gets the Interest-Amount that the Token has generated\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return creatorInterest The NFT Creator's portion of the Interest\n    * @return ownerInterest The NFT Owner's portion of the Interest\n    */\n  function getInterest(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256 creatorInterest, uint256 ownerInterest)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] != address(0x0)) {\n    return GenericSmartWallet(_wallets[uuid]).getInterest(assetToken);\n    }\n  }\n\n  function getRewards(address contractAddress, uint256 tokenId, address rewardToken)\n    external\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return GenericSmartWallet(_wallets[uuid]).getRewards(rewardToken);\n  }\n\n  function energize(address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount)\n    external\n    override\n    onlyController\n    returns (uint256 yieldTokensAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Deposit into Smart-Wallet\n    yieldTokensAmount = GenericSmartWallet(wallet).deposit(assetToken, assetAmount, 0);\n\n    // Log Event\n    emit WalletEnergized(contractAddress, tokenId, assetToken, assetAmount, yieldTokensAmount);\n  }\n\n  function discharge(address /* receiver */, address /* contractAddress */, uint256 /* tokenId */, address /* assetToken */, address /* creatorRedirect */)\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    return (0, 0);\n  }\n\n  function dischargeAmount(address /* receiver */, address /* contractAddress */, uint256 /* tokenId */, address /* assetToken */, uint256 /* assetAmount */, address /* creatorRedirect */)\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    return (0, 0);\n  }\n\n  function dischargeAmountForCreator(\n    address /* receiver */,\n    address /* contractAddress */,\n    uint256 /* tokenId */,\n    address /* creator */,\n    address /* assetToken */,\n    uint256 /* assetAmount */\n  )\n    external\n    override\n    onlyController\n    returns (uint256 receiverAmount)\n  {\n    return 0;\n  }\n\n  function release(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"GWM:E-403\");\n\n    // Release Principal + Interest\n    principalAmount = GenericSmartWallet(wallet).getPrincipal(assetToken);\n    (creatorAmount, receiverAmount) = GenericSmartWallet(wallet).withdraw(receiver, creatorRedirect, assetToken);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function releaseAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"GWM:E-403\");\n\n    // Release from interest first + principal if needed\n    principalAmount = GenericSmartWallet(wallet).getPrincipal(assetToken);\n    (creatorAmount, receiverAmount) = GenericSmartWallet(wallet).withdrawAmount(receiver, creatorRedirect, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function withdrawRewards(address receiver, address contractAddress, uint256 tokenId, address rewardsToken, uint256 rewardsAmount)\n    external\n    override\n    onlyController\n    returns (uint256 amount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"GWM:E-403\");\n\n    // Withdraw Rewards to Receiver\n    amount = GenericSmartWallet(wallet).withdrawRewards(receiver, rewardsToken, rewardsAmount);\n\n    // Log Event\n    emit WalletRewarded(contractAddress, tokenId, receiver, rewardsToken, amount);\n  }\n\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams)\n    external\n    override\n    onlyController\n    returns (bytes memory)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    return GenericSmartWallet(wallet).executeForAccount(externalAddress, ethValue, encodedParams);\n  }\n\n  function refreshPrincipal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    onlyControllerOrExecutor\n  {\n    // no-op\n  }\n\n  function getWalletAddressById(address contractAddress, uint256 tokenId, address creator, uint256 annuityPct)\n    external\n    override\n    onlyController\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Create Smart-Wallet if none exists\n    if (wallet == address(0x0)) {\n      wallet = _createWallet();\n      _wallets[uuid] = wallet;\n\n      if (creator != address(0x0)) {\n        GenericSmartWallet(wallet).setNftCreator(creator, annuityPct);\n      }\n\n      emit NewSmartWallet(contractAddress, tokenId, wallet, creator, annuityPct);\n    }\n\n    return wallet;\n  }\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _createWallet()\n    internal\n    returns (address)\n  {\n    address newWallet = _createClone(_walletTemplate);\n    GenericSmartWallet(newWallet).initialize();\n    return newWallet;\n  }\n\n}\n"
    },
    "contracts/v1/yield/generic/ERC20/GenericWalletManagerB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericWalletManagerB.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../lib/WalletManagerBase.sol\";\nimport \"./GenericSmartWalletB.sol\";\n\n/**\n * @notice Generic ERC20 Wallet Manager B\n * @dev Non-upgradeable Contract\n */\ncontract GenericWalletManagerB is WalletManagerBase {\n  using SafeMath for uint256;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor () public {\n    _walletTemplate = address(new GenericSmartWalletB());\n  }\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isReserveActive(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    view\n    returns (bool)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return false; }\n    return GenericSmartWalletB(_wallets[uuid]).isReserveActive(assetToken);\n  }\n\n  function getReserveInterestToken(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    view\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return address(0x0); }\n    return GenericSmartWalletB(_wallets[uuid]).getReserveInterestToken(assetToken);\n  }\n\n  /**\n    * @notice Gets the Available Balance of Assets held in the Token\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Available Balance of the Token\n    */\n  function getTotal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return GenericSmartWalletB(_wallets[uuid]).getTotal(assetToken);\n  }\n\n  /**\n    * @notice Gets the Principal-Amount of Assets held in the Smart-Wallet\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return  The Principal-Balance of the Smart-Wallet\n    */\n  function getPrincipal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return GenericSmartWalletB(_wallets[uuid]).getPrincipal(assetToken);\n  }\n\n  /**\n    * @notice Gets the Interest-Amount that the Token has generated\n    * @param contractAddress The Address to the External Contract of the Token\n    * @param tokenId The ID of the Token within the External Contract\n    * @return creatorInterest The NFT Creator's portion of the Interest\n    * @return ownerInterest The NFT Owner's portion of the Interest\n    */\n  function getInterest(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    returns (uint256 creatorInterest, uint256 ownerInterest)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] != address(0x0)) {\n    return GenericSmartWalletB(_wallets[uuid]).getInterest(assetToken, 0);\n    }\n  }\n\n  function getRewards(address contractAddress, uint256 tokenId, address rewardToken)\n    external\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    if (_wallets[uuid] == address(0x0)) { return 0; }\n    return GenericSmartWalletB(_wallets[uuid]).getRewards(rewardToken);\n  }\n\n  function energize(address contractAddress, uint256 tokenId, address assetToken, uint256 assetAmount)\n    external\n    override\n    onlyController\n    returns (uint256 yieldTokensAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Deposit into Smart-Wallet\n    yieldTokensAmount = GenericSmartWalletB(wallet).deposit(assetToken, assetAmount, 0);\n\n    // Log Event\n    emit WalletEnergized(contractAddress, tokenId, assetToken, assetAmount, yieldTokensAmount);\n  }\n\n  function discharge(address /* receiver */, address /* contractAddress */, uint256 /* tokenId */, address /* assetToken */, address /* creatorRedirect */)\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    return (0, 0);\n  }\n\n  function dischargeAmount(address /* receiver */, address /* contractAddress */, uint256 /* tokenId */, address /* assetToken */, uint256 /* assetAmount */, address /* creatorRedirect */)\n    external\n    override\n    onlyController\n    returns (uint256 creatorAmount, uint256 receiverAmount)\n  {\n    return (0, 0);\n  }\n\n  function dischargeAmountForCreator(\n    address /* receiver */,\n    address /* contractAddress */,\n    uint256 /* tokenId */,\n    address /* creator */,\n    address /* assetToken */,\n    uint256 /* assetAmount */\n  )\n    external\n    override\n    onlyController\n    returns (uint256 receiverAmount)\n  {\n    return 0;\n  }\n\n  function release(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"GWM:E-403\");\n\n    // Release Principal + Interest\n    principalAmount = GenericSmartWalletB(wallet).getPrincipal(assetToken);\n    (creatorAmount, receiverAmount) = GenericSmartWalletB(wallet).withdraw(receiver, creatorRedirect, 0, assetToken);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function releaseAmount(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address assetToken,\n    uint256 assetAmount,\n    address creatorRedirect\n  )\n    external\n    override\n    onlyController\n    returns (uint256 principalAmount, uint256 creatorAmount, uint256 receiverAmount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"GWM:E-403\");\n\n    // Release from interest first + principal if needed\n    principalAmount = GenericSmartWalletB(wallet).getPrincipal(assetToken);\n    (creatorAmount, receiverAmount) = GenericSmartWalletB(wallet).withdrawAmount(receiver, creatorRedirect, 0, assetToken, assetAmount);\n\n    // Log Event\n    emit WalletReleased(contractAddress, tokenId, receiver, assetToken, principalAmount, creatorAmount, receiverAmount);\n  }\n\n  function withdrawRewards(address receiver, address contractAddress, uint256 tokenId, address rewardsToken, uint256 rewardsAmount)\n    external\n    override\n    onlyControllerOrExecutor\n    returns (uint256 amount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    require(wallet != address(0x0), \"GWM:E-403\");\n\n    // Withdraw Rewards to Receiver\n    amount = GenericSmartWalletB(wallet).withdrawRewards(receiver, rewardsToken, rewardsAmount);\n\n    // Log Event\n    emit WalletRewarded(contractAddress, tokenId, receiver, rewardsToken, amount);\n  }\n\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams)\n    external\n    override\n    onlyControllerOrExecutor\n    returns (bytes memory)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    return GenericSmartWalletB(wallet).executeForAccount(externalAddress, ethValue, encodedParams);\n  }\n\n  function refreshPrincipal(address contractAddress, uint256 tokenId, address assetToken)\n    external\n    override\n    onlyControllerOrExecutor\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n    GenericSmartWalletB(wallet).refreshPrincipal(assetToken);\n  }\n\n  function getWalletAddressById(address contractAddress, uint256 tokenId, address /* creator */, uint256 /* annuityPct */)\n    external\n    override\n    onlyControllerOrExecutor\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address wallet = _wallets[uuid];\n\n    // Create Smart-Wallet if none exists\n    if (wallet == address(0x0)) {\n      wallet = _createWallet();\n      _wallets[uuid] = wallet;\n      emit NewSmartWallet(contractAddress, tokenId, wallet, address(0), 0);\n    }\n\n    return wallet;\n  }\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _createWallet()\n    internal\n    returns (address)\n  {\n    address newWallet = _createClone(_walletTemplate);\n    GenericSmartWalletB(newWallet).initialize();\n    return newWallet;\n  }\n\n}\n"
    },
    "contracts/v1/yield/generic/ERC721/GenericBasketManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericBasketManager.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"../../../interfaces/IBasketManager.sol\";\nimport \"../../../interfaces/ISmartBasket.sol\";\nimport \"../../../lib/BlackholePrevention.sol\";\nimport \"../../../lib/TokenInfo.sol\";\nimport \"./GenericSmartBasket.sol\";\n\n/**\n * @notice Generic ERC721 Basket Manager\n * @dev Non-upgradeable Contract\n */\ncontract GenericBasketManager is Ownable, BlackholePrevention, IBasketManager {\n  using Counters for Counters.Counter;\n  using TokenInfo for address;\n\n  // The Controller Contract Address\n  address internal _controller;\n\n  // Template Contract for creating Token Smart-Baskets\n  address internal _basketTemplate;\n\n  //       TokenID => Token Smart-Basket Address\n  mapping (uint256 => address) internal _baskets;\n\n  mapping (uint256 => Counters.Counter) internal _totalTokens;\n\n  // State of Basket Manager\n  bool internal _paused;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor () public {\n    _basketTemplate = address(new GenericSmartBasket());\n  }\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isPaused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function getTokenTotalCount(\n    address contractAddress,\n    uint256 tokenId\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    return _totalTokens[uuid].current();\n  }\n\n  function getTokenCountByType(\n    address contractAddress,\n    uint256 tokenId,\n    address basketTokenAddress,\n    uint256 basketTokenId\n  )\n    external\n    override\n    returns (uint256)\n  {\n    address basket = getBasketAddressById(contractAddress, tokenId);\n    return GenericSmartBasket(basket).getTokenCountByType(basketTokenAddress, basketTokenId);\n  }\n\n  function prepareTransferAmount(uint256 /* nftTokenAmount */) external override onlyController {\n    // no-op\n  }\n\n  function addToBasket(\n    address contractAddress,\n    uint256 tokenId,\n    address basketTokenAddress,\n    uint256 basketTokenId\n  )\n    public\n    override\n    onlyController\n    whenNotPaused\n    returns (bool added)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n\n    added = GenericSmartBasket(basket).addToBasket(basketTokenAddress, basketTokenId);\n\n    // Log Event\n    if (added) {\n      _totalTokens[uuid].increment();\n      emit BasketAdd(contractAddress, tokenId, basketTokenAddress, basketTokenId, 1);\n    }\n  }\n\n\n  function removeFromBasket(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address basketTokenAddress,\n    uint256 basketTokenId\n  )\n    public\n    override\n    onlyController\n    returns (bool removed)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    require(basket != address(0x0), \"GBM:E-403\");\n\n    removed = GenericSmartBasket(basket).removeFromBasket(receiver, basketTokenAddress, basketTokenId);\n\n    // Log Event\n    if (removed) {\n      _totalTokens[uuid].decrement();\n      emit BasketRemove(receiver, contractAddress, tokenId, basketTokenAddress, basketTokenId, 1);\n    }\n  }\n\n  function withdrawRewards(address receiver, address contractAddress, uint256 tokenId, address rewardsToken, uint256 rewardsAmount)\n    external\n    override\n    onlyController\n    returns (uint256 amount)\n  {\n    // no-op\n  }\n\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams)\n    public\n    override\n    onlyController\n    returns (bytes memory)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    return GenericSmartBasket(basket).executeForAccount(externalAddress, ethValue, encodedParams);\n  }\n\n  function getBasketAddressById(address contractAddress, uint256 tokenId)\n    public\n    override\n    onlyController\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n\n    // Create Smart-Basket if none exists\n    if (basket == address(0x0)) {\n      basket = _createBasket();\n      _baskets[uuid] = basket;\n\n      emit NewSmartBasket(contractAddress, tokenId, basket);\n    }\n\n    return basket;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /**\n    * @dev Sets the Paused-state of the Basket Manager\n    */\n  function setPausedState(bool paused) external onlyOwner {\n    _paused = paused;\n    emit PausedStateSet(paused);\n  }\n\n  /**\n    * @dev Connects to the Charged Particles Controller\n    */\n  function setController(address controller) external onlyOwner {\n    _controller = controller;\n    emit ControllerSet(controller);\n  }\n\n  function withdrawEther(address contractAddress, uint256 tokenId, address payable receiver, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawEther(receiver, amount);\n    return ISmartBasket(basket).withdrawEther(receiver, amount);\n  }\n\n  function withdrawERC20(address contractAddress, uint256 tokenId, address payable receiver, address tokenAddress, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawERC20(receiver, tokenAddress, amount);\n    return ISmartBasket(basket).withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawERC721(receiver, nftTokenAddress, nftTokenId);\n    return ISmartBasket(basket).withdrawERC721(receiver, nftTokenAddress, nftTokenId);\n  }\n\n  function withdrawERC1155(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawERC1155(receiver, nftTokenAddress, nftTokenId, amount);\n    return ISmartBasket(basket).withdrawERC1155(receiver, nftTokenAddress, nftTokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _getTokenUUID(address contractAddress, uint256 tokenId) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(contractAddress, tokenId)));\n  }\n\n  function _createBasket()\n    internal\n    returns (address)\n  {\n    address newBasket = _createClone(_basketTemplate);\n    GenericSmartBasket(newBasket).initialize();\n    return newBasket;\n  }\n\n  /**\n    * @dev Creates Contracts from a Template via Cloning\n    * see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n    */\n  function _createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  /// @dev Throws if called by any account other than the Controller contract\n  modifier onlyController() {\n    require(_controller == msg.sender, \"GBM:E-108\");\n    _;\n  }\n\n  // Throws if called by any account other than the Charged Particles Escrow Controller.\n  modifier whenNotPaused() {\n    require(_paused != true, \"GBM:E-101\");\n    _;\n  }\n\n}\n"
    },
    "contracts/v1/yield/generic/ERC721/GenericBasketManagerB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericBasketManager.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"../../../interfaces/IBasketManager.sol\";\nimport \"../../../interfaces/ISmartBasket.sol\";\nimport \"../../../interfaces/ITokenInfoProxy.sol\";\nimport \"../../../lib/BlackholePrevention.sol\";\nimport \"../../../lib/TokenInfo.sol\";\nimport \"../../../lib/NftTokenType.sol\";\nimport \"./GenericSmartBasketB.sol\";\n\n/**\n * @notice Generic ERC721 Basket Manager\n * @dev Non-upgradeable Contract\n */\ncontract GenericBasketManagerB is Ownable, BlackholePrevention, IBasketManager {\n  using Counters for Counters.Counter;\n  using TokenInfo for address;\n  using NftTokenType for address;\n\n  ITokenInfoProxy internal _tokenInfoProxy;\n\n  // The Controller Contract Address\n  address internal _controller;\n\n  // The Executor Contract Address\n  address internal _executor;\n\n  // Template Contract for creating Token Smart-Baskets\n  address internal _basketTemplate;\n\n  //       TokenID => Token Smart-Basket Address\n  mapping (uint256 => address) internal _baskets;\n\n  // Prepared Amount\n  uint256 internal _preparedAmount;\n\n  // State of Basket Manager\n  bool internal _paused;\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  constructor () public {\n    _basketTemplate = address(new GenericSmartBasketB());\n  }\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function isPaused() external view override returns (bool) {\n    return _paused;\n  }\n\n  function getTokenTotalCount(\n    address contractAddress,\n    uint256 tokenId\n  )\n    external\n    view\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    if (basket == address(0)) { return 0; }\n    return GenericSmartBasketB(basket).getNestedNftCount();\n  }\n\n  function getTokenCountByType(\n    address contractAddress,\n    uint256 tokenId,\n    address basketTokenAddress,\n    uint256 basketTokenId\n  )\n    external\n    override\n    returns (uint256)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    if (basket == address(0)) { return 0; }\n    return GenericSmartBasketB(basket).getTokenCountByType(basketTokenAddress, basketTokenId);\n  }\n\n  function prepareTransferAmount(uint256 nftTokenAmount) external override onlyController {\n    _preparedAmount = nftTokenAmount;\n  }\n\n  function addToBasket(\n    address contractAddress,\n    uint256 tokenId,\n    address basketTokenAddress,\n    uint256 basketTokenId\n  )\n    public\n    override\n    onlyController\n    whenNotPaused\n    returns (bool added)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    require(basket != address(0x0), \"GBM:E-403\");\n\n    uint256 nftTokenAmount = 1;\n    if (_preparedAmount > 0) {\n      nftTokenAmount = _preparedAmount;\n      _preparedAmount = 0;\n    }\n\n    added = GenericSmartBasketB(basket).addToBasket(basketTokenAddress, basketTokenId, nftTokenAmount);\n    if (added) {\n      emit BasketAdd(contractAddress, tokenId, basketTokenAddress, basketTokenId, nftTokenAmount);\n    }\n  }\n\n\n  function removeFromBasket(\n    address receiver,\n    address contractAddress,\n    uint256 tokenId,\n    address basketTokenAddress,\n    uint256 basketTokenId\n  )\n    public\n    override\n    onlyController\n    returns (bool removed)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    require(basket != address(0x0), \"GBM:E-403\");\n\n    uint256 nftTokenAmount = 1;\n    if (_preparedAmount > 0) {\n      nftTokenAmount = _preparedAmount;\n      _preparedAmount = 0;\n    }\n\n    removed = GenericSmartBasketB(basket).removeFromBasket(receiver, basketTokenAddress, basketTokenId, nftTokenAmount);\n    if (removed) {\n      emit BasketRemove(receiver, contractAddress, tokenId, basketTokenAddress, basketTokenId, nftTokenAmount);\n    }\n  }\n\n  function withdrawRewards(address receiver, address contractAddress, uint256 tokenId, address rewardsToken, uint256 rewardsAmount)\n    external\n    override\n    onlyControllerOrExecutor\n    returns (uint256 amount)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    require(basket != address(0x0), \"GWM:E-403\");\n\n    // Withdraw Rewards to Receiver\n    amount = GenericSmartBasketB(basket).withdrawRewards(receiver, rewardsToken, rewardsAmount);\n\n    // Log Event\n    emit BasketRewarded(contractAddress, tokenId, receiver, rewardsToken, amount);\n  }\n\n\n  function executeForAccount(address contractAddress, uint256 tokenId, address externalAddress, uint256 ethValue, bytes memory encodedParams)\n    public\n    override\n    onlyControllerOrExecutor\n    returns (bytes memory)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    require(basket != address(0x0), \"GBM:E-403\");\n    return GenericSmartBasketB(basket).executeForAccount(externalAddress, ethValue, encodedParams);\n  }\n\n  function getBasketAddressById(address contractAddress, uint256 tokenId)\n    public\n    override\n    onlyControllerOrExecutor\n    returns (address)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n\n    // Create Smart-Basket if none exists\n    if (basket == address(0x0)) {\n      basket = _createBasket();\n      _baskets[uuid] = basket;\n\n      emit NewSmartBasket(contractAddress, tokenId, basket);\n    }\n\n    return basket;\n  }\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |__________________________________*/\n\n  /**\n    * @dev Sets the Paused-state of the Basket Manager\n    */\n  function setPausedState(bool paused) external onlyOwner {\n    _paused = paused;\n    emit PausedStateSet(paused);\n  }\n\n  /**\n    * @dev Connects to the Charged Particles Controller\n    */\n  function setController(address controller) external onlyOwner {\n    _controller = controller;\n    emit ControllerSet(controller);\n  }\n\n  /**\n    * @dev Connects to the ExecForAccount Controller\n    */\n  function setExecutor(address executor) external onlyOwner {\n    _executor = executor;\n    emit ExecutorSet(executor);\n  }\n\n  /**\n    * @dev Connects to the Charged Particles Controller\n    */\n  function setTokenInfoProxy(address tokenInfoProxy) external onlyOwner {\n    _tokenInfoProxy = ITokenInfoProxy(tokenInfoProxy);\n  }\n\n  function withdrawEther(address contractAddress, uint256 tokenId, address payable receiver, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawEther(receiver, amount);\n    return ISmartBasket(basket).withdrawEther(receiver, amount);\n  }\n\n  function withdrawERC20(address contractAddress, uint256 tokenId, address payable receiver, address tokenAddress, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawERC20(receiver, tokenAddress, amount);\n    return ISmartBasket(basket).withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawERC721(receiver, nftTokenAddress, nftTokenId);\n    return ISmartBasket(basket).withdrawERC721(receiver, nftTokenAddress, nftTokenId);\n  }\n\n  function withdrawERC1155(address contractAddress, uint256 tokenId, address payable receiver, address nftTokenAddress, uint256 nftTokenId, uint256 amount)\n    external\n    virtual\n    override\n    onlyOwner\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    address basket = _baskets[uuid];\n    _withdrawERC1155(receiver, nftTokenAddress, nftTokenId, amount);\n    return ISmartBasket(basket).withdrawERC1155(receiver, nftTokenAddress, nftTokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  function _createBasket()\n    internal\n    returns (address)\n  {\n    address newBasket = _createClone(_basketTemplate);\n    GenericSmartBasketB(newBasket).initialize(_tokenInfoProxy);\n    return newBasket;\n  }\n\n  /**\n    * @dev Creates Contracts from a Template via Cloning\n    * see: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\n    */\n  function _createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n\n  /***********************************|\n  |             Modifiers             |\n  |__________________________________*/\n\n  /// @dev Throws if called by any account other than the Controller contract\n  modifier onlyController() {\n    require(_controller == msg.sender, \"GBM:E-108\");\n    _;\n  }\n\n  /// @dev Throws if called by any account other than the Controller or Executor contract\n  modifier onlyControllerOrExecutor() {\n    require(_executor == msg.sender || _controller == msg.sender, \"WMB:E-108\");\n    _;\n  }\n\n  // Throws if called by any account other than the Charged Particles Escrow Controller.\n  modifier whenNotPaused() {\n    require(_paused != true, \"GBM:E-101\");\n    _;\n  }\n\n}\n"
    },
    "contracts/v1/yield/generic/ERC721/GenericSmartBasket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericSmartWallet.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../../../interfaces/ISmartBasket.sol\";\nimport \"../../../lib/BlackholePrevention.sol\";\nimport \"../../../lib/NftTokenType.sol\";\n\n\n/**\n * @notice Generic ERC721-Token Smart-Basket\n * @dev Non-upgradeable Contract\n */\ncontract GenericSmartBasket is ISmartBasket, BlackholePrevention, IERC721Receiver {\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using NftTokenType for address;\n\n  address internal _basketManager;\n\n  // NFT contract address => Token Ids in Basket\n  mapping (address => mapping(uint256 => EnumerableSet.UintSet)) internal _nftContractTokens;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize() public {\n    require(_basketManager == address(0x0), \"GSB:E-002\");\n    _basketManager = msg.sender;\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function getTokenCountByType(address contractAddress, uint256 tokenId) external view override returns (uint256) {\n    uint256 nftType = contractAddress.getTokenType(tokenId);\n    return _nftContractTokens[contractAddress][nftType].length();\n  }\n\n  function onERC721Received(address, address, uint256, bytes calldata) external override returns (bytes4) {\n    return IERC721Receiver(0).onERC721Received.selector;\n  }\n\n  function addToBasket(address contractAddress, uint256 tokenId)\n    external\n    override\n    onlyBasketManager\n    returns (bool)\n  {\n    uint256 nftType = contractAddress.getTokenType(tokenId);\n    require(!_nftContractTokens[contractAddress][nftType].contains(tokenId), \"GSB:E-425\");\n\n    bool added = _nftContractTokens[contractAddress][nftType].add(tokenId);\n    if (added) {\n      // NFT should have been Transferred into here via Charged-Particles\n      added = (IERC721(contractAddress).ownerOf(tokenId) == address(this));\n    }\n    return added;\n  }\n\n  function removeFromBasket(address receiver, address contractAddress, uint256 tokenId)\n    external\n    override\n    onlyBasketManager\n    returns (bool)\n  {\n    uint256 nftType = contractAddress.getTokenType(tokenId);\n    require(_nftContractTokens[contractAddress][nftType].contains(tokenId), \"GSB:E-426\");\n\n    bool removed = _nftContractTokens[contractAddress][nftType].remove(tokenId);\n    if (removed) {\n      IERC721(contractAddress).safeTransferFrom(address(this), receiver, tokenId);\n    }\n    return removed;\n  }\n\n  function executeForAccount(\n    address contractAddress,\n    uint256 ethValue,\n    bytes memory encodedParams\n  )\n    external\n    override\n    onlyBasketManager\n    returns (bytes memory)\n  {\n    (bool success, bytes memory result) = contractAddress.call{value: ethValue}(encodedParams);\n    require(success, string(result));\n    return result;\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual override onlyBasketManager {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external virtual override onlyBasketManager {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual override onlyBasketManager {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual override onlyBasketManager {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  /// @dev Throws if called by any account other than the basket manager\n  modifier onlyBasketManager() {\n    require(_basketManager == msg.sender, \"GSB:E-109\");\n    _;\n  }\n}\n"
    },
    "contracts/v1/yield/generic/ERC721/GenericSmartBasketB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// GenericSmartWallet.sol -- Part of the Charged Particles Protocol\n// Copyright (c) 2021 Firma Lux, Inc. <https://charged.fi>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155Receiver.sol\";\nimport \"../../../interfaces/ISmartBasketB.sol\";\nimport \"../../../interfaces/ITokenInfoProxy.sol\";\nimport \"../../../lib/TokenInfo.sol\";\nimport \"../../../lib/NftTokenType.sol\";\nimport \"../../../lib/BlackholePrevention.sol\";\n\n/**\n * @notice Generic ERC721-Token Smart-Basket\n * @dev Non-upgradeable Contract\n */\ncontract GenericSmartBasketB is ISmartBasketB, BlackholePrevention, IERC721Receiver, ERC1155Receiver {\n  using TokenInfo for address;\n  using NftTokenType for address;\n\n  address internal _basketManager;\n\n  // NFT TokenUUID => ERC1155 Balance\n  mapping (uint256 => uint256) internal _nftContractTokenBalance;\n  uint256 internal _nestedNftCount;\n\n\n  /***********************************|\n  |          Initialization           |\n  |__________________________________*/\n\n  function initialize(ITokenInfoProxy /* tokenInfoProxy */) public {\n    require(_basketManager == address(0x0), \"GSB:E-002\");\n    _basketManager = msg.sender;\n  }\n\n\n  /***********************************|\n  |              Public               |\n  |__________________________________*/\n\n  function getNestedNftCount() external view override returns (uint256) {\n    return _nestedNftCount;\n  }\n\n  function getTokenCountByType(address contractAddress, uint256 tokenId) external view override returns (uint256) {\n    return _nftContractTokenBalance[contractAddress.getTokenUUID(tokenId)];\n  }\n\n  function onERC721Received(address, address, uint256, bytes calldata) external override returns (bytes4) {\n    return IERC721Receiver(0).onERC721Received.selector;\n  }\n\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata) external override returns (bytes4) {\n    return IERC1155Receiver(0).onERC1155Received.selector;\n  }\n\n  // Unimplemented\n  function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external override returns (bytes4) {\n    return \"\"; // IERC1155ReceiverUpgradeable(0).onERC1155BatchReceived.selector;\n  }\n\n  function addToBasket(address contractAddress, uint256 tokenId, uint256 nftTokenAmount)\n    external\n    override\n    onlyBasketManager\n    returns (bool)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    _nftContractTokenBalance[uuid] += nftTokenAmount;\n    _nestedNftCount += nftTokenAmount;\n    return true;\n  }\n\n  function removeFromBasket(\n      address receiver,\n      address contractAddress,\n      uint256 tokenId,\n      uint256 nftTokenAmount\n    )\n    external\n    override\n    onlyBasketManager\n    returns (bool)\n  {\n    uint256 uuid = contractAddress.getTokenUUID(tokenId);\n    _nftContractTokenBalance[uuid] -= nftTokenAmount;\n    _nestedNftCount -= nftTokenAmount;\n\n    if (contractAddress.isERC1155()) {\n      IERC1155(contractAddress).safeTransferFrom(address(this), receiver, tokenId, nftTokenAmount, \"\");\n    } else {\n      IERC721(contractAddress).safeTransferFrom(address(this), receiver, tokenId);\n    }\n    return true;\n  }\n\n  function withdrawRewards(address receiver, address rewardsTokenAddress, uint256 rewardsAmount)\n    external\n    override\n    onlyBasketManager\n    returns (uint256)\n  {\n    address self = address(this);\n    IERC20 rewardsToken = IERC20(rewardsTokenAddress);\n\n    uint256 walletBalance = rewardsToken.balanceOf(self);\n    require(walletBalance >= rewardsAmount, \"GSB:E-411\");\n\n    // Transfer Rewards to Receiver\n    rewardsToken.safeTransfer(receiver, rewardsAmount);\n    return rewardsAmount;\n  }\n\n  function executeForAccount(\n    address contractAddress,\n    uint256 ethValue,\n    bytes memory encodedParams\n  )\n    external\n    override\n    onlyBasketManager\n    returns (bytes memory)\n  {\n    (bool success, bytes memory result) = contractAddress.call{value: ethValue}(encodedParams);\n    require(success, string(result));\n    return result;\n  }\n\n\n  /***********************************|\n  |          Only Admin/DAO           |\n  |      (blackhole prevention)       |\n  |__________________________________*/\n\n  function withdrawEther(address payable receiver, uint256 amount) external virtual override onlyBasketManager {\n    _withdrawEther(receiver, amount);\n  }\n\n  function withdrawERC20(address payable receiver, address tokenAddress, uint256 amount) external virtual override onlyBasketManager {\n    _withdrawERC20(receiver, tokenAddress, amount);\n  }\n\n  function withdrawERC721(address payable receiver, address tokenAddress, uint256 tokenId) external virtual override onlyBasketManager {\n    _withdrawERC721(receiver, tokenAddress, tokenId);\n  }\n\n  function withdrawERC1155(address payable receiver, address tokenAddress, uint256 tokenId, uint256 amount) external virtual override onlyBasketManager {\n    _withdrawERC1155(receiver, tokenAddress, tokenId, amount);\n  }\n\n\n  /***********************************|\n  |         Private Functions         |\n  |__________________________________*/\n\n  /// @dev Throws if called by any account other than the basket manager\n  modifier onlyBasketManager() {\n    require(_basketManager == msg.sender, \"GSB:E-109\");\n    _;\n  }\n}\n"
    },
    "erc20permit/contracts/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./IERC2612.sol\";\n\n/**\n * @author Georgios Konstantopoulos\n * @dev Extension of {ERC20} that allows token holders to use their tokens\n * without sending any transactions by setting {IERC20-allowance} with a\n * signature using the {permit} method, and then spend them via\n * {IERC20-transferFrom}.\n *\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\n */\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping (address => uint256) public override nonces;\n\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    constructor(string memory name_, string memory symbol_) internal ERC20(name_, symbol_) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name_)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free option is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an optional parameter\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ERC20Permit: invalid signature\"\n        );\n\n        _approve(owner, spender, amount);\n    }\n}\n"
    },
    "erc20permit/contracts/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}